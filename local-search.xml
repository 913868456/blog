<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AutoLayout与Autoresizing约束冲突</title>
    <link href="/blog/2020/10/30/iOS/AutoLayout%E4%B8%8EAutoresizing%E7%BA%A6%E6%9D%9F%E5%86%B2%E7%AA%81/"/>
    <url>/blog/2020/10/30/iOS/AutoLayout%E4%B8%8EAutoresizing%E7%BA%A6%E6%9D%9F%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>  经常看到使用SnapKit进行布局的时候，明明各个约束都写好了，但是进入页面的时候，日志打印显示约束冲突，如下：</p><pre><code class="hljs xml">&quot;<span class="hljs-tag">&lt;<span class="hljs-name">NSAutoresizingMaskLayoutConstraint:0x283cf6620</span> <span class="hljs-attr">h</span>=<span class="hljs-string">--&amp;</span> <span class="hljs-attr">v</span>=<span class="hljs-string">--&amp;</span> <span class="hljs-attr">ShiHuiGroup.PerformanceHeaderView:0x10c128b60.width</span> == <span class="hljs-string">0</span>   (<span class="hljs-attr">active</span>)&gt;</span>&quot;,&quot;<span class="hljs-tag">&lt;<span class="hljs-name">SnapKit.LayoutConstraint:0x28383e700@PerformanceHeaderView.swift#110</span> <span class="hljs-attr">UILabel:0x10c128d40.left</span> == <span class="hljs-string">UIView:0x10c1291b0.left</span> + <span class="hljs-attr">15.0</span>&gt;</span>&quot;,&quot;<span class="hljs-tag">&lt;<span class="hljs-name">SnapKit.LayoutConstraint:0x28383e7c0@PerformanceHeaderView.swift#110</span> <span class="hljs-attr">UILabel:0x10c128d40.right</span> == <span class="hljs-string">UIView:0x10c1291b0.right</span> <span class="hljs-attr">-</span> <span class="hljs-attr">15.0</span>&gt;</span>&quot;</code></pre><p>该问题说  Autoresizing定义的约束为 width =0，且该约束处于激活状态；<br>但是SnapiKit却设置的是Leading和Traling，有宽度的，因此会报冲突</p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>UIView 的translatesAutoresizingMaskIntoConstraints 属性默认为ture，将Autoresizing翻译成的约束与AutoLayout的约束产生冲突</p><p>官方文档解释：</p><pre><code class="hljs routeros">translatesAutoresizingMaskIntoConstraintsA Boolean value that determines whether the view’s autoresizing mask is translated into Auto Layout constraints.该属性是决定view的自动尺寸适配掩码是否翻译成 AutoLayout 的约束Note that the autoresizing mask constraints fully specify the view’s size <span class="hljs-keyword">and</span> position; therefore, you cannot <span class="hljs-builtin-name">add</span> additional constraints <span class="hljs-keyword">to</span> modify this size <span class="hljs-keyword">or</span> position without introducing conflicts. 注意 自动尺寸适配掩码已经完全指定了view的尺寸和位置，因此，你不需要添加额外的约束去修改该视图的尺寸和位置,从而避免引入冲突<span class="hljs-keyword">If</span> you want <span class="hljs-keyword">to</span> use Auto Layout <span class="hljs-keyword">to</span> dynamically calculate the size <span class="hljs-keyword">and</span> position of your view, you must <span class="hljs-builtin-name">set</span> this property <span class="hljs-keyword">to</span> <span class="hljs-literal">false</span>, <span class="hljs-keyword">and</span> then provide a non ambiguous, nonconflicting <span class="hljs-builtin-name">set</span> of constraints <span class="hljs-keyword">for</span> the view.如果想要使用AutoLayout去动态计算视图的位置和尺寸，必须将该属性置为<span class="hljs-literal">false</span>,并且给该视图提供 一个明确的，无冲突的约束集合By default, the property is <span class="hljs-builtin-name">set</span> <span class="hljs-keyword">to</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">for</span> any view you programmatically create. <span class="hljs-keyword">If</span> you <span class="hljs-builtin-name">add</span> views <span class="hljs-keyword">in</span><span class="hljs-built_in"> Interface </span>Builder, the<span class="hljs-built_in"> system </span>automatically sets this property <span class="hljs-keyword">to</span> <span class="hljs-literal">false</span>.默认情况下，该属性是<span class="hljs-literal">true</span>,如果你的视图在Interface Builder 中，系统自动将改属性置为<span class="hljs-literal">false</span></code></pre><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>将该视图的属性设置为false</p><h4 id="小技巧："><a href="#小技巧：" class="headerlink" title="小技巧："></a>小技巧：</h4><blockquote><p>如果一个视图内的多个子视图报该问题，那么只需要把其父视图的该属性关闭即可</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>AutoLayout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOSBeta版本计划退出命令</title>
    <link href="/blog/2020/10/26/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA-macOS-beta-%E8%AE%A1%E5%88%92/"/>
    <url>/blog/2020/10/26/%E5%B7%A5%E5%85%B7/%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA-macOS-beta-%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs ada">sudo softwareupdate <span class="hljs-comment">--clear-catalog </span>​​​</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS系统更新CocoaPods失效问题</title>
    <link href="/blog/2020/10/26/%E5%B7%A5%E5%85%B7/MacOS-%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%90%8E-Cocoapods%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <url>/blog/2020/10/26/%E5%B7%A5%E5%85%B7/MacOS-%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%90%8E-Cocoapods%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs awk"> <span class="hljs-regexp">//</span>重装cocoapodssudo gem uninstall cocoapods  sudo gem install -n <span class="hljs-regexp">/usr/</span>local/bin cocoapods</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CocoaPods</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS编程指南</title>
    <link href="/blog/2020/10/26/iOS/iOS-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97-(%E9%83%A8%E5%88%86%E5%AE%98%E7%BF%BB)/"/>
    <url>/blog/2020/10/26/iOS/iOS-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97-(%E9%83%A8%E5%88%86%E5%AE%98%E7%BF%BB)/</url>
    
    <content type="html"><![CDATA[<p>之前感觉网站上关于iOS编程知识内容不够权威和完整,所以一直从苹果官方文档上一点一点翻译,效率慢,占用时间多.所以就开始找官网翻译,目前已收集部分文档.前人栽树,后人乘凉.在此感谢所有优秀翻译者的分享.</p><p> (链接:<a href="https://pan.baidu.com/s/1dCG8r0">https://pan.baidu.com/s/1dCG8r0</a>  密码:3dpn)<br>里面包含</p><ul><li><em>核心动画编程指南</em> </li><li><em>多线程编程指南</em> </li><li><em>本地和远程推送编程指南</em></li><li><em>ARC官方文档</em></li><li><em>iOS并发编程指南</em></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS包瘦身</title>
    <link href="/blog/2020/10/26/iOS/iOS-App%E5%8C%85%E7%98%A6%E8%BA%AB%E6%96%B9%E6%A1%88/"/>
    <url>/blog/2020/10/26/iOS/iOS-App%E5%8C%85%E7%98%A6%E8%BA%AB%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3340896-480c6ee28376273f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-04-23 下午1.21.40.png"></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>应用瘦身</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通知编程</title>
    <link href="/blog/2020/10/26/iOS/Notification-Programming-Topics/"/>
    <url>/blog/2020/10/26/iOS/Notification-Programming-Topics/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Foundation 为传递事件发生的信息提供了一个编程架构,这篇文档描述这个架构的元素并解释如何使用他们.<br>阅读这篇文档去学习<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Notification.html#//apple_ref/doc/uid/TP40008195-CH35">notifications</a>,通知中心,和通知队列.</p><h3 id="本文档组织构成"><a href="#本文档组织构成" class="headerlink" title="本文档组织构成"></a>本文档组织构成</h3><p>该文档包含下面文章:</p><ul><li><em>通知</em>  描述封装事件信息的对象.</li><li><em>通知中心</em> 描述负责管理发送和接受通知的对象.</li><li><em>通知队列</em> 面搜狐</li><li><em>注册通知</em></li><li><em>发送通知</em></li><li><em>投递通知给指定线程</em></li></ul><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><h2 id="通知中心-描述"><a href="#通知中心-描述" class="headerlink" title="通知中心 描述"></a>通知中心 描述</h2><h2 id="通知队列"><a href="#通知队列" class="headerlink" title="通知队列"></a>通知队列</h2><h2 id="注册通知"><a href="#注册通知" class="headerlink" title="注册通知"></a>注册通知</h2><h2 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h2><h2 id="投递通知给指定线程"><a href="#投递通知给指定线程" class="headerlink" title="投递通知给指定线程"></a>投递通知给指定线程</h2><hr><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><p>  <a href="">线程编程指南</a> </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">Notification Programming Topics</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Apple登录集成</title>
    <link href="/blog/2020/03/30/iOS/Apple%E7%99%BB%E5%BD%95%E9%9B%86%E6%88%90/"/>
    <url>/blog/2020/03/30/iOS/Apple%E7%99%BB%E5%BD%95%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1.target -&gt; Signing &amp; Capabilities, 点击加号, 搜索 Sign In with Apple</p><p>2.General -&gt; Frameworks, Libraries, and Embedded Content,点击加号， 搜索 AuthenticationServices 并导入进去， Embed 选择  Embed &amp; Sign</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ul><li><p>应用启动登录校验</p><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="hljs-keyword">Any</span>]?)</span></span> -&gt; <span class="hljs-type">Bool</span> &#123;       <span class="hljs-keyword">let</span> appleIDProvider = <span class="hljs-type">ASAuthorizationAppleIDProvider</span>()       <span class="hljs-comment">//此处Userid可以为本地存储的token或其他登陆确认身份内容</span>       appleIDProvider.getCredentialState(forUserID: <span class="hljs-type">KeychainItem</span>.currentUserIdentifier) &#123; (credentialState, error) <span class="hljs-keyword">in</span>           <span class="hljs-keyword">switch</span> credentialState &#123;           <span class="hljs-keyword">case</span> .authorized:               <span class="hljs-comment">//授权有效，走登陆成功页面</span>               <span class="hljs-keyword">break</span>           <span class="hljs-keyword">case</span> .revoked, .notFound:               <span class="hljs-comment">// 走登陆页面</span>               <span class="hljs-type">DispatchQueue</span>.main.async &#123;                                  &#125;           <span class="hljs-keyword">default</span>:               <span class="hljs-keyword">break</span>           &#125;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>   &#125;</code></pre></li><li><p>创建appid登录按钮并添加到登陆页面指定位置</p></li></ul><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> authorizationButton = <span class="hljs-constructor">ASAuthorizationAppleIDButton()</span> @objcfunc handle<span class="hljs-constructor">AuthorizationAppleIDButtonPress()</span> &#123;    <span class="hljs-keyword">let</span> appleIDProvider = <span class="hljs-constructor">ASAuthorizationAppleIDProvider()</span>    <span class="hljs-keyword">let</span> request = appleIDProvider.create<span class="hljs-constructor">Request()</span>    request.requestedScopes = <span class="hljs-literal">[.<span class="hljs-identifier">fullName</span>, .<span class="hljs-identifier">email</span>]</span>        <span class="hljs-keyword">let</span> authorizationController = <span class="hljs-constructor">ASAuthorizationController(<span class="hljs-params">authorizationRequests</span>: [<span class="hljs-params">request</span>])</span>    authorizationController.delegate = self    authorizationController.presentationContextProvider = self    authorizationController.perform<span class="hljs-constructor">Requests()</span>&#125;</code></pre><ul><li><p>处理登陆事件代理</p><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LoginViewController</span>: <span class="hljs-title">ASAuthorizationControllerDelegate</span> </span>&#123;    <span class="hljs-comment">/// - Tag: 认证状态回调信息</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">authorizationController</span><span class="hljs-params">(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization)</span></span> &#123;        <span class="hljs-keyword">switch</span> authorization.credential &#123;        <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> appleIDCredential <span class="hljs-keyword">as</span> <span class="hljs-type">ASAuthorizationAppleIDCredential</span>: <span class="hljs-comment">//此处为appleID 认证</span>                        <span class="hljs-comment">// 根据以下信息在后端创建账户</span>            <span class="hljs-keyword">let</span> userIdentifier = appleIDCredential.user  <span class="hljs-comment">//用户唯一标志符</span>            <span class="hljs-keyword">let</span> fullName = appleIDCredential.fullName            <span class="hljs-keyword">let</span> email = appleIDCredential.email                        <span class="hljs-comment">// 后端请求注册账户及密码及登录成功后存储登录信息处理（这里根据业务情况来决定是否重新注册用户信息）</span>                        <span class="hljs-comment">// 成功后进入登陆后页面</span>            <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> passwordCredential <span class="hljs-keyword">as</span> <span class="hljs-type">ASPasswordCredential</span>: <span class="hljs-comment">//此处为账号密码认证</span>                    <span class="hljs-comment">// Sign in using an existing iCloud Keychain credential.</span>            <span class="hljs-keyword">let</span> username = passwordCredential.user            <span class="hljs-keyword">let</span> password = passwordCredential.password                        <span class="hljs-comment">// 做一些账号密码的登录处理</span>                        <span class="hljs-comment">// 成功后进入登陆后页面</span>        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>        &#125;    &#125;        <span class="hljs-comment">/// - Tag: 获取认证状态失败后的错误信息</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">authorizationController</span><span class="hljs-params">(controller: ASAuthorizationController, didCompleteWithError error: Error)</span></span> &#123;        <span class="hljs-comment">// Handle error.</span>    &#125;&#125;</code></pre></li><li><p>处理视图代理</p><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LoginViewController</span>: <span class="hljs-title">ASAuthorizationControllerPresentationContextProviding</span> </span>&#123;    <span class="hljs-comment">/// - Tag: 提供presention视图</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentationAnchor</span><span class="hljs-params">(<span class="hljs-keyword">for</span> controller: ASAuthorizationController)</span></span> -&gt; <span class="hljs-type">ASPresentationAnchor</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.view.window!    &#125;&#125;</code></pre></li><li><p>进入登录视图进行登陆验证 （此处可根据业务情况来决定是否添加）</p><pre><code class="hljs reasonml">override func view<span class="hljs-constructor">DidAppear(<span class="hljs-params">_</span> <span class="hljs-params">animated</span>: Bool)</span> &#123;    super.view<span class="hljs-constructor">DidAppear(<span class="hljs-params">animated</span>)</span>    perform<span class="hljs-constructor">ExistingAccountSetupFlows()</span>&#125;func perform<span class="hljs-constructor">ExistingAccountSetupFlows()</span> &#123;    <span class="hljs-comment">// Prepare requests for both Apple ID and password providers.</span>    <span class="hljs-keyword">let</span> requests = <span class="hljs-literal">[ASA<span class="hljs-identifier">uthorizationAppleIDProvider</span>().<span class="hljs-identifier">createRequest</span>(),</span><span class="hljs-literal">                    ASA<span class="hljs-identifier">uthorizationPasswordProvider</span>().<span class="hljs-identifier">createRequest</span>()]</span>        <span class="hljs-comment">// Create an authorization controller with the given requests.</span>    <span class="hljs-keyword">let</span> authorizationController = <span class="hljs-constructor">ASAuthorizationController(<span class="hljs-params">authorizationRequests</span>: <span class="hljs-params">requests</span>)</span>    authorizationController.delegate = self    authorizationController.presentationContextProvider = self    authorizationController.perform<span class="hljs-constructor">Requests()</span>&#125;</code></pre></li></ul><h2 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h2><ul><li>根据<code>userIdentifier</code>退出登陆流程</li></ul><p>##参考资料<br><a href="https://developer.apple.com/documentation/authenticationservices/implementing_user_authentication_with_sign_in_with_apple">Implementing User Authentication with Sign in with Apple</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Carthage安装</title>
    <link href="/blog/2019/05/22/%E5%B7%A5%E5%85%B7/Carthage-%E5%AE%89%E8%A3%85/"/>
    <url>/blog/2019/05/22/%E5%B7%A5%E5%85%B7/Carthage-%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="Homebrew-更新"><a href="#Homebrew-更新" class="headerlink" title="Homebrew 更新"></a>Homebrew 更新</h3><pre><code class="hljs dsconfig"><span class="hljs-string">brew </span><span class="hljs-string">update</span><span class="hljs-string"></span><span class="hljs-string">#</span> <span class="hljs-string">brew </span>有时候更新会没有反应,以下是解决方案<span class="hljs-comment"># 进入 brew 的仓库根目录</span><span class="hljs-string">cd </span><span class="hljs-string">&quot;$(brew --repo)&quot;</span><span class="hljs-comment"># 修改为中科大的源</span><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">mirrors.</span><span class="hljs-string">ustc.</span><span class="hljs-string">edu.</span><span class="hljs-string">cn/</span><span class="hljs-string">brew.</span><span class="hljs-string">git</span><span class="hljs-string">cd </span><span class="hljs-string">&quot;$(brew --repo)/Library/Taps/homebrew/homebrew-cask&quot;</span><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">mirrors.</span><span class="hljs-string">ustc.</span><span class="hljs-string">edu.</span><span class="hljs-string">cn/</span><span class="hljs-string">homebrew-cask.</span><span class="hljs-string">git</span><span class="hljs-string">cd </span><span class="hljs-string">&quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><span class="hljs-string">git </span><span class="hljs-string">remote </span><span class="hljs-built_in">set-url</span> <span class="hljs-string">origin </span><span class="hljs-string">https:</span>//<span class="hljs-string">mirrors.</span><span class="hljs-string">ustc.</span><span class="hljs-string">edu.</span><span class="hljs-string">cn/</span><span class="hljs-string">homebrew-core.</span><span class="hljs-string">git</span><span class="hljs-string">brew </span><span class="hljs-string">update </span>-v</code></pre><h3 id="Carthage-更新"><a href="#Carthage-更新" class="headerlink" title="Carthage 更新"></a>Carthage 更新</h3><pre><code class="hljs routeros">brew<span class="hljs-built_in"> upgrade </span>carthage</code></pre><h3 id="创建Cartfile文件"><a href="#创建Cartfile文件" class="headerlink" title="创建Cartfile文件"></a>创建Cartfile文件</h3><pre><code class="hljs properties"><span class="hljs-attr">cd</span> <span class="hljs-string">项目根目录</span><span class="hljs-attr">touch</span> <span class="hljs-string">Cartfile</span></code></pre><h3 id="cartfile添加指定库"><a href="#cartfile添加指定库" class="headerlink" title="cartfile添加指定库"></a>cartfile添加指定库</h3><pre><code class="hljs apache"><span class="hljs-attribute">github</span> <span class="hljs-string">&quot;SVProgressHUD/SVProgressHUD&quot;</span> ~&gt; <span class="hljs-number">1</span>.<span class="hljs-number">0</span></code></pre><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><pre><code class="hljs pgsql">carthage <span class="hljs-keyword">update</span> <span class="hljs-comment">--platform iOS </span></code></pre><h3 id="添加framwork"><a href="#添加framwork" class="headerlink" title="添加framwork"></a>添加framwork</h3><p>点击”项目名称”-&gt; “target” -&gt; “Gerneral”，在最底部找到”Linked Frameworks and Libraries”。</p><h3 id="添加run-script"><a href="#添加run-script" class="headerlink" title="添加run script"></a>添加run script</h3><p>点击”项目名称”-&gt; “target” -&gt; “Build Phases’, 点击 “+”-&gt; “New Run Script Phase”.<br>脚本内容</p><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>carthage <span class="hljs-keyword">copy</span>-frameworks</code></pre><p>编辑 “Input Files”路径</p><pre><code class="hljs awk">$(SRCROOT)<span class="hljs-regexp">/Carthage/</span>Build<span class="hljs-regexp">/iOS/</span>Kingfisher.framework</code></pre><p>编辑”Output Files”路径</p><pre><code class="hljs reasonml"><span class="hljs-constructor">$(BUILT_PRODUCTS_DIR)</span>/<span class="hljs-constructor">$(FRAMEWORKS_FOLDER_PATH)</span>/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Kingfisher</span>.</span></span>framework</code></pre><p>Done!</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://crowall.com/topic/412">HomeBrew 修改镜像源解决慢的问题</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>依赖管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fastlane自动打包上传</title>
    <link href="/blog/2019/05/08/%E5%B7%A5%E5%85%B7/fastlane--%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0/"/>
    <url>/blog/2019/05/08/%E5%B7%A5%E5%85%B7/fastlane--%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><pre><code class="hljs sql"><span class="hljs-comment">#安装fastlane</span>sudo gem <span class="hljs-keyword">install</span> -n /usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">bin</span> fastlane</code></pre><h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><pre><code class="hljs properties"><span class="hljs-attr">cd</span> <span class="hljs-string">项目目录</span><span class="hljs-attr">fastlane</span> <span class="hljs-string">init</span></code></pre><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>根据自己的需要配置不同的选择项</p><ul><li><p>使用目的<br><img src="https://upload-images.jianshu.io/upload_images/3340896-58bf85526d9a4d31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-04-25 下午7.28.54.png"></p></li><li><p>输入appleID 和 密码<br><img src="https://upload-images.jianshu.io/upload_images/3340896-474c8e0de8d5364c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="[图片上传中...(屏幕快照 2019-04-25 下午7.29.50.png-931c1f-1557283422808-0)]"></p></li><li><p>输入6位验证码<br><img src="https://upload-images.jianshu.io/upload_images/3340896-175c5718683cc2bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-04-25 下午7.29.50.png"></p></li><li><p>选择y<br><img src="https://upload-images.jianshu.io/upload_images/3340896-c5f43217481f0bcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-04-25 下午7.29.58.png"></p></li></ul><h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><p>项目目录下生成fastlane文件目录<br> <pre><code class="hljs properties"><span class="hljs-attr">cd</span> <span class="hljs-string">fastlane</span><span class="hljs-attr">vi</span> <span class="hljs-string">Fastfile</span></code></pre><br>将下面的文件内容拷贝进去,项目名称, <code>bundleId</code>, <code>profileName</code>, <code>workspace</code> ,<code>outputname</code>自己修改,<br><code>api_key</code>,<code>user_key</code>自己在蒲公英内测分发 –&gt; api 查看自己应用的 apikey和 userkey</p><pre><code class="hljs elixir">default_platform(<span class="hljs-symbol">:ios</span>)platform <span class="hljs-symbol">:ios</span> <span class="hljs-keyword">do</span>  desc <span class="hljs-string">&quot;Push a new release build to the App Store&quot;</span>  lane <span class="hljs-symbol">:release</span> <span class="hljs-keyword">do</span>    build_app(<span class="hljs-symbol">workspace:</span> <span class="hljs-string">&quot;xxx.xcworkspace&quot;</span>, <span class="hljs-symbol">scheme:</span> <span class="hljs-string">&quot;xxx&quot;</span>)    <span class="hljs-comment"># 修改为自己的项目名称</span>    upload_to_app_store  <span class="hljs-keyword">end</span>  lane <span class="hljs-symbol">:beta</span> <span class="hljs-keyword">do</span>  build_ios_app(  <span class="hljs-symbol">workspace:</span> <span class="hljs-string">&quot;xxx.xcworkspace&quot;</span>,  <span class="hljs-comment"># 替换成自己的项目名</span>  <span class="hljs-symbol">configuration:</span> <span class="hljs-string">&quot;Release&quot;</span>,  <span class="hljs-symbol">scheme:</span> <span class="hljs-string">&quot;HotTravel&quot;</span>,  <span class="hljs-symbol">silent:</span> <span class="hljs-keyword">true</span>,  <span class="hljs-symbol">clean:</span> <span class="hljs-keyword">true</span>,  <span class="hljs-symbol">export_method:</span> <span class="hljs-string">&quot;ad-hoc&quot;</span>,  <span class="hljs-symbol">export_options:</span> &#123;      <span class="hljs-symbol">provisioningProfiles:</span> &#123;          <span class="hljs-string">&quot;bundle ID&quot;</span> =&gt; <span class="hljs-string">&quot;adhoc profile name&quot;</span>   <span class="hljs-comment"># 修改为自己的adhoc profile文件名及buildle ID</span>       &#125;  &#125;,  <span class="hljs-symbol">output_directory:</span> <span class="hljs-string">&quot;./build&quot;</span>,   <span class="hljs-symbol">output_name:</span> <span class="hljs-string">&quot;xxx.ipa&quot;</span>,       <span class="hljs-symbol">sdk:</span> <span class="hljs-string">&quot;iOS 12.2&quot;</span>        <span class="hljs-comment"># use SDK as the name or path of the base SDK when building the project.</span>)  pgyer(<span class="hljs-symbol">api_key:</span> <span class="hljs-string">&quot;xxxxxxxxxx&quot;</span>, <span class="hljs-symbol">user_key:</span> <span class="hljs-string">&quot;xxxxxxxxxx&quot;</span>)   <span class="hljs-comment"># 自己在蒲公英内测分发 --&gt; api 查看自己应用的 apikey和 userkey</span>  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre><h5 id="打包上传"><a href="#打包上传" class="headerlink" title="打包上传"></a>打包上传</h5><ul><li>蒲公英 ad-hoc <pre><code class="hljs awk">fastlane add_plugin pgyer  <span class="hljs-regexp">//</span>添加蒲公英插件fastlane init  <span class="hljs-regexp">//</span>添加完一定要初始化,否则上传不会成功</code></pre>⚠️ 注意<br>添加完蒲公英插件一定要初始化,否则上传不会成功!<br>添加完蒲公英插件一定要初始化,否则上传不会成功!<br>添加完蒲公英插件一定要初始化,否则上传不会成功!</li></ul><p>ad-hoc包</p><pre><code class="hljs awk">fastlane beta  <span class="hljs-regexp">//</span>ad-hoc包自动分发到蒲公英</code></pre><ul><li>Release <pre><code class="hljs arduino">fastlane <span class="hljs-built_in">release</span></code></pre>⚠️ 注意</li></ul><p>1.一定要有Xcode的证书或者p12文件,否则,打包成功后上传会失败!<br>2.打发布包第一次的时候需要输入 apple App专用密码,登录设置 <a href="%5Bhttps://appleid.apple.com/account/manage%5D(https://appleid.apple.com/account/manage)">Apple account manage</a><br><img src="https://upload-images.jianshu.io/upload_images/3340896-0bf9efb6bcd739a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2019-08-06 下午4.08.45.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.fastlane.tools/">fastlane docs</a><br><a href="https://www.pgyer.com/doc/view/fastlane">蒲公英文档中心</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fastlane</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/blog/2019/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/blog/2019/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构?"></a>什么是数据结构?</h2><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合.</p><p>通常有以下四类基本结构:</p><ul><li>集合</li><li>线性结构</li><li>树形结构</li><li>图状结构或网状结构</li></ul><p>数据的存储结构:</p><ul><li>顺序存储结构</li><li>链式存储结构</li></ul><p>高级程序语言中的数据类型可以分为两类:<br>一类是非结构的原子类型.  原子类型的值是不可分解的,例如C语言中的基本类型(整型,实型,字符型,枚举类型)指针类型和空类型.<br>另一类是结构类型.结构类型的值是由若干成分按某种结构组成的,因此可以分解的,并且它的成分可以是结构的,也可以是非结构的. </p><p>算法和算法分析<br>算法是对特定问题求解步骤的一种描述,他是指令的有限序列,其中每一条指令表示一个或多个操作;此外一个算法还具有下列5个重要特性:</p><ul><li>有穷性</li><li>确定性</li><li>可行性</li><li>输入</li><li>输出    </li></ul><p>算法的时间复杂度<br>T(n) = O(f(n))<br>算法的空间复杂度<br>S(n) = O(f(n))</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是一个相当灵活的数据结构,它的长度可根据需要增长或缩短,即对线性表的数据元素不仅可以进行访问,还可以进行插入和删除<br>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素.<br>线性表的插入和删除的时间复杂度为O(n)</p><h3 id="线性链表-单链表"><a href="#线性链表-单链表" class="headerlink" title="线性链表 (单链表)"></a>线性链表 (单链表)</h3><p>除了存储数据本身信息外,还需存储一个指示其直接后继的信息(即直接后继的存储位置),这种存储映像称作 <strong>结点</strong>,包含两个域,数据域和指针域</p><h3 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h3><p>表中最后一个结点的指针域指向头结点,整个链表形成一个环</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>包含两个指针域,其一指向直接后继,另一指向直接前趋.</p><h3 id="双向循环链表-略"><a href="#双向循环链表-略" class="headerlink" title="双向循环链表 (略)"></a>双向循环链表 (略)</h3><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈是仅在表尾进行插入和删除操作的线性表,队列是只允许在表的一段进行插入元素,在另一端进行删除元素的线性表<br>栈 (后进先出)<br>队列(先进先出) </p><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><p>树是n个结点的有限集.树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树数成为结点的度.<br>森林是m(m&gt;=0)棵互不相交的树的集合.</p><p>遍历二叉树</p><ul><li>先序遍历 </li></ul><p>1.访问根节点;<br>2.先序遍历左子树;<br>3.先序遍历有子树.</p><ul><li>中序遍历</li></ul><p>1.中序遍历左子树;<br>2.访问根节点;<br>3.中序遍历右子树.</p><ul><li>后序遍历</li></ul><p>1.后序遍历左子树;<br>2.后序遍历有字数;<br>3.访问根结点.</p><h3 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h3><p>树的带权路径长度为树中所有叶子节点的带权路径长度之和.n个叶子节点分别带权,其中带权路径长度最小的二叉树称作<strong>最优二叉树</strong>或<strong>赫夫曼树</strong></p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><ul><li>若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值;</li><li>若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值;</li><li>它的左右子树也分别为二叉排序树.</li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>它的左子树和右子树都是平衡二叉树,且左子树和右子树的的深度之差的绝对值不超过1.</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>根据设定的哈希函数H(key)和处理冲突的方法将一组关键字映像到一个有限的连续的地址集(区间)上,并以关键字在地址集中的”像”作为记录在表中的存储位置,这种表便称为<strong>哈希表</strong>,所得存储位置称为<strong>哈希地址</strong></p><h4 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h4><ul><li>直接定址法</li><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>除留取余法</li><li>随机数法 </li></ul><p>处理冲突的方法</p><ul><li>开放定址法</li><li>再哈希法</li><li>链地址法</li><li>建立一个公共溢出区</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>插入排序</li></ul><p><strong>直接插入排序</strong> 是一种最简单的排序方法,它的基本操作是将一个记录插入到已排好序的有序表中,从而得到一个新的,记录数增1的有序表</p><ul><li>交换排序</li><li>选择排序</li><li>归并排序</li><li>计数排序</li><li>基数排序</li><li>希尔排序</li><li>堆排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/blog/2019/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/blog/2019/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是编译程序"><a href="#什么是编译程序" class="headerlink" title="什么是编译程序?"></a>什么是编译程序?</h2><p>从功能上看,一个编译程序就是一个语言翻译程序.语言翻译程序是把一种语言(称作源语言)书写的程序翻译成另外一种语言(称作目标语言)的等价程序.</p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-58117c524cd79319.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译程序功能及高级源程序的处理过程"></p><ul><li>编译的各个阶段<br><img src="https://upload-images.jianshu.io/upload_images/3340896-b8ccae78df765998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译各个阶段"></li><li>编译程序的结构</li><li>*编译程序** 按照执行顺序包含 <em>词法分析程序</em>  <em>语法分析程序</em>  <em>语义分析程序</em> <em>中间代码生成程序</em> <em>代码优化程序</em> <em>目标代码生成程序</em><br>   另外 <em>表格管理程序</em> 及 <em>出错处理程序</em> 伴随整个编译过程.<br>   表格管理程序主要负责编译过程中各种信息的保留;编译过程发现源程序有错误,编译程序应报告错误性质和错误发生的位置,并将错误造成的影响限制在最小范围内,这些工作由出错处理程序来完成.</li></ul><h2 id="解释程序和编译程序的区别"><a href="#解释程序和编译程序的区别" class="headerlink" title="解释程序和编译程序的区别?"></a>解释程序和编译程序的区别?</h2><p>编译程序是一个语言处理程序,它把一个高级语言程序翻译成某个机器的汇编语言程序或二进制代码程序,这个二进制代码程序在机器上运行以生成结果;<br>解释程序不需要在运行前先把源程序翻译成目标代码,也可以实现在某台机器上运行程序并生成结果.</p><p>解释程序接收某个语言的程序并立即运行这个源程序.它的工作模式是一个个的获取,分析并执行源程序语句,一旦第一个语句分析结束,源程序便开始运行并且生成结果,它特别适合程序员以交互方式工作的情况,即希望在获取下一个语句之前了解每个语句的执行结果,允许执行时修改程序. (如Shell解释程序,SQL解释程序)</p><h2 id="运行时存储组织"><a href="#运行时存储组织" class="headerlink" title="运行时存储组织"></a>运行时存储组织</h2><p>目标程序在目标机环境中运行时,都置身于自己的一个运行时存储空间.<br>  编译程序所产生的目标程序本身大小通常是确定的,一般存放在指定的专用存储区域,即<strong>代码区</strong><br>  相应地,目标程序运行过程中需要创建或访问的数据对象将存储在<strong>数据区</strong>,数据对象包括用户定义的各种类型的命名对象(如变量和常量),作为保留中间结果和传递参数的临时对象及调用过程时所需的连接信息等.</p><p>面向数据对象的运行时存储组织所关注的几个重要问题:</p><ul><li><strong>数据对象的表示</strong><br>需要明确源语言中各类数据对象在目标机中的表示形式.</li><li><strong>表达式计算</strong><br>需要明确如何正确有效地组织表达式的计算过程</li><li><strong>存储分配策略</strong><br>核心问题是如何正确有效地分配不同作用域或不同生命周期的数据对象的存储</li><li><strong>过程实现</strong><br>如何实现过程/函数调用以及参数传递<h3 id="程序运行时存储空间的布局"><a href="#程序运行时存储空间的布局" class="headerlink" title="程序运行时存储空间的布局"></a>程序运行时存储空间的布局</h3>运行时的存储空间从逻辑上可分为<code>代码区</code>和<code>数据区</code>两个主要部分,一般情况下至少含有 <code>保留地址区</code> <code>代码区</code> <code>静态数据区</code> <code>动态数据区</code></li></ul><p>存储分配策略<br>1.静态存储分配, 即在编译期间为数据对象分配存储空间.<br>2.栈式存储分配   内存地址由高到低<br>3.堆式存储分配   内存地址由低到高</p><h2 id="面向对象语言存储分配策略"><a href="#面向对象语言存储分配策略" class="headerlink" title="面向对象语言存储分配策略"></a>面向对象语言存储分配策略</h2><h3 id="类和对象的角色"><a href="#类和对象的角色" class="headerlink" title="类和对象的角色"></a>类和对象的角色</h3><ul><li>类扮演的角色是程序的静态定义.类是一组运行时对象的共同性质的静态描述.类包含两类特征成员,属性和方法</li><li>对象扮演的角色是程序运行时的动态结构. 每个对象都是某个类的实例.<br>面向对象机制的主要特点, <code>封装</code> <code>继承</code> <code>多态</code> <code>重载</code> <code>动态绑定</code><h3 id="面向对象程序运行时的特征"><a href="#面向对象程序运行时的特征" class="headerlink" title="面向对象程序运行时的特征"></a>面向对象程序运行时的特征</h3></li><li>对象是类的一个实例</li><li>执行一个面向对象程序就是创建系统根类的一个实例,并调用该实例的创建该过程.</li><li>创建对象的过程实现该对象的初始化;对于根类而言,创建其对象即执行该系统.</li></ul><p>对象的存储包含对象各个属性的存储以及方法索引表,<br>方法的动态绑定,是将当前实例方法对应的实例作为参数传进去(即self 或 this 指向的实例作为参数传给该方法  )</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreGraphics</title>
    <link href="/blog/2019/03/14/iOS/Core-Graphics/"/>
    <url>/blog/2019/03/14/iOS/Core-Graphics/</url>
    
    <content type="html"><![CDATA[<p>采用 <code>Quartz</code> 高级绘画引擎提供基于路径的绘制,形变,颜色管理,离屏渲染,渐变与阴影,图片数据管理,图片创建,图片蒙版,同样的PDF创建,显示和解析.</p><p>###几何数据类型<br><a href="https://developer.apple.com/documentation/coregraphics/cgfloat">CGFloat</a></p><p><a href="https://developer.apple.com/documentation/coregraphics/cgpoint">CGPoint</a></p><p><a href="https://developer.apple.com/documentation/coregraphics/cgsize">CGSize</a></p><p><a href="https://developer.apple.com/documentation/coregraphics/cgrect">CGRect</a></p><p><a href="https://developer.apple.com/documentation/coregraphics/cgvector">CGVector</a></p><p><a href="https://developer.apple.com/documentation/coregraphics/cgaffinetransform">CGAffineTransform</a></p><h3 id="2D-绘制"><a href="#2D-绘制" class="headerlink" title="2D 绘制"></a>2D 绘制</h3><p><a href="">CGContext</a></p><h4 id="常用API说明"><a href="#常用API说明" class="headerlink" title="常用API说明"></a>常用API说明</h4><pre><code class="hljs swift"><span class="hljs-comment">/*构建绘制路径*/</span><span class="hljs-comment">//在图形环境中创建一个新的空路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">beginPath</span><span class="hljs-params">()</span></span><span class="hljs-comment">//在指定点开始一个新的子路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">move</span><span class="hljs-params">(to: CGPoint)</span></span><span class="hljs-comment">//从当前点添加一条直线到指定点</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addLine</span><span class="hljs-params">(to: CGPoint)</span></span><span class="hljs-comment">//根据数组内的点连线,其中数组里的第一个点作为线的初始起点</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addLines</span><span class="hljs-params">(between: [CGPoint])</span></span><span class="hljs-comment">//添加一个矩形路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addRect</span><span class="hljs-params">(CGRect)</span></span><span class="hljs-comment">//添加多个矩形路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addRects</span><span class="hljs-params">([CGRect])</span></span><span class="hljs-comment">//添加椭圆</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addEllipse</span><span class="hljs-params">(<span class="hljs-keyword">in</span>: CGRect)</span></span><span class="hljs-comment">//添加圆</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addArc</span><span class="hljs-params">(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)</span></span><span class="hljs-comment">//三阶贝塞尔曲线</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addCurve</span><span class="hljs-params">(to end: CGPoint, control1: CGPoint, control2: CGPoint)</span></span><span class="hljs-comment">//二阶贝塞尔曲线</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addQuadCurve</span><span class="hljs-params">(to end: CGPoint, control: CGPoint)</span></span><span class="hljs-comment">//关闭当前的子路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closePath</span><span class="hljs-params">()</span></span><span class="hljs-comment">/*绘制当前路径*/</span><span class="hljs-comment">//沿着当前路径绘制线</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strokePath</span><span class="hljs-params">()</span></span><span class="hljs-comment">/*绘制形状*/</span><span class="hljs-comment">//透明</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clear</span><span class="hljs-params">(CGRect)</span></span><span class="hljs-comment">//使用填充色在当前的图形状态下填充指定区域</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fill</span><span class="hljs-params">(CGRect)</span></span><span class="hljs-comment">//填充多个区域</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fill</span><span class="hljs-params">([CGRect])</span></span><span class="hljs-comment">//填充区域内的椭圆形</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fillEllipse</span><span class="hljs-params">(<span class="hljs-keyword">in</span>: CGRect)</span></span><span class="hljs-comment">//画指定区域的路径</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stoke</span><span class="hljs-params">(CGRect)</span></span><span class="hljs-comment">//画椭圆</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stokeEllipse</span><span class="hljs-params">(<span class="hljs-keyword">in</span>: CGRect)</span></span><span class="hljs-comment">//画多条线段</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stokeLineSegments</span><span class="hljs-params">(between: [CGPoint])</span></span><span class="hljs-comment">/*画渐变和阴影*/</span><span class="hljs-comment">//直线平滑过渡</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">drawLinearGradient</span><span class="hljs-params">(<span class="hljs-number">_</span> gradient: CGGradient, </span></span><span class="hljs-function"><span class="hljs-params">                  start startPoint: CGPoint, </span></span><span class="hljs-function"><span class="hljs-params">                    end endPoint: CGPoint, </span></span><span class="hljs-function"><span class="hljs-params">                options: CGGradientDrawingOptions)</span></span><span class="hljs-comment">//扇面渐变过渡</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">drawRadialGradient</span><span class="hljs-params">(<span class="hljs-number">_</span> gradient: CGGradient, </span></span><span class="hljs-function"><span class="hljs-params">            startCenter: CGPoint, </span></span><span class="hljs-function"><span class="hljs-params">            startRadius: CGFloat, </span></span><span class="hljs-function"><span class="hljs-params">              endCenter: CGPoint, </span></span><span class="hljs-function"><span class="hljs-params">              endRadius: CGFloat, </span></span><span class="hljs-function"><span class="hljs-params">                options: CGGradientDrawingOptions)</span></span>                           <span class="hljs-comment">/*绘制文字*/</span><span class="hljs-comment">//文字绘制位置</span><span class="hljs-keyword">var</span> textPosition: <span class="hljs-type">CGPoint</span><span class="hljs-comment">//设置字符间距</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setCharacterSpacing</span><span class="hljs-params">(CGFloat)</span></span><span class="hljs-comment">//设置字体</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setFont</span><span class="hljs-params">(CGFont)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setFontSize</span><span class="hljs-params">(CGFloat)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setTextDrawingMode</span><span class="hljs-params">(CGTextDrawingMode)</span></span><span class="hljs-comment">/*设置填充,描画,和阴影颜色*/</span><span class="hljs-comment">//填充色</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setFillColor</span><span class="hljs-params">(CGColor)</span></span><span class="hljs-comment">//阴影</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setShadow</span><span class="hljs-params">(offset: CGSize, blur: CGFloat)</span></span>  <span class="hljs-comment">//描画线颜色</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setStokeColor</span><span class="hljs-params">(CGColor)</span></span>  <span class="hljs-comment">//设置透明度</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setAlpha</span><span class="hljs-params">(CGFloat)</span></span><span class="hljs-comment">/*裁切路径*/</span>   <span class="hljs-comment">//裁切区域内指定矩形</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clip</span><span class="hljs-params">(to: CGRect)</span></span><span class="hljs-comment">//裁切区域内多个矩形</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clip</span><span class="hljs-params">(to: [CGRect])</span></span> <span class="hljs-comment">//裁切区域内用图片填充</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clip</span><span class="hljs-params">(to: CGRect, mask: CGImage)</span></span><span class="hljs-comment">/*设置路径绘制选项*/</span><span class="hljs-comment">//是否允许反锯齿</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setAllowAntialiasing</span><span class="hljs-params">(Bool)</span></span><span class="hljs-comment">//平滑度</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setFlatness</span><span class="hljs-params">(CGFloat)</span></span><span class="hljs-comment">//线帽</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setLineCap</span><span class="hljs-params">(CGLineCap)</span></span><span class="hljs-comment">//虚线</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setLineDash</span><span class="hljs-params">(phase: CGFloat, lengths: [CGFloat])</span></span><span class="hljs-comment">//线连接处样式</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setLineJoin</span><span class="hljs-params">(CGLineJoin)</span></span><span class="hljs-comment">//线宽</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setLineWidth</span><span class="hljs-params">(CGFloat)</span></span> <span class="hljs-comment">/*保存上下文状态*/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">saveGState</span><span class="hljs-params">()</span></span><span class="hljs-comment">//保存最新的状态,需要之前保存过一次状态,否则会崩溃</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreGState</span><span class="hljs-params">()</span></span><span class="hljs-comment">/*管理图形上下文*/</span><span class="hljs-comment">//强制立即绘制</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span><span class="hljs-comment">//标记窗口上下文需要更新</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">synchronize</span><span class="hljs-params">()</span></span><span class="hljs-comment">/*管理位图*/</span><span class="hljs-comment">//位图信息</span><span class="hljs-keyword">var</span> bitmapInfo: <span class="hljs-type">CGBitmapInfo</span><span class="hljs-comment">//像素高</span><span class="hljs-keyword">var</span> height: <span class="hljs-type">Int</span><span class="hljs-comment">//像素宽</span><span class="hljs-keyword">var</span> width: <span class="hljs-type">Int</span><span class="hljs-comment">//生成一个CGImage</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeImage</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">CGImage?</span></code></pre><p><a href="https://developer.apple.com/documentation/coregraphics/cgpath">CGPath</a></p><p><a href="https://developer.apple.com/documentation/coregraphics/cgmutablepath">CGMutablePath</a></p><p><a href="">CGLayer</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/documentation/coregraphics">Core Graphics</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreGraphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PhotoKit</title>
    <link href="/blog/2019/03/13/iOS/PhotoKit/"/>
    <url>/blog/2019/03/13/iOS/PhotoKit/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3340896-b7a0956c45c82900.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Photos.png"></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>苹果的PhotoKit,是提供给开发者的对本地相册库的和iCloud 相册的资源进行操作的API,所有资源以PHAsset的形式来提供给PhotoKit使用,同时本地的图片库和iCloud图片的变动通知,会发送给PhotoKit;同时,PhotoKit也可以通过 <strong>变更请求</strong> (编辑请求,改变请求,删除请求…)来对资源进行变更.</p><h3 id="资源的操作"><a href="#资源的操作" class="headerlink" title="资源的操作"></a>资源的操作</h3><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PHPhotoLibrary</span>.</span></span>shared<span class="hljs-literal">()</span>.register(self); <span class="hljs-comment">// viewDidLoad 执行</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PHPhotoLibrary</span>.</span></span>shared<span class="hljs-literal">()</span>.unregister<span class="hljs-constructor">ChangeObserver(<span class="hljs-params">self</span>)</span>;<span class="hljs-comment">//deinit 方法中执行</span>extension MasterViewController: PHPhotoLibraryChangeObserver &#123;<span class="hljs-comment">//资源变动后的通知</span>    <span class="hljs-comment">/// - Tag: RespondToChanges</span>    func photo<span class="hljs-constructor">LibraryDidChange(<span class="hljs-params">_</span> <span class="hljs-params">changeInstance</span>: PHChange)</span> &#123;                <span class="hljs-comment">// Change notifications may originate from a background queue.</span>        <span class="hljs-comment">// Re-dispatch to the main queue before acting on the change,</span>        <span class="hljs-comment">// so you can update the UI.</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DispatchQueue</span>.</span></span>main.sync &#123;        &#125;    &#125;&#125;</code></pre><h3 id="资源的查找"><a href="#资源的查找" class="headerlink" title="资源的查找"></a>资源的查找</h3><p>排序和筛选条件我们可以根据 <a href="https://developer.apple.com/documentation/photokit/phfetchoptions">PHFetchOptions</a>里面的 <code>predicate</code> 和 <code>sortDescriptors</code> 属性来设置, 里面也包含支持 <strong>predicate</strong> 和 <strong>sort</strong> 的 keys, 可以参考 <a href="https://nshipster.cn/nspredicate/">NSPredicate</a> 和  <a href="https://nshipster.cn/nssortdescriptor/">NSSortDescriptor</a> 来了解更多筛选和排序条件的设置.</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PHAssetCollection</span>.</span></span>fetch<span class="hljs-constructor">AssetCollections(<span class="hljs-params">with</span>: .<span class="hljs-params">smartAlbum</span>, <span class="hljs-params">subtype</span>: .<span class="hljs-params">albumRegular</span>, <span class="hljs-params">options</span>: <span class="hljs-params">nil</span>)</span><span class="hljs-comment">//智能相册</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PHCollectionList</span>.</span></span>fetch<span class="hljs-constructor">TopLevelUserCollections(<span class="hljs-params">with</span>: <span class="hljs-params">nil</span>)</span><span class="hljs-comment">//用户相册</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PHAsset</span>.</span></span>fetch<span class="hljs-constructor">Assets(<span class="hljs-params">with</span>: <span class="hljs-params">phtotfectchOptions</span>)</span><span class="hljs-comment">//图片资源</span></code></pre><h3 id="资源的变更请求"><a href="#资源的变更请求" class="headerlink" title="资源的变更请求"></a>资源的变更请求</h3><pre><code class="hljs less"><span class="hljs-comment">//Asynchronously runs a block that requests changes to be performed in the photo library.  异步请求</span><span class="hljs-selector-tag">func</span>  <span class="hljs-selector-tag">performChanges</span>(<span class="hljs-attribute">_</span>:<span class="hljs-attribute">completionHandler</span>:)<span class="hljs-comment">//Synchronously runs a block that requests changes to be performed in the photo library.  同步请求</span><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">performChangesAndWait</span>(_ <span class="hljs-attribute">changeBlock</span>: <span class="hljs-variable">@escaping</span> () -&gt; Void) <span class="hljs-selector-tag">throws</span></code></pre><h3 id="Album的操作-增加-修改-删除"><a href="#Album的操作-增加-修改-删除" class="headerlink" title="Album的操作(增加,修改,删除)"></a>Album的操作(增加,修改,删除)</h3><pre><code class="hljs swift"><span class="hljs-comment">//增加相册</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addAlbum</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-type">PHPhotoLibrary</span>.shared().performChanges(&#123;            <span class="hljs-keyword">let</span> assetCollectionRequest = <span class="hljs-type">PHCollectionListChangeRequest</span>.creationRequestForCollectionList(withTitle: <span class="hljs-string">&quot;title&quot;</span>);            <span class="hljs-keyword">self</span>.identifier =  assetCollectionRequest.placeholderForCreatedCollectionList.localIdentifier;        &#125;) &#123; (ret, error) <span class="hljs-keyword">in</span>            <span class="hljs-keyword">if</span> ret &#123;                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> id = <span class="hljs-keyword">self</span>.identifier &#123;                    <span class="hljs-keyword">let</span> collections = <span class="hljs-type">PHCollectionList</span>.fetchCollectionLists(withLocalIdentifiers: [id], options: <span class="hljs-literal">nil</span>)                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\(collections)&quot;</span>);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-comment">//删除相册</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteAlbum</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">let</span> fecthOptions = <span class="hljs-type">PHFetchOptions</span>();        <span class="hljs-keyword">let</span> predicate = <span class="hljs-type">NSPredicate</span>.<span class="hljs-keyword">init</span>(format: <span class="hljs-string">&quot;localizedTitle == &#x27;title&#x27;&quot;</span>);        fecthOptions.predicate = predicate;        <span class="hljs-keyword">let</span> titleList = <span class="hljs-type">PHCollectionList</span>.fetchCollectionLists(with: .folder, subtype: .regularFolder, options: fecthOptions);                <span class="hljs-type">PHPhotoLibrary</span>.shared().performChanges(&#123;            <span class="hljs-type">PHCollectionListChangeRequest</span>.deleteCollectionLists(titleList);        &#125;) &#123; (ret, error) <span class="hljs-keyword">in</span>            <span class="hljs-keyword">if</span> ret &#123;                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;删除成功&quot;</span>);            &#125;        &#125;    &#125;<span class="hljs-comment">//修改相册</span>  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">modifyAlbum</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">let</span> fecthOptions = <span class="hljs-type">PHFetchOptions</span>();        <span class="hljs-keyword">let</span> predicate = <span class="hljs-type">NSPredicate</span>.<span class="hljs-keyword">init</span>(format: <span class="hljs-string">&quot;localizedTitle == &#x27;title&#x27;&quot;</span>);        fecthOptions.predicate = predicate;        <span class="hljs-keyword">let</span> titleList = <span class="hljs-type">PHCollectionList</span>.fetchCollectionLists(with: .folder, subtype: .regularFolder, options: fecthOptions);        <span class="hljs-type">PHPhotoLibrary</span>.shared().performChanges(&#123;                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> collection = titleList.firstObject &#123;                <span class="hljs-keyword">let</span> modifyRequest = <span class="hljs-type">PHCollectionListChangeRequest</span>(<span class="hljs-keyword">for</span>: collection);                modifyRequest?.title = <span class="hljs-string">&quot;modify album&quot;</span>;            &#125;        &#125;) &#123; (ret, error) <span class="hljs-keyword">in</span>            <span class="hljs-keyword">if</span> ret &#123;                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;修改成功&quot;</span>);            &#125;        &#125;   &#125;</code></pre><h3 id="Asset的操作"><a href="#Asset的操作" class="headerlink" title="Asset的操作"></a>Asset的操作</h3><pre><code class="hljs swift">   <span class="hljs-comment">//增加</span>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">creationRequestForAsset</span><span class="hljs-params">(from image: UIImage)</span></span> -&gt; <span class="hljs-type">Self</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">creationRequestForAssetFromImage</span><span class="hljs-params">(atFileURL fileURL: URL)</span></span> -&gt; <span class="hljs-type">Self?</span>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">creationRequestForAssetFromVideo</span><span class="hljs-params">(atFileURL fileURL: URL)</span></span> -&gt; <span class="hljs-type">Self?</span>   <span class="hljs-comment">//删除</span>   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteAssets</span><span class="hljs-params">(<span class="hljs-number">_</span> assets: NSFastEnumeration)</span></span>   <span class="hljs-comment">//修改</span>  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestContentEditingInput</span><span class="hljs-params">(with options: PHContentEditingInputRequestOptions?, completionHandler: @escaping <span class="hljs-params">(PHContentEditingInput?, [AnyHashable : <span class="hljs-keyword">Any</span>])</span></span></span> -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">PHContentEditingInputRequestID</span>  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancelContentEditingInputRequest</span><span class="hljs-params">(<span class="hljs-number">_</span> requestID: PHContentEditingInputRequestID)</span></span>   <span class="hljs-comment">// MARK: UI Actions</span>    <span class="hljs-comment">/// - Tag: EditAlert</span>    <span class="hljs-meta">@IBAction</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">editAsset</span><span class="hljs-params">(<span class="hljs-number">_</span> sender: UIBarButtonItem)</span></span> &#123;        <span class="hljs-comment">// Use a UIAlertController to display editing options to the user.</span>        <span class="hljs-keyword">let</span> alertController = <span class="hljs-type">UIAlertController</span>(title: <span class="hljs-literal">nil</span>, message: <span class="hljs-literal">nil</span>, preferredStyle: .actionSheet)        #<span class="hljs-keyword">if</span> os(iOS)        alertController.modalPresentationStyle = .popover        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> popoverController = alertController.popoverPresentationController &#123;            popoverController.barButtonItem = sender            popoverController.permittedArrowDirections = .up        &#125;        #endif                <span class="hljs-comment">// Add a Cancel action to dismiss the alert without doing anything.</span>        alertController.addAction(<span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-type">NSLocalizedString</span>(<span class="hljs-string">&quot;Cancel&quot;</span>, comment: <span class="hljs-string">&quot;&quot;</span>),                                                style: .cancel, handler: <span class="hljs-literal">nil</span>))        <span class="hljs-comment">// Allow editing only if the PHAsset supports edit operations.</span>        <span class="hljs-keyword">if</span> asset.canPerform(.content) &#123;            <span class="hljs-comment">// Add actions for some canned filters.</span>            alertController.addAction(<span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-type">NSLocalizedString</span>(<span class="hljs-string">&quot;Sepia Tone&quot;</span>, comment: <span class="hljs-string">&quot;&quot;</span>),                                                    style: .<span class="hljs-keyword">default</span>, handler: getFilter(<span class="hljs-string">&quot;CISepiaTone&quot;</span>)))            alertController.addAction(<span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-type">NSLocalizedString</span>(<span class="hljs-string">&quot;Chrome&quot;</span>, comment: <span class="hljs-string">&quot;&quot;</span>),                                                    style: .<span class="hljs-keyword">default</span>, handler: getFilter(<span class="hljs-string">&quot;CIPhotoEffectChrome&quot;</span>)))                        <span class="hljs-comment">// Add actions to revert any edits that have been made to the PHAsset.</span>            alertController.addAction(<span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-type">NSLocalizedString</span>(<span class="hljs-string">&quot;Revert&quot;</span>, comment: <span class="hljs-string">&quot;&quot;</span>),                                                    style: .<span class="hljs-keyword">default</span>, handler: revertAsset))        &#125;        <span class="hljs-comment">// Present the UIAlertController.</span>        present(alertController, animated: <span class="hljs-literal">true</span>)    &#125;    #<span class="hljs-keyword">if</span> os(tvOS)    <span class="hljs-meta">@IBAction</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">playLivePhoto</span><span class="hljs-params">(<span class="hljs-number">_</span> sender: <span class="hljs-keyword">Any</span>)</span></span> &#123;        livePhotoView.startPlayback(with: .full)    &#125;    #endif    <span class="hljs-comment">/// - Tag: PlayVideo</span>    <span class="hljs-meta">@IBAction</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">play</span><span class="hljs-params">(<span class="hljs-number">_</span> sender: AnyObject)</span></span> &#123;        <span class="hljs-keyword">if</span> playerLayer != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-comment">// The app already created an AVPlayerLayer, so tell it to play.</span>            playerLayer.player!.play()        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> options = <span class="hljs-type">PHVideoRequestOptions</span>()            options.isNetworkAccessAllowed = <span class="hljs-literal">true</span>            options.deliveryMode = .automatic            options.progressHandler = &#123; progress, <span class="hljs-number">_</span>, <span class="hljs-number">_</span>, <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>                <span class="hljs-comment">// The handler may originate on a background queue, so</span>                <span class="hljs-comment">// re-dispatch to the main queue for UI work.</span>                <span class="hljs-type">DispatchQueue</span>.main.sync &#123;                    <span class="hljs-keyword">self</span>.progressView.progress = <span class="hljs-type">Float</span>(progress)                &#125;            &#125;            <span class="hljs-comment">// Request an AVPlayerItem for the displayed PHAsset.</span>            <span class="hljs-comment">// Then configure a layer for playing it.</span>            <span class="hljs-type">PHImageManager</span>.<span class="hljs-keyword">default</span>().requestPlayerItem(forVideo: asset, options: options, resultHandler: &#123; playerItem, info <span class="hljs-keyword">in</span>                <span class="hljs-type">DispatchQueue</span>.main.sync &#123;                    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">self</span>.playerLayer == <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;                                        <span class="hljs-comment">// Create an AVPlayer and AVPlayerLayer with the AVPlayerItem.</span>                    <span class="hljs-keyword">let</span> player = <span class="hljs-type">AVPlayer</span>(playerItem: playerItem)                    <span class="hljs-keyword">let</span> playerLayer = <span class="hljs-type">AVPlayerLayer</span>(player: player)                                        <span class="hljs-comment">// Configure the AVPlayerLayer and add it to the view.</span>                    playerLayer.videoGravity = <span class="hljs-type">AVLayerVideoGravity</span>.resizeAspect                    playerLayer.frame = <span class="hljs-keyword">self</span>.view.layer.bounds                    <span class="hljs-keyword">self</span>.view.layer.addSublayer(playerLayer)                                        player.play()                                        <span class="hljs-comment">// Cache the player layer by reference, so you can remove it later.</span>                    <span class="hljs-keyword">self</span>.playerLayer = playerLayer                &#125;            &#125;)        &#125;    &#125;    <span class="hljs-comment">/// - Tag: RemoveAsset</span>    <span class="hljs-meta">@IBAction</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeAsset</span><span class="hljs-params">(<span class="hljs-number">_</span> sender: AnyObject)</span></span> &#123;        <span class="hljs-keyword">let</span> completion = &#123; (success: <span class="hljs-type">Bool</span>, error: <span class="hljs-type">Error?</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span>            <span class="hljs-keyword">if</span> success &#123;                <span class="hljs-type">PHPhotoLibrary</span>.shared().unregisterChangeObserver(<span class="hljs-keyword">self</span>)                <span class="hljs-type">DispatchQueue</span>.main.sync &#123;                    <span class="hljs-number">_</span> = <span class="hljs-keyword">self</span>.navigationController!.popViewController(animated: <span class="hljs-literal">true</span>)                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can&#x27;t remove the asset: \(String(describing: error))&quot;</span>)            &#125;        &#125;        <span class="hljs-keyword">if</span> assetCollection != <span class="hljs-literal">nil</span> &#123;            <span class="hljs-comment">// Remove the asset from the selected album.</span>            <span class="hljs-type">PHPhotoLibrary</span>.shared().performChanges(&#123;                <span class="hljs-keyword">let</span> request = <span class="hljs-type">PHAssetCollectionChangeRequest</span>(<span class="hljs-keyword">for</span>: <span class="hljs-keyword">self</span>.assetCollection)!                request.removeAssets([<span class="hljs-keyword">self</span>.asset] <span class="hljs-keyword">as</span> <span class="hljs-type">NSArray</span>)            &#125;, completionHandler: completion)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// Delete the asset from the photo library.</span>            <span class="hljs-type">PHPhotoLibrary</span>.shared().performChanges(&#123;                <span class="hljs-type">PHAssetChangeRequest</span>.deleteAssets([<span class="hljs-keyword">self</span>.asset] <span class="hljs-keyword">as</span> <span class="hljs-type">NSArray</span>)            &#125;, completionHandler: completion)        &#125;    &#125;    <span class="hljs-comment">/// - Tag: MarkFavorite</span>    <span class="hljs-meta">@IBAction</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toggleFavorite</span><span class="hljs-params">(<span class="hljs-number">_</span> sender: UIBarButtonItem)</span></span> &#123;        <span class="hljs-type">PHPhotoLibrary</span>.shared().performChanges(&#123;            <span class="hljs-keyword">let</span> request = <span class="hljs-type">PHAssetChangeRequest</span>(<span class="hljs-keyword">for</span>: <span class="hljs-keyword">self</span>.asset)            request.isFavorite = !<span class="hljs-keyword">self</span>.asset.isFavorite        &#125;, completionHandler: &#123; success, error <span class="hljs-keyword">in</span>            <span class="hljs-keyword">if</span> success &#123;                <span class="hljs-type">DispatchQueue</span>.main.sync &#123;                    sender.title = <span class="hljs-keyword">self</span>.asset.isFavorite ? <span class="hljs-string">&quot;♥︎&quot;</span> : <span class="hljs-string">&quot;♡&quot;</span>                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can&#x27;t mark the asset as a Favorite: \(String(describing: error))&quot;</span>)            &#125;        &#125;)    &#125;        <span class="hljs-comment">// MARK: Image display</span>        <span class="hljs-keyword">var</span> targetSize: <span class="hljs-type">CGSize</span> &#123;        <span class="hljs-keyword">let</span> scale = <span class="hljs-type">UIScreen</span>.main.scale        <span class="hljs-keyword">return</span> <span class="hljs-type">CGSize</span>(width: imageView.bounds.width * scale, height: imageView.bounds.height * scale)    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateImage</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">if</span> asset.mediaSubtypes.<span class="hljs-built_in">contains</span>(.photoLive) &#123;            updateLivePhoto()        &#125; <span class="hljs-keyword">else</span> &#123;            updateStaticImage()        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateLivePhoto</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-comment">// Prepare the options to pass when fetching the live photo.</span>        <span class="hljs-keyword">let</span> options = <span class="hljs-type">PHLivePhotoRequestOptions</span>()        options.deliveryMode = .highQualityFormat        options.isNetworkAccessAllowed = <span class="hljs-literal">true</span>        options.progressHandler = &#123; progress, <span class="hljs-number">_</span>, <span class="hljs-number">_</span>, <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>            <span class="hljs-comment">// The handler may originate on a background queue, so</span>            <span class="hljs-comment">// re-dispatch to the main queue for UI work.</span>            <span class="hljs-type">DispatchQueue</span>.main.sync &#123;                <span class="hljs-keyword">self</span>.progressView.progress = <span class="hljs-type">Float</span>(progress)            &#125;        &#125;                <span class="hljs-comment">// Request the live photo for the asset from the default PHImageManager.</span>        <span class="hljs-type">PHImageManager</span>.<span class="hljs-keyword">default</span>().requestLivePhoto(<span class="hljs-keyword">for</span>: asset, targetSize: targetSize, contentMode: .aspectFit, options: options,                                                  resultHandler: &#123; livePhoto, info <span class="hljs-keyword">in</span>                                                    <span class="hljs-comment">// PhotoKit finishes the request, so hide the progress view.</span>                                                    <span class="hljs-keyword">self</span>.progressView.isHidden = <span class="hljs-literal">true</span>                                                                                                        <span class="hljs-comment">// Show the Live Photo view.</span>                                                    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> livePhoto = livePhoto <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;                                                                                                        <span class="hljs-comment">// Show the Live Photo.</span>                                                    <span class="hljs-keyword">self</span>.imageView.isHidden = <span class="hljs-literal">true</span>                                                    <span class="hljs-keyword">self</span>.livePhotoView.isHidden = <span class="hljs-literal">false</span>                                                    <span class="hljs-keyword">self</span>.livePhotoView.livePhoto = livePhoto                                                                                                        <span class="hljs-keyword">if</span> !<span class="hljs-keyword">self</span>.isPlayingHint &#123;                                                        <span class="hljs-comment">// Play back a short section of the Live Photo, similar to the Photos share sheet.</span>                                                        <span class="hljs-keyword">self</span>.isPlayingHint = <span class="hljs-literal">true</span>                                                        <span class="hljs-keyword">self</span>.livePhotoView.startPlayback(with: .hint)                                                    &#125;        &#125;)    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateStaticImage</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-comment">// Prepare the options to pass when fetching the (photo, or video preview) image.</span>        <span class="hljs-keyword">let</span> options = <span class="hljs-type">PHImageRequestOptions</span>()        options.deliveryMode = .highQualityFormat        options.isNetworkAccessAllowed = <span class="hljs-literal">true</span>        options.progressHandler = &#123; progress, <span class="hljs-number">_</span>, <span class="hljs-number">_</span>, <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>            <span class="hljs-comment">// The handler may originate on a background queue, so</span>            <span class="hljs-comment">// re-dispatch to the main queue for UI work.</span>            <span class="hljs-type">DispatchQueue</span>.main.sync &#123;                <span class="hljs-keyword">self</span>.progressView.progress = <span class="hljs-type">Float</span>(progress)            &#125;        &#125;                <span class="hljs-type">PHImageManager</span>.<span class="hljs-keyword">default</span>().requestImage(<span class="hljs-keyword">for</span>: asset, targetSize: targetSize, contentMode: .aspectFit, options: options,                                              resultHandler: &#123; image, <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>                                                <span class="hljs-comment">// PhotoKit finished the request, so hide the progress view.</span>                                                <span class="hljs-keyword">self</span>.progressView.isHidden = <span class="hljs-literal">true</span>                                                                                                <span class="hljs-comment">// If the request succeeded, show the image view.</span>                                                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> image = image <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;                                                                                                <span class="hljs-comment">// Show the image.</span>                                                <span class="hljs-keyword">self</span>.livePhotoView.isHidden = <span class="hljs-literal">true</span>                                                <span class="hljs-keyword">self</span>.imageView.isHidden = <span class="hljs-literal">false</span>                                                <span class="hljs-keyword">self</span>.imageView.image = image        &#125;)    &#125;        <span class="hljs-comment">// MARK: Asset editing</span>        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">revertAsset</span><span class="hljs-params">(sender: UIAlertAction)</span></span> &#123;        <span class="hljs-type">PHPhotoLibrary</span>.shared().performChanges(&#123;            <span class="hljs-keyword">let</span> request = <span class="hljs-type">PHAssetChangeRequest</span>(<span class="hljs-keyword">for</span>: <span class="hljs-keyword">self</span>.asset)            request.revertAssetContentToOriginal()        &#125;, completionHandler: &#123; success, error <span class="hljs-keyword">in</span>            <span class="hljs-keyword">if</span> !success &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can&#x27;t revert the asset: \(String(describing: error))&quot;</span>) &#125;        &#125;)    &#125;        <span class="hljs-comment">// Returns a filter-applier function for the named filter.</span>    <span class="hljs-comment">// Use the function as a handler for a UIAlertAction object.</span>    <span class="hljs-comment">/// - Tag: ApplyFilter</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFilter</span><span class="hljs-params">(<span class="hljs-number">_</span> filterName: String)</span></span> -&gt; (<span class="hljs-type">UIAlertAction</span>) -&gt; <span class="hljs-type">Void</span> &#123;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyFilter</span><span class="hljs-params">(<span class="hljs-number">_</span>: UIAlertAction)</span></span> &#123;            <span class="hljs-comment">// Set up a handler to handle prior edits.</span>            <span class="hljs-keyword">let</span> options = <span class="hljs-type">PHContentEditingInputRequestOptions</span>()            options.canHandleAdjustmentData = &#123;                $<span class="hljs-number">0</span>.formatIdentifier == <span class="hljs-keyword">self</span>.formatIdentifier &amp;&amp; $<span class="hljs-number">0</span>.formatVersion == <span class="hljs-keyword">self</span>.formatVersion            &#125;                        <span class="hljs-comment">// Prepare for editing.</span>            asset.requestContentEditingInput(with: options, completionHandler: &#123; input, info <span class="hljs-keyword">in</span>                <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> input = input                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Can&#x27;t get the content-editing input: \(info)&quot;</span>) &#125;                                <span class="hljs-comment">// This handler executes on the main thread; dispatch to a background queue for processing.</span>                <span class="hljs-type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;                                        <span class="hljs-comment">// Create adjustment data describing the edit.</span>                    <span class="hljs-keyword">let</span> adjustmentData = <span class="hljs-type">PHAdjustmentData</span>(formatIdentifier: <span class="hljs-keyword">self</span>.formatIdentifier,                                                          formatVersion: <span class="hljs-keyword">self</span>.formatVersion,                                                          data: filterName.data(using: .utf8)!)                                        <span class="hljs-comment">// Create content editing output, write the adjustment data.</span>                    <span class="hljs-keyword">let</span> output = <span class="hljs-type">PHContentEditingOutput</span>(contentEditingInput: input)                    output.adjustmentData = adjustmentData                                        <span class="hljs-comment">// Select a filtering function for the asset&#x27;s media type.</span>                    <span class="hljs-keyword">let</span> applyFunc: (<span class="hljs-type">String</span>, <span class="hljs-type">PHContentEditingInput</span>, <span class="hljs-type">PHContentEditingOutput</span>, @escaping () -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Void</span>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.asset.mediaSubtypes.<span class="hljs-built_in">contains</span>(.photoLive) &#123;                        applyFunc = <span class="hljs-keyword">self</span>.applyLivePhotoFilter                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.asset.mediaType == .image &#123;                        applyFunc = <span class="hljs-keyword">self</span>.applyPhotoFilter                    &#125; <span class="hljs-keyword">else</span> &#123;                        applyFunc = <span class="hljs-keyword">self</span>.applyVideoFilter                    &#125;                                        <span class="hljs-comment">// Apply the filter.</span>                    applyFunc(filterName, input, output, &#123;                        <span class="hljs-comment">// When the app finishes rendering the filtered result, commit the edit to the photo library.</span>                        <span class="hljs-type">PHPhotoLibrary</span>.shared().performChanges(&#123;                            <span class="hljs-keyword">let</span> request = <span class="hljs-type">PHAssetChangeRequest</span>(<span class="hljs-keyword">for</span>: <span class="hljs-keyword">self</span>.asset)                            request.contentEditingOutput = output                        &#125;, completionHandler: &#123; success, error <span class="hljs-keyword">in</span>                            <span class="hljs-keyword">if</span> !success &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can&#x27;t edit the asset: \(String(describing: error))&quot;</span>) &#125;                        &#125;)                    &#125;)                &#125;            &#125;)        &#125;        <span class="hljs-keyword">return</span> applyFilter    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyPhotoFilter</span><span class="hljs-params">(<span class="hljs-number">_</span> filterName: String, input: PHContentEditingInput, output: PHContentEditingOutput, completion: <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;                <span class="hljs-comment">// Load the full-size image.</span>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> inputImage = <span class="hljs-type">CIImage</span>(contentsOf: input.fullSizeImageURL!)            <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Can&#x27;t load the input image to edit.&quot;</span>) &#125;                <span class="hljs-comment">// Apply the filter.</span>        <span class="hljs-keyword">let</span> outputImage = inputImage            .oriented(forExifOrientation: input.fullSizeImageOrientation)            .applyingFilter(filterName, parameters: [:])                <span class="hljs-comment">// Write the edited image as a JPEG.</span>        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">try</span> <span class="hljs-keyword">self</span>.ciContext.writeJPEGRepresentation(of: outputImage,                                                       to: output.renderedContentURL, colorSpace: inputImage.colorSpace!, options: [:])        &#125; <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error &#123;            <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Can&#x27;t apply the filter to the image: \(error).&quot;</span>)        &#125;        completion()    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyLivePhotoFilter</span><span class="hljs-params">(<span class="hljs-number">_</span> filterName: String, input: PHContentEditingInput, output: PHContentEditingOutput, completion: @escaping <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;                <span class="hljs-comment">// This app filters assets only for output. In an app that previews</span>        <span class="hljs-comment">// filters while editing, create a livePhotoContext early and reuse it</span>        <span class="hljs-comment">// to render both for previewing and for final output.</span>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> livePhotoContext = <span class="hljs-type">PHLivePhotoEditingContext</span>(livePhotoEditingInput: input)            <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Can&#x27;t fetch the Live Photo to edit.&quot;</span>) &#125;                livePhotoContext.frameProcessor = &#123; frame, <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>            <span class="hljs-keyword">return</span> frame.image.applyingFilter(filterName, parameters: [:])        &#125;        livePhotoContext.saveLivePhoto(to: output) &#123; success, error <span class="hljs-keyword">in</span>            <span class="hljs-keyword">if</span> success &#123;                completion()            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Can&#x27;t output the Live Photo.&quot;</span>)            &#125;        &#125;    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyVideoFilter</span><span class="hljs-params">(<span class="hljs-number">_</span> filterName: String, input: PHContentEditingInput, output: PHContentEditingOutput, completion: @escaping <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;        <span class="hljs-comment">// Load the AVAsset to process from input.</span>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> avAsset = input.audiovisualAsset            <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Can&#x27;t fetch the AVAsset to edit.&quot;</span>) &#125;                <span class="hljs-comment">// Set up a video composition to apply the filter.</span>        <span class="hljs-keyword">let</span> composition = <span class="hljs-type">AVVideoComposition</span>(            asset: avAsset,            applyingCIFiltersWithHandler: &#123; request <span class="hljs-keyword">in</span>                <span class="hljs-keyword">let</span> filtered = request.sourceImage.applyingFilter(filterName, parameters: [:])                request.finish(with: filtered, context: <span class="hljs-literal">nil</span>)        &#125;)                <span class="hljs-comment">// Export the video composition to the output URL.</span>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> export = <span class="hljs-type">AVAssetExportSession</span>(asset: avAsset, presetName: <span class="hljs-type">AVAssetExportPresetHighestQuality</span>)            <span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;Can&#x27;t configure the AVAssetExportSession.&quot;</span>) &#125;        export.outputFileType = <span class="hljs-type">AVFileType</span>.mov        export.outputURL = output.renderedContentURL        export.videoComposition = composition        export.exportAsynchronously(completionHandler: completion)    &#125;<span class="hljs-comment">// MARK: PHPhotoLibraryChangeObserver</span><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AssetViewController</span>: <span class="hljs-title">PHPhotoLibraryChangeObserver</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">photoLibraryDidChange</span><span class="hljs-params">(<span class="hljs-number">_</span> changeInstance: PHChange)</span></span> &#123;        <span class="hljs-comment">// The call might come on any background queue. Re-dispatch to the main queue to handle it.</span>        <span class="hljs-type">DispatchQueue</span>.main.sync &#123;            <span class="hljs-comment">// Check if there are changes to the displayed asset.</span>            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> details = changeInstance.changeDetails(<span class="hljs-keyword">for</span>: asset) <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;                        <span class="hljs-comment">// Get the updated asset.</span>            asset = details.objectAfterChanges                        <span class="hljs-comment">// If the asset&#x27;s content changes, update the image and stop any video playback.</span>            <span class="hljs-keyword">if</span> details.assetContentChanged &#123;                updateImage()                                playerLayer?.removeFromSuperlayer()                playerLayer = <span class="hljs-literal">nil</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">// MARK: PHLivePhotoViewDelegate</span><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AssetViewController</span>: <span class="hljs-title">PHLivePhotoViewDelegate</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">livePhotoView</span><span class="hljs-params">(<span class="hljs-number">_</span> livePhotoView: PHLivePhotoView, willBeginPlaybackWith playbackStyle: PHLivePhotoViewPlaybackStyle)</span></span> &#123;        isPlayingHint = (playbackStyle == .hint)    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">livePhotoView</span><span class="hljs-params">(<span class="hljs-number">_</span> livePhotoView: PHLivePhotoView, didEndPlaybackWith playbackStyle: PHLivePhotoViewPlaybackStyle)</span></span> &#123;        isPlayingHint = (playbackStyle == .hint)    &#125;&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/documentation/photokit/browsing_and_modifying_photo_albums">Browsing and Modifying Photo Albums</a><br><a href="https://nshipster.cn/nspredicate/">NSPredicate</a><br><a href="https://nshipster.cn/nssortdescriptor/">NSSortDescriptor</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PhotoKit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TextView自适应高度</title>
    <link href="/blog/2019/01/11/iOS/TextView-%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <url>/blog/2019/01/11/iOS/TextView-%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p> TableView 的Cell内的textView根据文本输入内容,cell的高度自适应</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>TableView Cell高度自适应 <pre><code class="hljs ini"><span class="hljs-attr">editList.estimatedRowHeight</span> = <span class="hljs-number">52</span><span class="hljs-comment">;  //设置预估行高</span><span class="hljs-attr">editList.rowHeight</span> = UITableViewAutomaticDimension<span class="hljs-comment">;  //设置Cell高度自适应</span></code></pre></li><li>Cell内部设置<pre><code class="hljs reasonml">  var textString: String &#123;    get &#123;        return textView?.text ?? <span class="hljs-string">&quot;&quot;</span>    &#125;    set &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> textView = textView &#123;            textView.text = newValue            text<span class="hljs-constructor">ViewDidChange(<span class="hljs-params">textView</span>)</span> <span class="hljs-comment">//在cell外部给textView赋值,需要调用textView的代理方法,重新计算textView的size</span>        &#125;    &#125;  &#125; func setup<span class="hljs-constructor">UI()</span> &#123;        selectionStyle = .none;    separatorInset = <span class="hljs-constructor">UIEdgeInsetsMake(0, 20, 0, 20)</span>;    contentView.backgroundColor = .white;    titleLabel = <span class="hljs-constructor">UILabel()</span>;    titleLabel.textAlignment = .left;    titleLabel.textColor = ResourceManager.LIGHT_TEXT_COLOR;    titleLabel.font = ResourceManager.NORMAL_FONT;    contentView.add<span class="hljs-constructor">Subview(<span class="hljs-params">titleLabel</span>)</span>;        textView = <span class="hljs-constructor">UITextView()</span>;    textView.textAlignment = .right;    textView.delegate = self;    textView.isScrollEnabled = <span class="hljs-literal">false</span>; <span class="hljs-comment">//禁止textView的滚动</span>    textView.font = ResourceManager.NORMAL_FONT;       contentView.add<span class="hljs-constructor">Subview(<span class="hljs-params">textView</span>)</span>;        titleLabel.set<span class="hljs-constructor">ContentCompressionResistancePriority(.<span class="hljs-params">defaultHigh</span>, <span class="hljs-params">for</span>: .<span class="hljs-params">horizontal</span>)</span>;    textView.set<span class="hljs-constructor">ContentCompressionResistancePriority(.<span class="hljs-params">defaultLow</span>, <span class="hljs-params">for</span>: .<span class="hljs-params">horizontal</span>)</span>;    &#125;override func layout<span class="hljs-constructor">Subviews()</span> &#123;    super.layout<span class="hljs-constructor">Subviews()</span>;    titleLabel.snp.makeConstraints &#123; (make) <span class="hljs-keyword">in</span>        make.top.equal<span class="hljs-constructor">ToSuperview()</span>.offset(<span class="hljs-number">16</span>);        make.leading.equal<span class="hljs-constructor">ToSuperview()</span>.offset(<span class="hljs-number">20</span>);    &#125;        textView.snp.makeConstraints &#123; (make) <span class="hljs-keyword">in</span>        make.top.equal<span class="hljs-constructor">ToSuperview()</span>.offset(<span class="hljs-number">8</span>);        make.bottom.equal<span class="hljs-constructor">ToSuperview()</span>.offset<span class="hljs-number">(-8)</span>;        make.trailing.equal<span class="hljs-constructor">ToSuperview()</span>.offset<span class="hljs-number">(-20)</span>;        make.leading.equal<span class="hljs-constructor">To(<span class="hljs-params">titleLabel</span>.<span class="hljs-params">snp</span>.<span class="hljs-params">trailing</span>)</span>.offset(<span class="hljs-number">8</span>);    &#125;&#125;    <span class="hljs-comment">//textView代理方法</span>    func text<span class="hljs-constructor">ViewDidChange(<span class="hljs-params">_</span> <span class="hljs-params">textView</span>: UITextView)</span> &#123;          <span class="hljs-keyword">let</span> size = textView.bounds.size          <span class="hljs-keyword">let</span> newSize = textView.size<span class="hljs-constructor">ThatFits(CGSize(<span class="hljs-params">width</span>: <span class="hljs-params">size</span>.<span class="hljs-params">width</span>, <span class="hljs-params">height</span>: CGFloat.<span class="hljs-params">greatestFiniteMagnitude</span>)</span>)            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> controller = self.parent<span class="hljs-constructor">ViewController()</span> <span class="hljs-keyword">as</span>? ContractEditController &#123;        <span class="hljs-comment">// Resize the cell only when cell&#x27;s size is changed</span>        <span class="hljs-keyword">if</span> size.height != newSize.height &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UIView</span>.</span></span>set<span class="hljs-constructor">AnimationsEnabled(<span class="hljs-params">false</span>)</span>            controller.editList.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Updates()</span>            controller.editList.<span class="hljs-keyword">end</span><span class="hljs-constructor">Updates()</span>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UIView</span>.</span></span>set<span class="hljs-constructor">AnimationsEnabled(<span class="hljs-params">true</span>)</span>                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> thisIndexPath = controller.editList.index<span class="hljs-constructor">Path(<span class="hljs-params">for</span>: <span class="hljs-params">self</span>)</span> &#123;<span class="hljs-comment">//滚动到cell底部</span>                controller.editList.scroll<span class="hljs-constructor">ToRow(<span class="hljs-params">at</span>: <span class="hljs-params">thisIndexPath</span>, <span class="hljs-params">at</span>: .<span class="hljs-params">bottom</span>, <span class="hljs-params">animated</span>: <span class="hljs-params">false</span>)</span>            &#125;          &#125;         &#125;     &#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UITextView</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim常用命令</title>
    <link href="/blog/2018/12/12/Linux/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/blog/2018/12/12/Linux/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs awk"><span class="hljs-regexp">//</span>进入文件vi xxx.txt<span class="hljs-regexp">//</span>退出文件:q<span class="hljs-regexp">//</span>强制脱出文件:q!<span class="hljs-regexp">//</span>保存文件:w<span class="hljs-regexp">//</span>保存并退出文件:wq<span class="hljs-regexp">/*****命令模式*******/</span><span class="hljs-regexp">//</span>向下翻页control + f<span class="hljs-regexp">//</span>向上翻页control + b<span class="hljs-regexp">//</span>撤销u<span class="hljs-regexp">//</span>向下查找/word<span class="hljs-regexp">//</span>查找下一个n<span class="hljs-regexp">//</span>重复上个动作.<span class="hljs-regexp">//</span>复制一行yy<span class="hljs-regexp">//</span>粘贴一行p<span class="hljs-regexp">//</span>删除一行dd<span class="hljs-regexp">//</span>删除光标下的n行ndd<span class="hljs-regexp">/****输入模式*****/</span>i<span class="hljs-regexp">//</span>退出输入模式,切换到命令模式esc<span class="hljs-regexp">/****底线命令模式****/</span>:<span class="hljs-regexp">//</span>用户刚刚启动vi/vim便进入了命令模式<span class="hljs-regexp">//</span>删除光标所在处字符x<span class="hljs-regexp">//</span>退出底线命令模式esc</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件命令</title>
    <link href="/blog/2018/12/11/Linux/Linux-%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/"/>
    <url>/blog/2018/12/11/Linux/Linux-%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><pre><code class="hljs markdown">-rwxr--r--//总共9个字符//-表示类型,<span class="hljs-code">`d`</span>为目录,<span class="hljs-code">`-`</span>为文件//rwx 表示所有者权限,读写执行//r-- 表示所述用户组的权限,只读//r--表示其他权限,只读ls -al //查阅文件详细信息-rw-r--r-- 1 root   root   239 5 6 13:22 test.txt  // [<span class="hljs-string">文件类型与权限</span>] [<span class="hljs-string">文件连接数</span>][<span class="hljs-symbol">所有者账号</span>] [用户组账号] [文件容量 单位 B] [修改日期] [文件名]</code></pre><h2 id="用户切换"><a href="#用户切换" class="headerlink" title="用户切换"></a>用户切换</h2><pre><code class="hljs awk"><span class="hljs-regexp">//</span>切换到root 用户sudo -i<span class="hljs-regexp">//</span>root 切换到指定用户su - username   <span class="hljs-regexp">//</span>注意- 和 用户名之间有空格</code></pre><h2 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h2><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> filePath <span class="hljs-comment">//切换目录</span><span class="hljs-keyword">pwd</span> <span class="hljs-comment">//打印当前路径</span><span class="hljs-comment">//新建(增加)</span><span class="hljs-keyword">mkdir</span> dirname <span class="hljs-comment">//新建目录</span><span class="hljs-keyword">mkdir</span> -p test1/test2/test3  <span class="hljs-comment">//创建多层目录</span><span class="hljs-keyword">mkdir</span> -<span class="hljs-keyword">m</span> 711 test2 <span class="hljs-comment">//新建权限为rwx--x--x的目录</span>touch filename <span class="hljs-comment">//创建文件</span><span class="hljs-comment">//删除</span><span class="hljs-keyword">rm</span> filename   <span class="hljs-comment">//移除文件</span><span class="hljs-keyword">rm</span> -r dirName <span class="hljs-comment">//移除目录</span><span class="hljs-keyword">rmdir</span> dirname <span class="hljs-comment">//移除目录</span><span class="hljs-keyword">rmdir</span> -p test1/test2/test3 <span class="hljs-comment">//连同上层空的目录也一起删除</span><span class="hljs-comment">//复制</span>cp  源路径 目标路径cp -a sourcefile desfile <span class="hljs-comment">//完全复制</span>cp -i sourcefile desfile  <span class="hljs-comment">//询问</span>cp -r sourcefile desfile  <span class="hljs-comment">//递归复制</span><span class="hljs-comment">//移动</span>mv [-fiu] souce destination-f <span class="hljs-comment">//强制</span>-i  <span class="hljs-comment">//询问是否覆盖</span>-<span class="hljs-keyword">u</span> <span class="hljs-comment">//更新为最新</span><span class="hljs-comment">//修改</span><span class="hljs-comment">//修改的用户组: groupname在 etc/group 文件中存在</span>chgrp [-R] groupname dirname/filename<span class="hljs-comment">//修改拥有者:  ownername 在 etc/passwd 文件中存在</span>chown ownername dirname/filenamechown :groupname dirname/filenamechown ownername:groupname dirname/filename<span class="hljs-comment">//修改文件权限</span><span class="hljs-comment">//数字修改权限  各个权限加权分 r: 4 w: 2 x: 1 </span>chmod 777 dirname/filename <span class="hljs-comment">//-rwxrwxrwx</span>chmod 755 dirname/filename <span class="hljs-comment">//-rwxr-xr-x</span><span class="hljs-comment">//修改权限(通过字符)</span><span class="hljs-comment">//chmod      u g o a       + - =      rwx        文件目录</span>chmod <span class="hljs-keyword">u</span>=rwx,go=r filename  <span class="hljs-comment">//-rwxr--r--</span>chmod a+w filename   <span class="hljs-comment">//增加写权限</span>chmod a-x filename  <span class="hljs-comment">//减少执行权限 </span>basename  <span class="hljs-keyword">dir</span>/finename  <span class="hljs-comment">//获取文件名</span>dirname  <span class="hljs-keyword">dir</span>/filename  <span class="hljs-comment">//获取目录名</span><span class="hljs-comment">//修改新建文件和目录的默认权限</span>umask 002  <span class="hljs-comment">//owner group others  002表示拿掉others的写权限</span>root的umask默认是022一般用户umask默认是002<span class="hljs-comment">//查看文件类型</span><span class="hljs-keyword">file</span> filePath <span class="hljs-comment">//脚本文件名查找</span><span class="hljs-keyword">which</span> command<span class="hljs-comment">//文件查找</span>whereis 文件名locate 文件名或部分文件名find /home -user vbird <span class="hljs-comment">//查找/home下面属于vbird的文件</span>find  /  name 文件名 <span class="hljs-comment">//查找文件名</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>文件及权限命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoLayout Cell高度自适应</title>
    <link href="/blog/2018/11/22/iOS/XIB--%E6%88%96%E8%80%85-AutoLayout-%E5%AE%9E%E7%8E%B0Cell%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <url>/blog/2018/11/22/iOS/XIB--%E6%88%96%E8%80%85-AutoLayout-%E5%AE%9E%E7%8E%B0Cell%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<ol><li>不要设置TableView返回Cell高度的代理方法</li><li>设置底部控件约束与cell的contentView距离</li><li>设置预估行高,并且设置cell高度自动计算 </li></ol><p><strong>注意:</strong> 如果不设置预估行高的话,Cell会设置固定行高为44,如果使用SnapKit设置的Cell自适应高度可能在某些机型上无效</p><pre><code class="hljs ini"><span class="hljs-attr">taskList.estimatedRowHeight</span> = <span class="hljs-number">77</span><span class="hljs-comment">;</span><span class="hljs-attr">taskList.rowHeight</span> = UITableViewAutomaticDimension<span class="hljs-comment">;</span></code></pre><p>有些时候,虽然设置了上面的动态约束,但是对cell高度做动态约束的时候,会在log里面有约束冲突的警告,这个时候是只需要将超过44的高度约束的Prority属性设置为大于750就行了,默认的高度约束是750;而默认高度的约束也是44,所以会出现冲突;</p><pre><code class="hljs dns">[LayoutConstraints] Unable to simultaneously satisfy constraints.Probably at least one of the constraints in the following list is one you don&#x27;t want. Try this: (<span class="hljs-number">1</span>) look at each constraint and try to figure out which you don&#x27;t expect<span class="hljs-comment">; </span>(<span class="hljs-number">2</span>) find the code that added the unwanted constraint or constraints and fix it. (    &quot;&lt;SnapKit.LayoutConstraint:<span class="hljs-number">0</span>x<span class="hljs-number">2833606c0</span>@MalfunctionDetailCell.swift#<span class="hljs-number">88</span> UILabel:<span class="hljs-number">0x103983790</span>.top == UITableViewCellContentView:<span class="hljs-number">0x103984060</span>.top + <span class="hljs-number">10</span>.<span class="hljs-number">0</span>&gt;&quot;,    &quot;&lt;SnapKit.LayoutConstraint:<span class="hljs-number">0</span>x<span class="hljs-number">283360a20</span>@MalfunctionDetailCell.swift#<span class="hljs-number">95</span> UILabel:<span class="hljs-number">0x103983d70</span>.top == UILabel:<span class="hljs-number">0x103983790</span>.bottom + <span class="hljs-number">6</span>.<span class="hljs-number">0</span>&gt;&quot;,    &quot;&lt;SnapKit.LayoutConstraint:<span class="hljs-number">0</span>x<span class="hljs-number">283360d80</span>@MalfunctionDetailCell.swift#<span class="hljs-number">101</span> UILabel:<span class="hljs-number">0x103983a80</span>.top == UILabel:<span class="hljs-number">0x103983d70</span>.bottom + <span class="hljs-number">6</span>.<span class="hljs-number">0</span>&gt;&quot;,    &quot;&lt;SnapKit.LayoutConstraint:<span class="hljs-number">0</span>x283360ea0@MalfunctionDetailCell.swift#<span class="hljs-number">104</span> UILabel:<span class="hljs-number">0x103983a80</span>.height == <span class="hljs-number">16</span>.<span class="hljs-number">0</span>&gt;&quot;,    &quot;&lt;SnapKit.LayoutConstraint:<span class="hljs-number">0</span>x<span class="hljs-number">283360f00</span>@MalfunctionDetailCell.swift#<span class="hljs-number">105</span> UILabel:<span class="hljs-number">0x103983a80</span>.bottom == UITableViewCellContentView:<span class="hljs-number">0x103984060</span>.bottom - <span class="hljs-number">8</span>.<span class="hljs-number">0</span>&gt;&quot;,    &quot;&lt;NSLayoutConstraint:<span class="hljs-number">0</span>x<span class="hljs-number">28346b8e0</span> &#x27;UIView-Encapsulated-Layout-Height&#x27; UITableViewCellContentView:<span class="hljs-number">0x103984060</span>.height == <span class="hljs-number">44</span>   (active)&gt;&quot;  //这里是重点)</code></pre><h4 id="Tips-约束的优先级-Priority"><a href="#Tips-约束的优先级-Priority" class="headerlink" title="Tips:  约束的优先级(Priority)"></a>Tips:  约束的优先级(Priority)</h4><p>在Xib或者storyBoard 中我们设置的约束默认的优先级都是Required(1000),如果想要设置约束根据优先级动态调整,则需要将优先级降至1000以下;当然,我们也可以设置优先级的具体数值;</p><pre><code class="hljs clean">##注意## 当我们将某个约束优先级设置为Required时,其他等级的约束将无效;</code></pre><h6 id="xib-和-storyBoard下有以下几种优先级"><a href="#xib-和-storyBoard下有以下几种优先级" class="headerlink" title="xib 和 storyBoard下有以下几种优先级"></a>xib 和 storyBoard下有以下几种优先级</h6><pre><code class="hljs angelscript">Required(<span class="hljs-number">1000</span>) &gt; High(<span class="hljs-number">750</span>) &gt; Low(<span class="hljs-number">250</span>);</code></pre><h6 id="SnapKit增加一种"><a href="#SnapKit增加一种" class="headerlink" title="SnapKit增加一种"></a>SnapKit增加一种</h6><pre><code class="hljs angelscript">Required(<span class="hljs-number">1000</span>) &gt; High(<span class="hljs-number">750</span>) &gt; Medium(<span class="hljs-number">500</span>) &gt; Low(<span class="hljs-number">250</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoLayout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用命令</title>
    <link href="/blog/2018/08/28/%E5%B7%A5%E5%85%B7/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/blog/2018/08/28/%E5%B7%A5%E5%85%B7/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h4><p>配置</p><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">&quot;你的名字&quot;</span>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">&quot;邮箱&quot;</span></code></pre><p>远程仓库操作</p><pre><code class="hljs awk">git remote add origin <span class="hljs-string">&quot;仓库地址&quot;</span> <span class="hljs-regexp">//</span>链接远程仓库git push -u origin master        <span class="hljs-regexp">//</span>第一次将本地仓库推送到远程仓库git branch -r                    <span class="hljs-regexp">//</span>查看远程分支列表git clone 仓库地址               <span class="hljs-regexp">//</span>将远程仓库克隆到本地git push origin master           <span class="hljs-regexp">//</span>将本地库改动提交远程git pull                         <span class="hljs-regexp">//</span>更新本地库至远程库的最新改动git push origin --<span class="hljs-keyword">delete</span> 远程分支名  <span class="hljs-regexp">//</span>删除远程分支</code></pre><p>SSH Key 操作</p><pre><code class="hljs awk">$ ls -al ~/.ssh<span class="hljs-comment"># Lists the files in your .ssh directory, if they exist</span>ssh -keygen -t rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span>   <span class="hljs-regexp">//</span>生成SSH key,保存路径为<span class="hljs-regexp">/root/</span>.ssh</code></pre><p>创建忽略文件</p><pre><code class="hljs awk">touch .gitignore  <span class="hljs-regexp">//</span>不需要服务端提交的内容可以写到忽略文件里</code></pre><p>添加</p><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span> 将当前目录初始化为git仓库git <span class="hljs-keyword">add</span> 文件名 将文件添加到暂存区git <span class="hljs-keyword">add</span> -A   <span class="hljs-comment">//将所有修改文件全部添加到缓存区</span>git commit -m <span class="hljs-string">&quot;描述&quot;</span>  将暂存区提交到仓库</code></pre><p>查询</p><pre><code class="hljs awk">git status                <span class="hljs-regexp">//</span>查询仓库状态git diff 文件名           <span class="hljs-regexp">//</span>比较文件差异git log                   <span class="hljs-regexp">//</span>查看仓库历史记录(详细)git log --oneline         <span class="hljs-regexp">//</span>查看仓库历史记录(单行)git reflog                <span class="hljs-regexp">//</span>查看所有版本的commitID  (本地分支Git记录不小心删除时,可以用此查看删除的Git记录)</code></pre><p>撤销(回滚)</p><pre><code class="hljs awk">git  checkout -- 文件名     <span class="hljs-regexp">//</span>撤销工作区修改git reset HEAD 文件名       <span class="hljs-regexp">//</span>撤销暂存区的修改git reset --hard 该版本ID   <span class="hljs-regexp">//</span>回退到历史版本git reset --hard HEAD^      <span class="hljs-regexp">//</span>回退到上个版本git reflog                  <span class="hljs-regexp">//</span>回滚到未来</code></pre><p>删除</p><pre><code class="hljs awk">rm filename                 <span class="hljs-regexp">//</span>删除本地文件git rm index.html --cached  <span class="hljs-regexp">//</span>保证当前工作区中没有index.html,使用--cached表示只删除换缓存区中的内容</code></pre><p>标签</p><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">标签名           //为当前版本打标签</span><span class="hljs-title">git</span> <span class="hljs-keyword">tag</span> <span class="hljs-title">标签名 该版本ID</span>  //为历史版本打标签git <span class="hljs-keyword">tag</span>                  <span class="hljs-title">//查看所有标签</span><span class="hljs-title">git</span> show  标签名         //查看某一标签git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> 标签名        //删除某一标签</code></pre><p>分支管理</p><pre><code class="hljs awk">git branch dev           <span class="hljs-regexp">//</span>创建分支git checkout dev         <span class="hljs-regexp">//</span>切换分支git checkout -b dev      <span class="hljs-regexp">//</span>创建并切换分支git branch -d dev        <span class="hljs-regexp">//</span>删除分支git commit -a -m <span class="hljs-string">&#x27;dev1&#x27;</span>  <span class="hljs-regexp">//</span>在分支上提交新的版本git merge dev            <span class="hljs-regexp">//</span>合并分支git stash            <span class="hljs-regexp">//</span>在分支开发过程中遇到问题,需要切换到其他分支,保留写好的内容再切换到主干git stash apply          <span class="hljs-regexp">//</span>再次切换分支后需要应用一下保留的内容git stash drop           <span class="hljs-regexp">//</span>丢弃保存的内容git stash pop            <span class="hljs-regexp">//</span>使用并丢掉</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/3340896-9aefe571129ba75d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git flow"></p><h4 id="Git-Submodule-管理项目子模块"><a href="#Git-Submodule-管理项目子模块" class="headerlink" title="Git Submodule 管理项目子模块"></a>Git Submodule 管理项目子模块</h4><pre><code class="hljs awk">git clone &lt;repository&gt; --recursive                   <span class="hljs-regexp">//</span>递归的方式克隆整个项目git submodule add &lt;repository&gt; &lt;path&gt;                <span class="hljs-regexp">//</span>添加子模块git submodule init                                   <span class="hljs-regexp">//</span>初始化子模块(远程仓库子模块添加或删除后,需要进行此操作)git submodule update                                 <span class="hljs-regexp">//</span>更新子模块git submodule foreach git pull                      <span class="hljs-regexp">//</span>拉取所有子模块git rm moduleA                                      <span class="hljs-regexp">//</span>删除子模块</code></pre><h4 id="git-flow-命令"><a href="#git-flow-命令" class="headerlink" title="git flow 命令"></a>git flow 命令</h4><pre><code class="hljs awk">brew install git-flow    <span class="hljs-regexp">//</span>安装git-flow</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/3340896-c6377d2d53ee3e4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gitFlow命令.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天路旅途（四）</title>
    <link href="/blog/2018/08/25/%E9%9A%8F%E7%AC%94/%E5%A4%A9%E8%B7%AF%E6%97%85%E9%80%94-(%E5%9B%9B)/"/>
    <url>/blog/2018/08/25/%E9%9A%8F%E7%AC%94/%E5%A4%A9%E8%B7%AF%E6%97%85%E9%80%94-(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<p>接下来的就是看图说话环节了,码字太累,何况自己文学素养不高,对付着看吧,O(∩_∩)O哈哈~<br><img src="https://upload-images.jianshu.io/upload_images/3340896-fb317d08ae873cf6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拉萨站.jpg"><br>这张照片呢,是我从拉萨站走出来的时候拍的,当时很纳闷,为什么不让走正门广场而从边上一个简陋的小门出去呢?后来了解到好像是由于安保问题,具体什么的就不深究了.<br><img src="https://upload-images.jianshu.io/upload_images/3340896-11d88ab0e555d555.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广场雕塑.jpg"><br>拉萨站是在堆龙德庆区,到拉萨市里面还得打车,大约四十来分钟吧,咳咳…写这篇文章的时候,时间已经过了将近一年了,我就记得我当时是直接滴滴过去的.司机是东北人,来这里一年了,下车的时候留了手机号,如果去景区,他说可以载着我,价钱合适就ok.后来还真给这大哥打了电话,带着我们去了纳木错.<br><img src="https://upload-images.jianshu.io/upload_images/3340896-654c1b4f835cafda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拉萨站广场.jpg"><br>这张照片是我下车后,过了大概两个小时后拍的.中间有一段小插曲,火车到拉萨的时候已经中午12点10分了,到吃饭点儿了,我呢? 一个人,不用担心,本来就是自由行,所以喜欢哪里就在哪里多待会儿.先解决午饭问题,<br>车站的路对过,就是各种饭馆,转到一家饭馆,进去点了一碗面,吃完后,就背着包出去接着逛. 没过多久,肚子就开始疼起来,幸亏我带着纸,于是屁颠屁颠地开始找厕所.<br>来到拉萨吃的第一顿饭,居然让我这样度过,至今难忘~~</p><p>转了一会儿, 感觉没意思了,于是滴滴了一个司机,带着我向拉萨城里出发,下面这张是在等车的公交站牌前拍的,自我感觉还是比较良好的<del>O(∩_∩)O哈哈</del><br><img src="https://upload-images.jianshu.io/upload_images/3340896-fe9ac1954177f7c3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远山.jpg"></p><p>到酒店后放下行囊,就带着相机,开始在城里到处溜达,首先当然去八廓街了…</p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-902846f9f13c96f9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="八廓街.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-4e2c1d6b30c6253f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="色彩斑斓.jpg"></p><p>主街道的酒店还是蛮漂亮的,就在玛吉阿米茶馆前面,地理位置相当好,当然价格肯定也不菲喽.<br> 拉萨给我的印象就是,没人的地方,蓝天白云,绿水青山;有人的地方,花枝招展,色彩斑斓.</p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-5f5e77f179446f5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="五彩经幡.jpg"><br>藏族民居的楼顶一般都会挂上五彩经幡,随风摆动,煞是好看.这里我要科普一下,经幡之所以被称作经幡，是因为这些幡上面都印有佛经，在信奉藏传佛教的人们看来，随风而舞的经幡飘动一下，就是诵经一次，在不停地向神传达人的愿望，祈求神的庇佑。这样，经幡便成为连接神与人的纽带。风幡所在即意味着神灵所在，也意味着人们对神灵的祈求所在。风幡寄托着人们美好的愿望。</p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-50563d1edccf5599.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="天堂时光.jpg"><br>&lt;天堂时光旅行书店&gt; 听名字就感觉仙气满满, 这里也是我此行的目的地之一,简友 <a href="https://www.jianshu.com/u/54f4e7e9a502">马儿你慢些走</a> 里面写在西藏支教的日子,就是通过书店的主人,潘老师介绍,来拉萨支教的,非常有趣的一个人,感兴趣的话可以看看她写的文章.</p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-80402ee877d42cec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自信.jpg"><br><img src="https://upload-images.jianshu.io/upload_images/3340896-b673fa7dfce8c0e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="佛语.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-5eabff6a2d72611c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="掠影1.jpg"><br>偷拍一下小姐姐,O(∩_∩)O哈哈~<br><img src="https://upload-images.jianshu.io/upload_images/3340896-99af155ecd8b1a54.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="掠影2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-792f08459fa98f28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="仓姑寺甜茶馆.jpg"><br>仓姑寺甜茶馆就在八廓街里,由于不能再里面拍照,所以我就百度了一张,自己标明位置,自己点了一壶甜茶.我是不是灵魂画手呀! 😝</p><p><a href="">未完待续</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codable</title>
    <link href="/blog/2018/08/17/Swift/Swift---4-Codable/"/>
    <url>/blog/2018/08/17/Swift/Swift---4-Codable/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/3340896-f2a235b5b168f084.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><em>Objective-C</em>  中我们有好多 <em>JSON</em> 转 <em>Model</em> 第三方,比如 <em>JSONModel</em>, <em>MJExtension</em>,<em>YYModel</em>等好用的第三方库,在 <strong>Swift 4</strong> 推出了 <em>Codable</em> 协议,只要遵循 <strong>Codable</strong> 协议的模型就可以用<em>JSONEncoder</em> 和 <em>JSONDecoder</em> 两个类来实现 <em>JSON</em> 和 <em>Model</em> 的相互转换.</p><p><strong>Codable</strong> 协议分为两部分,<strong>Encodable</strong>和<strong>Decodable</strong>;如果只需要解析JSON数据,那么只遵循 <strong>Decodable</strong> 协议就行了,如果 <em>JSON</em> 和 <em>Model</em> 都需要相互转换,那么遵循 <strong>Codable</strong> 协议</p><h2 id="JSON-amp-Model"><a href="#JSON-amp-Model" class="headerlink" title="JSON &amp; Model"></a><strong>JSON</strong> &amp; <strong>Model</strong></h2><h5 id="支持类型"><a href="#支持类型" class="headerlink" title="支持类型"></a>支持类型</h5><p>下面代码实现了 <em>JSON</em> 字符串转为 <em>Student</em> , <strong>Swift</strong>  标准库里的基本类型已经都遵循 <strong>Codable</strong> 协议,所以,只要用遵循 <strong>Codable</strong> 协议的类型来创建模型,就可以正常读取json中的内容.</p><p>示例代码中的 <strong>Student</strong> 模型里面包含 <em>Int</em>, <em>Float</em>, <em>Bool</em>, <em>String</em> 和自定义的枚举类型.可选类型也是支持的,如果json中读取的key对应value可能为空,那么我们可以声明该类型为可选类型.</p><h5 id="嵌套Model"><a href="#嵌套Model" class="headerlink" title="嵌套Model"></a>嵌套Model</h5><p>如果模型有嵌套自定义的类型, 自定义的枚举类型如果也遵循 <strong>Codable</strong> 协议,那么添加到模型中也可以正常读取,枚举的 <em>rawValue</em> 需要指定为遵循 <strong>Codable</strong> 协议的基本类型.</p><h5 id="自定义Model的key"><a href="#自定义Model的key" class="headerlink" title="自定义Model的key"></a>自定义Model的key</h5><p>如果需要自定义字段来解析 <em>JSON</em> 数据,实现 <strong>CodingKey</strong> 那个协议就OK,有一点不太友好的是,不管你是否自定义某个key,都要把模型中所有的key填写进去,否则会报编译错误.</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre><code class="hljs php">enum Gender: <span class="hljs-keyword">String</span>, Codable &#123;    <span class="hljs-keyword">case</span> male = <span class="hljs-string">&quot;male&quot;</span>    <span class="hljs-keyword">case</span> female = <span class="hljs-string">&quot;female&quot;</span>&#125;struct Student: Codable &#123;    <span class="hljs-keyword">var</span> name       : <span class="hljs-keyword">String</span>    <span class="hljs-keyword">var</span> gender     : Gender    <span class="hljs-keyword">var</span> age        : <span class="hljs-keyword">Int</span>    <span class="hljs-keyword">var</span> weight     : <span class="hljs-keyword">Float</span>    <span class="hljs-keyword">var</span> isRegisted : <span class="hljs-keyword">Bool</span>    <span class="hljs-keyword">var</span> score      : <span class="hljs-keyword">Double</span>?        enum CodingKeys: <span class="hljs-keyword">String</span>, CodingKey &#123;        <span class="hljs-keyword">case</span> gender        <span class="hljs-keyword">case</span> name        <span class="hljs-keyword">case</span> age        <span class="hljs-keyword">case</span> score        <span class="hljs-keyword">case</span> weight        <span class="hljs-keyword">case</span> isRegisted = <span class="hljs-string">&quot;is_registed&quot;</span>    &#125;&#125;let json = <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><span class="hljs-string">                &#123;</span><span class="hljs-string">                    &quot;</span>name<span class="hljs-string">&quot;  : &quot;</span>Durian<span class="hljs-string">&quot;,</span><span class="hljs-string">                    &quot;</span>gender<span class="hljs-string">&quot;: &quot;</span>male<span class="hljs-string">&quot;,</span><span class="hljs-string">                    &quot;</span>age<span class="hljs-string">&quot;   : 12,</span><span class="hljs-string">                    &quot;</span>weight<span class="hljs-string">&quot;: 56.4,</span><span class="hljs-string">                    &quot;</span>is_registed<span class="hljs-string">&quot;: true</span><span class="hljs-string">                    &quot;</span>score<span class="hljs-string">&quot; : null</span><span class="hljs-string">                &#125;</span><span class="hljs-string">                &quot;</span><span class="hljs-string">&quot;&quot;</span>.data(using: .utf8)!                let decoder = JSONDecoder()        let encoder = JSONEncoder()        encoder.outputFormatting = .prettyPrinted                <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">//json转Model</span>            let student =  <span class="hljs-keyword">try</span> decoder.decode(Student.<span class="hljs-built_in">self</span>, <span class="hljs-keyword">from</span>: json)            <span class="hljs-keyword">print</span>(student)            <span class="hljs-keyword">do</span> &#123;                <span class="hljs-comment">//model转JSON</span>                let json =  <span class="hljs-keyword">try</span> encoder.encode(student)                <span class="hljs-keyword">print</span>(<span class="hljs-keyword">String</span>(data: json, encoding: .utf8)!)            &#125; <span class="hljs-keyword">catch</span> &#123;                <span class="hljs-keyword">print</span>(<span class="hljs-built_in">error</span>)            &#125;        &#125; <span class="hljs-keyword">catch</span> &#123;            <span class="hljs-keyword">print</span>(<span class="hljs-built_in">error</span>)        &#125;</code></pre><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p><em>Codable</em>  不仅仅对 <em>JSON</em> 模型转换有很好的支持,对于 <em>PropertyList</em> 与模型的转换也很友好,我们只需要使用 <em>PropertyListEncoder</em>  和  <em>PropertyListDecoder</em>  替换 <em>JSONEncoder</em> 和 <em>JSONDecoder</em> 就行了,用法是一样的.</p><p>当然, <em>Codable</em> 的强大之处不止这些,阅读 <em>Apple</em> 官方文档,<a href="https://developer.apple.com/documentation/swift/codable">了解更多…</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types#overview">Encoding and Decoding Custom Types</a><br><a href="https://developer.apple.com/documentation/foundation/jsonencoder">JSONEcoder</a><br><a href="https://developer.apple.com/documentation/foundation/jsondecoder">JSONDecoder</a><br><a href="https://www.jianshu.com/p/bdd9c012df15">Swift 4 踩坑之 Codable 协议</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CALayer及CAAnimation</title>
    <link href="/blog/2018/04/27/iOS/CALayer-%E5%92%8C-CAAnimation/"/>
    <url>/blog/2018/04/27/iOS/CALayer-%E5%92%8C-CAAnimation/</url>
    
    <content type="html"><![CDATA[<h2 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h2><ul><li><p>Layer可以绘制的动画<br><img src="http://upload-images.jianshu.io/upload_images/3340896-901e4849bf35fa8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画类型"></p></li><li><p>CALayer position 和 anchorpoint</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/3340896-64a48bd8dd7ba3f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="positon属性"></p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-38913e949dcbfeac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="锚点属性"></p><pre><code>   - anchorpoint 基于单位坐标系,默认 (0.5,0.5)   - position    基于点坐标系,具体位置由锚点决定frame 属性是在 positon和bounds属性下衍生出来的,frame相对于父类坐标系,bounds定义自身坐标系</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3340896-d58622e2018f19a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="锚点位置与postion的变化"></p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-1dde00133bac2ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="锚点如何影响图层变化"></p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-54966cd3653e1120.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图层变化矩阵数据配置"></p><ul><li><p>Layer Tree 分类</p><ul><li>模型树(Model Tree)</li><li>显示树(Presentation Tree)</li><li>渲染树(Render Tree)</li></ul></li><li><p>图层(CALayer) 添加动画(CAAnimation)<br>动画基于操作图层对象来展示效果,通过下列方法来给图层添加动画</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>addAnimation:<span class="hljs-params">(CAAnimation *)</span>anim               forKey:<span class="hljs-params">(NSString *)</span>key;</code></pre></li></ul><h2 id="CAAnimation"><a href="#CAAnimation" class="headerlink" title="CAAnimation"></a>CAAnimation</h2><ul><li><p>CoreAnimation层级<br><img src="http://upload-images.jianshu.io/upload_images/3340896-f0db3c26d671677e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="层级"></p></li><li><p>CoreAnimation如何绘制内容<br><img src="http://upload-images.jianshu.io/upload_images/3340896-ac2ef3c4d239d1aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="绘制流程"></p></li><li><p>CoreAnimation API</p></li></ul><pre><code class="hljs autohotkey">CAAnimationGroup `animations`CAPropertyAnimation `keypath`     - CABasicAnimation `fromValue` `toValue`     - CAKeyframeAnimation `values` `path` `keyTimes`CATransition `type` `subType` `startProgress` `endProgress`</code></pre><ul><li>关于动画时间的控制</li></ul><p>动画暂停</p><pre><code class="hljs gml"><span class="hljs-comment">//根据全局时间获取本地时间</span>CFTimeInterval pausedTime = [<span class="hljs-symbol">layer</span> convertTime:CACurrentMediaTime() fromLayer:nil];<span class="hljs-comment">//将图层动画速度设为0</span><span class="hljs-symbol">layer</span>.<span class="hljs-symbol">speed</span> = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//根据暂停的本地时间设置偏移</span><span class="hljs-symbol">layer</span>.timerOffset = pausedTime;</code></pre><p>动画恢复</p><pre><code class="hljs gml"><span class="hljs-comment">//得到偏移时间</span>CFTimeInterval pausedTime = <span class="hljs-symbol">layer</span>.timeOffset;<span class="hljs-comment">//恢复图层的速度</span><span class="hljs-symbol">layer</span>.<span class="hljs-symbol">speed</span> = <span class="hljs-number">1.0</span>;<span class="hljs-comment">//设置timerOffset</span><span class="hljs-symbol">layer</span>.timeOffset = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//设值为0,进行时间转换</span><span class="hljs-symbol">layer</span>.beginTime = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//beginTime在当前时间的左侧</span>CFTimeInterval timeSincePause = [<span class="hljs-symbol">layer</span> convertTime:CACurrentMediaTime() fromLayer:nil] - puasedTime;<span class="hljs-symbol">layer</span>.beginTime = timeSincePause;</code></pre><pre><code class="hljs angelscript"><span class="hljs-comment">//动画恢复的时间点,要求:</span><span class="hljs-number">1.</span>beginTime = currentTime - timeOffset<span class="hljs-number">2.</span>timeOffset = <span class="hljs-number">0</span></code></pre><h2 id="CAMediaTiming-Delegate"><a href="#CAMediaTiming-Delegate" class="headerlink" title="CAMediaTiming Delegate"></a>CAMediaTiming Delegate</h2><p>CAAimation, CALayer 都遵循 CAMediatiming 协议,都包含下列属性<br><code>begintTime</code> <code>speed</code> <code>timeoffset</code> <code>duration</code> <code>repeatDuration</code> <code>repeatCount</code> <code>fillmode</code></p><p><img src="https://upload-images.jianshu.io/upload_images/3340896-2a7edb149c839e71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAMediaTiming的理解"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514">Core Animation Programming Guide</a></p><p><a href="https://blog.csdn.net/xiaolinyeyi/article/details/51736907">xiaolinyeyi</a></p><p><a href="https://blog.csdn.net/u013282174/article/details/51605403">DH’s Den</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreAnimation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP简介及Aspects介绍</title>
    <link href="/blog/2018/03/29/iOS/Aspects-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/"/>
    <url>/blog/2018/03/29/iOS/Aspects-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><p><img src="https://upload-images.jianshu.io/upload_images/3340896-1096322e544ec637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aop"></p><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h2 id="Aspects-简介"><a href="#Aspects-简介" class="headerlink" title="Aspects 简介"></a>Aspects 简介</h2><p><img src="https://upload-images.jianshu.io/upload_images/3340896-cf3f479419055275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="aspects"><br>一个轻量的单一的AOP库, 它让我们能够使用 method swizzling 技术 为每个类或者实例对象的方法添加执行代码.</p><h3 id="Aspects-在-iOS-开发常用使用场景"><a href="#Aspects-在-iOS-开发常用使用场景" class="headerlink" title="Aspects 在 iOS 开发常用使用场景"></a>Aspects 在 iOS 开发常用使用场景</h3><ul><li>监测用户点击事件</li><li>记录用户某一页面的留存</li><li>用户使用频率<br>…</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>Aspects 能够在调试的时候被用来动态添加日志</p><pre><code class="hljs scheme">[<span class="hljs-name">UIViewController</span> aspect_hookSelector:@selector(<span class="hljs-name">viewWillAppear:</span>) withOptions:AspectPositionAfter usingBlock:^(<span class="hljs-name">id&lt;AspectInfo&gt;</span> aspectInfo, BOOL animated) &#123;    NSLog(<span class="hljs-name">@</span><span class="hljs-string">&quot;View Controller %@ will appear animated: %tu&quot;</span>, aspectInfo.instance, animated)<span class="hljs-comment">;</span>&#125; error:NULL]<span class="hljs-comment">;</span></code></pre><h2 id="原理简析"><a href="#原理简析" class="headerlink" title="原理简析"></a>原理简析</h2><p>讲解原理前我们先熟悉一下<code>Objective-C</code>的消息转发流程</p><h3 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程:"></a>消息转发流程:</h3><ul><li><code>resolveInstanceMethod:</code><br>当实例对象无法找到 sel 实现时，首先调用此方法，对sel做处理</li><li><code>resolveClassMethod:</code><br>当类对象无法找到 sel 实现时，首先调用此方法，对sel做处理</li><li><code>forwardTargetForSelector:</code><br>sel 仍未处理，接着调用此方法，在这里可以对sel做处理</li><li><code>methodSignatureForSelector:</code><br>sel 仍未处理，runtime会通过<code>methodSigntureForSelector</code>方法尝试获取本次消息调用的具体环境信息，包括消息的参数与返回值类型。并封装成NSInvocation对象。我们可以在<code>forwardInvocation</code>方法内部对该对象作进一步的处理，并使之能够成功的完成消息处理。如果未能成功获取<code>NSInvocation</code>对象，那么程序就会发送<code>doesNotRecognizeSelector</code>消息抛出<code>unrecognized Selector send to xxx</code>的异常</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p><strong>重要</strong><br>Aspects 利用 <code>Objective-C</code> 的消息转发机制,在对象或类调用<code>selector</code>的时候,直接将其<code>IMP</code>替换为<code>objc_msgForward</code>,从而走消息转发流程,通过hook <code>forwardInvocation:</code>方法,将其<code>IMP</code>替换为自定义的<code>IMP</code>从而实现执行代码的添加和方法的替换.</p></blockquote><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><ul><li><p>替换selector的IMP,执行 objc_msgForward 函数,直接走消息转发</p><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!aspect<span class="hljs-constructor">_isMsgForwardIMP(<span class="hljs-params">targetMethodIMP</span>)</span>) &#123;       ...       ...       <span class="hljs-keyword">class</span><span class="hljs-constructor">_replaceMethod(<span class="hljs-params">klass</span>, <span class="hljs-params">selector</span>, <span class="hljs-params">aspect_getMsgForwardIMP</span>(<span class="hljs-params">self</span>, <span class="hljs-params">selector</span>)</span>, typeEncoding);       <span class="hljs-constructor">AspectLog(@<span class="hljs-string">&quot;Aspects: Installed hook for -[%@ %@].&quot;</span>, <span class="hljs-params">klass</span>, NSStringFromSelector(<span class="hljs-params">selector</span>)</span>);   &#125;</code></pre></li><li><p>hook <code>forwardInvocation:</code>方法,将其IMP替换为<code>__ASPECTS_ARE_BEING_CALLED__</code></p></li></ul><pre><code class="hljs reasonml">static NSString *const AspectsForwardInvocationSelectorName = @<span class="hljs-string">&quot;__aspects_forwardInvocation:&quot;</span>;static void aspect<span class="hljs-constructor">_swizzleForwardInvocation(Class <span class="hljs-params">klass</span>)</span> &#123;    <span class="hljs-constructor">NSCParameterAssert(<span class="hljs-params">klass</span>)</span>;    <span class="hljs-comment">// If there is no method, replace will act like class_addMethod.</span>    IMP originalImplementation = <span class="hljs-keyword">class</span><span class="hljs-constructor">_replaceMethod(<span class="hljs-params">klass</span>, @<span class="hljs-params">selector</span>(<span class="hljs-params">forwardInvocation</span>:)</span>, (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="hljs-string">&quot;v@:@&quot;</span>);    <span class="hljs-keyword">if</span> (originalImplementation) &#123;        <span class="hljs-keyword">class</span><span class="hljs-constructor">_addMethod(<span class="hljs-params">klass</span>, NSSelectorFromString(AspectsForwardInvocationSelectorName)</span>, originalImplementation, <span class="hljs-string">&quot;v@:@&quot;</span>);    &#125;    <span class="hljs-constructor">AspectLog(@<span class="hljs-string">&quot;Aspects: %@ is now aspect aware.&quot;</span>, NSStringFromClass(<span class="hljs-params">klass</span>)</span>);&#125;</code></pre><ul><li><code>forwardInvocation:</code>方法执行IMP<code>__ASPECTS_ARE_BEING_CALLED__</code></li></ul><pre><code class="hljs reasonml"><span class="hljs-comment">// This is the swizzled forwardInvocation: method.</span>static void <span class="hljs-constructor">__ASPECTS_ARE_BEING_CALLED__(<span class="hljs-params">__unsafe_unretained</span> NSObject <span class="hljs-operator">*</span><span class="hljs-params">self</span>, SEL <span class="hljs-params">selector</span>, NSInvocation <span class="hljs-operator">*</span><span class="hljs-params">invocation</span>)</span> &#123;        ...    ...    <span class="hljs-comment">// Before hooks.</span>    aspect<span class="hljs-constructor">_invoke(<span class="hljs-params">classContainer</span>.<span class="hljs-params">beforeAspects</span>, <span class="hljs-params">info</span>)</span>;    aspect<span class="hljs-constructor">_invoke(<span class="hljs-params">objectContainer</span>.<span class="hljs-params">beforeAspects</span>, <span class="hljs-params">info</span>)</span>;    <span class="hljs-comment">// Instead hooks.</span>    BOOL respondsToAlias = YES;    <span class="hljs-keyword">if</span> (objectContainer.insteadAspects.count<span class="hljs-operator"> || </span>classContainer.insteadAspects.count) &#123;        aspect<span class="hljs-constructor">_invoke(<span class="hljs-params">classContainer</span>.<span class="hljs-params">insteadAspects</span>, <span class="hljs-params">info</span>)</span>;        aspect<span class="hljs-constructor">_invoke(<span class="hljs-params">objectContainer</span>.<span class="hljs-params">insteadAspects</span>, <span class="hljs-params">info</span>)</span>;    &#125;<span class="hljs-keyword">else</span> &#123;        Class klass = <span class="hljs-keyword">object</span><span class="hljs-constructor">_getClass(<span class="hljs-params">invocation</span>.<span class="hljs-params">target</span>)</span>;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-keyword">if</span> ((respondsToAlias = <span class="hljs-literal">[<span class="hljs-identifier">klass</span> <span class="hljs-identifier">instancesRespondToSelector</span>:<span class="hljs-identifier">aliasSelector</span>]</span>)) &#123;                <span class="hljs-literal">[<span class="hljs-identifier">invocation</span> <span class="hljs-identifier">invoke</span>]</span>;                break;            &#125;        &#125;<span class="hljs-keyword">while</span> (!respondsToAlias<span class="hljs-operator"> &amp;&amp; </span>(klass = <span class="hljs-keyword">class</span><span class="hljs-constructor">_getSuperclass(<span class="hljs-params">klass</span>)</span>));    &#125;    <span class="hljs-comment">// After hooks.</span>    aspect<span class="hljs-constructor">_invoke(<span class="hljs-params">classContainer</span>.<span class="hljs-params">afterAspects</span>, <span class="hljs-params">info</span>)</span>;    aspect<span class="hljs-constructor">_invoke(<span class="hljs-params">objectContainer</span>.<span class="hljs-params">afterAspects</span>, <span class="hljs-params">info</span>)</span>;    ...    ...&#125;</code></pre><ul><li>在上一步中会根据<code>AspectOptions</code>按顺序执行block内代码，内部<code>forwardInvocation</code>方法调用时获取<code>NSInvocation</code>信息，然后用该信息生成一个参数相同的<code>blockInvocation</code>，再调用<code>invokeWithTarget</code>方法，来执行block内代码</li></ul><pre><code class="hljs objectivec">- (<span class="hljs-built_in">BOOL</span>)invokeWithInfo:(<span class="hljs-keyword">id</span>&lt;AspectInfo&gt;)info &#123;    <span class="hljs-built_in">NSInvocation</span> *blockInvocation = [<span class="hljs-built_in">NSInvocation</span> invocationWithMethodSignature:<span class="hljs-keyword">self</span>.blockSignature];    <span class="hljs-built_in">NSInvocation</span> *originalInvocation = info.originalInvocation;    <span class="hljs-built_in">NSUInteger</span> numberOfArguments = <span class="hljs-keyword">self</span>.blockSignature.numberOfArguments;    <span class="hljs-comment">// Be extra paranoid. We already check that on hook registration.</span>    <span class="hljs-keyword">if</span> (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;        AspectLogError(<span class="hljs-string">@&quot;Block has too many arguments. Not calling %@&quot;</span>, info);        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;    &#125;    <span class="hljs-comment">// The `self` of the block will be the AspectInfo. Optional.</span>    <span class="hljs-keyword">if</span> (numberOfArguments &gt; <span class="hljs-number">1</span>) &#123;        [blockInvocation setArgument:&amp;info atIndex:<span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">void</span> *argBuf = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> idx = <span class="hljs-number">2</span>; idx &lt; numberOfArguments; idx++) &#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];<span class="hljs-built_in">NSUInteger</span> argSize;<span class="hljs-built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="hljs-literal">NULL</span>);        <span class="hljs-keyword">if</span> (!(argBuf = reallocf(argBuf, argSize))) &#123;            AspectLogError(<span class="hljs-string">@&quot;Failed to allocate memory for block invocation.&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;        [originalInvocation getArgument:argBuf atIndex:idx];[blockInvocation setArgument:argBuf atIndex:idx];    &#125;        [blockInvocation invokeWithTarget:<span class="hljs-keyword">self</span>.block];        <span class="hljs-keyword">if</span> (argBuf != <span class="hljs-literal">NULL</span>) &#123;        free(argBuf);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/steipete/Aspects">Aspects</a><br><a href="https://www.jianshu.com/p/88ce7c4c2b2a">Runtime编程指南</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>切面编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVC 编程指南</title>
    <link href="/blog/2018/03/15/iOS/KVC-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <url>/blog/2018/03/15/iOS/KVC-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="关于Key-Value-Coding"><a href="#关于Key-Value-Coding" class="headerlink" title="关于Key-Value Coding"></a>关于Key-Value Coding</h2><p>键值编码是一种由NSKeyValueCoding非正式协议启用的机制，协议对象采用该协议来间接访问其属性。当一个对象兼容键值编码时，它的属性通过一个简洁的、统一的消息接口来使用字符串参数寻址。这种间接访问机制补充了实例变量及其相关访问方法所提供的直接访问。</p><p>您通常使用访问器方法来获得对对象属性的访问。获取访问器(或getter)返回一个属性的值。设置访问器(或setter)设置属性的值。在objective-c中，还可以直接访问属性的底层实例变量。在任何一种方法中访问对象属性都很简单，但需要调用属性特定的方法或变量名。随着属性列表的增长或变化，也必须使用访问这些属性的代码。与此相反，一个键值编码兼容的对象提供了一个简单的消息接口，它在所有属性中都是一致的。</p><p>键值编码是许多其他Cocoa技术的基础概念，如键值观察、Cocoa绑定、Core Data和applescript能力。在某些情况下，键值编码也有助于简化代码。</p><h3 id="使用服从Key-Value-Coding-的对象"><a href="#使用服从Key-Value-Coding-的对象" class="headerlink" title="使用服从Key-Value Coding 的对象"></a>使用服从Key-Value Coding 的对象</h3><p>对象通常在继承NSObject(直接或间接)时即采用了键值编码，它们都采用NSKeyValueCoding协议，并为基本方法提供默认实现。这样的对象通过一个紧凑的消息传递接口使其他对象能够执行以下操作:</p><ul><li><p>访问对象的属性。该协议指定了一些方法，例如通用的getter valueForKey:和通用的setter setValue:forKey:用于访问对象属性通过属性名(或键，参数化的字符串)。这些对象相关方法的默认实现使用键来定位和与底层数据交互。</p></li><li><p>操作集合属性。与其他属性一样，访问方法的默认实现与对象的集合属性(例如NSArray对象)实现相同。此外，如果一个对象定义了一个属性的集合访问器方法，那么它可以使用键值访问获取到集合的内容。这通常比直接访问更有效，并允许您通过标准化接口使用自定义集合对象。</p></li><li><p>在集合对象上调用集合操作符。当在键值编码兼容对象中访问集合属性时，可以将集合操作符插入到关键字字符串。集合操作符指示默认的NSKeyValueCoding getter实现对集合的取值操作，然后返回一个新的、经过筛选的集合版本，或者一个表示集合特征的单一值。</p></li><li><p>访问非对象属性。协议的默认实现会检测非对象属性，包括标量和结构体，并自动将它们封装起来，作为在协议接口上使用的对象。此外，该协议声明了一种方法，允许一个服从协议的对象在通过键值编码给一个非对象类型赋值为nil时,提供一个合适的响应.</p></li><li><p>通过keyPath访问属性。当您有一个符合键值编码的对象的层级结构时，您可以使用基于keyPath的方法在层次结构中调用单个方法来获取或来设置一个值。</p></li></ul><h3 id="为对象采用键值编码"><a href="#为对象采用键值编码" class="headerlink" title="为对象采用键值编码"></a>为对象采用键值编码</h3><p>为了使您自己的对象具有键值编码兼容，您确保他们采用了<code>NSKeyValueCoding</code>非正式协议并实现了相应的方法，例如<code>valueForKey:</code>作为通用的getter和 <code>setValue:forKey:</code> 作为通用的setter。幸运的是，如上所述，NSObject采用了这个协议，并为这些和其他基本方法提供了默认实现。因此，如果您从NSObject(或它的许多子类)派生对象，那么大部分工作已经为您完成了。</p><p>为了使默认的方法能够执行它们的工作，您可以确保对象的访问器方法和实例变量遵循某些定义良好的格式。这允许默认实现在对键值编码消息的响应中找到对象的属性。然后，您通过提供的校验方法可选地去扩展和自定义键值编码并且处理某些特殊的情况.</p><h3 id="Swift中的键值编码"><a href="#Swift中的键值编码" class="headerlink" title="Swift中的键值编码"></a>Swift中的键值编码</h3><p>从NSObject继承的Swift对象或其子类的默认属性遵循键值编码协议。而在Objective - C中，属性的访问器和实例变量必须遵循特定的模式，Swift的标准属性声明会自动保证这一点。另一方面，许多协议的特性要么不相关，要么使用在objective - c中不存在的本地Swift构造或一些技术能够更好地处理。例如,所有的Swift属性都是对象,你不必再操心对非对象属性默认实现的特殊处理</p><p>因此，虽然键值编码协议方法直接转换为Swift，但这个指南主要关注objective - c，在这里您需要做更多的工作以确保遵从性，在什么地方键值编码通常是最适合的。</p><h3 id="其他依赖键值编码的-Cocoa-技术"><a href="#其他依赖键值编码的-Cocoa-技术" class="headerlink" title="其他依赖键值编码的 Cocoa 技术"></a>其他依赖键值编码的 Cocoa 技术</h3><p>一个符合键值编码的对象在Cocoa技术参与广泛，这些技术依赖于这种访问方式，包括:</p><ul><li><p>键-值观察。这个机制使对象能够注册异步通知，这是由另一个对象属性的变化所驱动的，如键值观察编程指南所述。</p></li><li><p>Cocoa 绑定。这个技术集合完全实现了一个模型-视图-控制器范例，模型封装应用程序数据，视图显示和编辑数据，控制器在两者之间进行协调。阅读Cocoa绑定编程主题，了解更多关于Cocoa绑定的知识。</p></li><li><p>Core Data。这个框架为对象生命周期和对象持久化相关的常见任务提供了通用的和自动化的解决方案。更多了解您可以阅读Core Data编程指南。</p></li><li><p>AppleScript。这种脚本语言可以直接控制脚本应用程序和macOS的许多部分。Cocoa的脚本支持利用了键值编码来获取和设置脚本对象中的信息。NSScriptKeyValueCoding非正式协议中的方法为使用键值编码提供了额外的功能，包括通过索引在多值密钥中获取和设置键值，并强制(或转换)键值到适当的数据类型。AppleScript概述提供了AppleScript及其相关技术的高级概述。</p></li></ul><hr><h2 id="键值编码原理"><a href="#键值编码原理" class="headerlink" title="键值编码原理"></a>键值编码原理</h2><h3 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h3><p>一个对象在它的接口声明中明确属性.这些属性属于下面类别中的一种:</p><ul><li><p>属性(Attributes).这些属性是一些单一的值,例如一个标量,字符串,或者布尔类型的值.值对象诸如NSNumber和其他不可变类型比如NSColor也都被认为是属性.</p></li><li><p>一对一关系.这些属性是可变对象并且拥有他们自己的属性.一个对象的属性可以改变而无需改变对象自身.举例来说,一个 <code>bank account</code> 对象可能有一个<code>owner</code>属性,该属性是一个<code>Person</code>类型的对象.而<code>person</code>对象又有一个<code>address</code>属性.<code>owner</code>的<code>address</code>可能改变而 <code>bank account</code> 却不需要改变对<code>owner</code>的引用持有.<code>bank account</code> 的<code> owner</code>没有改变,仅仅是它的地址改变了.</p></li><li><p>一对多关系.这些属性是集合类型对象.尽管自定义集合类页可以实现,但是通常用一个NSArray或NSSet实例去持有该集合.</p></li></ul><p>BankAccount对象声明每种属性类型,如下:</p><p><strong>Listing 2-1</strong> <code> BankAccount</code>对象的属性</p><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">BankAccount </span>: NSObject<span class="hljs-variable">@property</span> (nonatomic) NSNumber* currentBalance;   <span class="hljs-comment">//An Attribute </span><span class="hljs-variable">@property</span> (nonatomic) Person*   owner;            <span class="hljs-comment">//A to-one relation  一对一关系</span><span class="hljs-variable">@property</span> (nonatomic) NSArray&lt; Transaction* &gt;* transactions;<span class="hljs-comment">//A to-many relation 一对多关系</span><span class="hljs-variable">@end</span></code></pre><p>为了持有包装的属性,一个对象在它的接口中为其属性提供了访问器方法.对象的创建者可以自定义访问器方法,或者依赖编译器去自动生成访问器方法.总之,代码的创建者使用这些访问器必须在编译前写明属性的名字.访问器方法的名字存储在静态存储区.举例来说,给定的 <code>bank account</code> 对象声明如** Listing 2-1 **,编译器会为<code>myAccount</code>对象生成一个setter方法来供你使用:</p><pre><code class="hljs scheme">[<span class="hljs-name">myAccount</span> setCurrentBalance:@(<span class="hljs-name">100.0</span>)]<span class="hljs-comment">;</span></code></pre><p>这种赋值方式直接,但是缺乏灵活性. 一个键值编码键值对象,提供一个更普遍的机制,使用字符串标签去访问一个对象的属性.</p><h4 id="使用key和key-Path来识别一个对象的属性"><a href="#使用key和key-Path来识别一个对象的属性" class="headerlink" title="使用key和key Path来识别一个对象的属性"></a>使用key和key Path来识别一个对象的属性</h4><p>key 是一个字符串用来识别具体的属性.通俗地讲, key代表一个属性.key必须使用ASCII编码,不可用包含空格,并且通常以小写字母开头(尽管有例外,比如在许多类中的URL属性)</p><p>因为<code>BankAccount</code>类兼容键值编码,它识别keys所对应的<code>owner</code>, <code>currentBalance</code>, <code>transactions</code>,这些对象的属性名.而不是调用 <code>setCurrentBalance: </code>方法,可以根据它的key来给其属性赋值:</p><pre><code class="hljs scheme">[<span class="hljs-name">myAccount</span> setValue:@(<span class="hljs-name">100.0</span>) forKey:@<span class="hljs-string">&quot;currentBalance&quot;</span>]<span class="hljs-comment">;</span></code></pre><p>事实上,你可以给myAccount对象使用该方法设置所有属性的值.只需要替换不同的key参数就行.因为参数是一个字符串,使其可以作为一个变量在运行时中进行操作.</p><p>key path 是一个以.符号做为key分割标记,来遍历对象的属性.在遍历中第一个key对应的属性跟receiver关联.每个子遍历key都更它上一级的属性值关联.key path对于多层次结构对象的属性调用很有用.</p><p>举例来说,keypath owner.address.street 应用于一个bank account实例对象.对应关联一个street字符串作为其值.假设Person和Address类也兼容键值编码,该字符串存储在bank account的owner属性所对应的address中.</p><blockquote><p>注意<br>在 Swift 中, 你可以使用#keyPath表示方式来取代使用一个字符串去表示一个key或者keypath.这种方式提供了编译时检测的优点.</p></blockquote><h4 id="使用key获取属性值"><a href="#使用key获取属性值" class="headerlink" title="使用key获取属性值"></a>使用key获取属性值</h4><p>一个兼容键值编码的对象,该对象继承自NSObject,一个从NSObject继承的对象，它提供了协议的基本方法的默认实现，它会自动采用该协议，并带有某些默认行为。这样的对象至少实现了以下基本的key-bassed getters:</p><ul><li><p><code>valueForKey: </code>根据key参数返回属性的值.如果以key命名的属性根据 访问器搜索格式 中的规则无法找到,该对象会给自己发送一个 <code>valueForUndefinedKey:</code> 消息. <code>valueForUndefinedKey: </code>方法的默认实现会吊起一个<code>NSUndefinedKeyException</code>,但是子类可以重写,并且更优雅的处理这种情况.</p></li><li><p><code>valueForKeyPath:</code> 返回对象指定键路径下的值.任何在键路径遍历下没有与之相匹配的键值编码兼容,意味着使用 <code>valueForKey: </code>的默认实现无法找到相对应的访问器方法.对象则调用 <code>valueForUndefinedKey:</code> 方法.</p></li><li><p><code>dictionaryWithValuesForKeys:</code> 根据数组里面所有key返回相关的键值字典.数组中每个key都会调用<code>valueForKey:</code>方法.返回值为一个字典,包含数组中所有的key和与之相关的值.</p></li></ul><blockquote><p>注意<br>集合类型对象,比如NSArray,NSSet,NSDictionary,不能把nil作为值包含进去.可以使用NSNull对象代表一个空值.NSNull提供一个实例来表示对象属性的空值. <code>dictionaryWithValuesForKeys: </code>方法和相关的 <code>setValuesForKeysWithDictionary: </code>方法 的默认实现 自动在NSNull(在字典参数中)和nil(在存储属性中)之间转换</p></blockquote><p>当你使用一个键路径去寻址一个属性时,如过键路径下的最后的key对应的是一个一对多的属性(意味着关联一个集合),返回值是一个包含所有键对应的值的集合.举例来讲,请求<code>transactions.payee</code>路径下的值,返回在所有<code>transactions</code>下<code>payee</code>对象的数组.keypath中多个数组同样适用.<code>accounts.transactions.payee</code>返回在所有<code>accountes</code>对象下,所有<code>transactions</code>下的<code>payee</code>组成的数组.</p><h4 id="使用key给属性赋值"><a href="#使用key给属性赋值" class="headerlink" title="使用key给属性赋值"></a>使用key给属性赋值</h4><p>和getter方法一样,键值编码对象也提供了基于NSKeyValueCoding协议实现的一组setter方法:</p><ul><li><p><code>setValue: forkey:</code> 给对象指定键赋值.该方法默认自动解包表示标量和结构体的NSNumber和NSValue对象,并且将这些解包后的值赋给对应属性.<br>如果将要赋值的键不存在,则对象调用 <code>setValue: forUndefinedKey:</code> 方法.默认会吊起<code>NSUndefinedKeyException.</code>然而,子类可以重写该方法,并且以自定义的方式处理.</p></li><li><p><code>setValue: forKeyPath:</code> 设置指定键路径下的值.对象在键路径遍历下未找到相关属性,则调用<code>setValue:forUndefinedKey:</code>方法.</p></li><li><p><code>setValuesForKeyswithDictionary: </code>给字典中所有key对应的属性赋值.默认实现是给每个键值对调用<code>setValue:forKey:</code>方法.如果有必要的话,用NSNull对象替换nil</p></li></ul><p>在默认实现中,当试图给一个非对象属性赋值nil时,键值编码兼容对象会给自身发送一个<code>setNilValueForKey:</code>消息.该方法默认会吊起<code>NSInvalidArgumentException</code>.但是一个对象可以重写该方法,去替代默认实现或者用一个标量值替代.</p><h4 id="使用键去简化对象访问"><a href="#使用键去简化对象访问" class="headerlink" title="使用键去简化对象访问"></a>使用键去简化对象访问</h4><p>通过键值编码的setter和getter能够简化代码.在macOS中,NSTableView,NSOutlineView对象在他们的列中标记一个字符串id.如果模型对应的表格不兼容键值编码,表格数据源方法会去强制检查每一列的id找到相关属性并返回.未来,当添加一个属性给模型的时候,例如Person对象的那中情况,你必须重新访问数据源方法,为新属性的测试添加另一种条件,并且返回相关的值.</p><p><strong>Listing 2-2</strong> 不适用键值编码的数据源方法实现</p><pre><code class="hljs groovy">- (id)<span class="hljs-attr">tableView:</span>(NSTableView *)tableview <span class="hljs-attr">objectValueForTableColumn:</span>(id)column <span class="hljs-attr">row:</span>(NSInteger)row&#123;    id result = nil;    Person *person = [self.people <span class="hljs-attr">objectAtIndex:</span>row];     <span class="hljs-keyword">if</span> ([[column identifier] <span class="hljs-attr">isEqualToString:</span>@<span class="hljs-string">&quot;name&quot;</span>]) &#123;        result = [person name];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([[column identifier] <span class="hljs-attr">isEqualToString:</span>@<span class="hljs-string">&quot;age&quot;</span>]) &#123;        result = @([person age]);  <span class="hljs-comment">// Wrap age, a scalar, as an NSNumber</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([[column identifier] <span class="hljs-attr">isEqualToString:</span>@<span class="hljs-string">&quot;favoriteColor&quot;</span>]) &#123;        result = [person favoriteColor];    &#125; <span class="hljs-comment">// And so on...</span>     <span class="hljs-keyword">return</span> result;&#125;</code></pre><p><strong>Listing 2-3</strong> 展示了一个使用兼容键值编码的<code>Person</code>对象 更紧凑的数据源方法实现方式. 只需要使用 <code>valueForKey</code> getter方法,数据源方法就会使用列的标签作为key返回合适的值. 除了更简洁外,也更加通俗易懂,因为只要列标识符总是与模型对象的属性名匹配，它就会在稍后添加新列时保持不变。</p><p><strong>Listing 2-3</strong> 使用键值编码实现数据源方法</p><pre><code class="hljs groovy">- (id)<span class="hljs-attr">tableView:</span>(NSTableView *)tableview <span class="hljs-attr">objectValueForTableColumn:</span>(id)column <span class="hljs-attr">row:</span>(NSInteger)row&#123;    <span class="hljs-keyword">return</span> [[self.people <span class="hljs-attr">objectAtIndex:</span>row] <span class="hljs-attr">valueForKey:</span>[column identifier]];&#125;</code></pre><hr><h3 id="访问集合属性"><a href="#访问集合属性" class="headerlink" title="访问集合属性"></a>访问集合属性</h3><p>键值编码兼容对象像公开其他属性的方式一样公开它的一对多属性.可以使用<code>valueForKey:</code>和 <code>setValue: forKey:</code> (或者他们的 keyPath) 方法来给对象的集合属性赋值和访问. 然而,当想要对集合内容进行操作时,通常使用协议定义的可变代理方法是最有效的.</p><p>协议定义了三个不同代理方法用来对集合对象进行访问:</p><ul><li><code>mutableArrayValueForKey:</code> 和 <code>mutableArrayValueForKeyPath:</code></li></ul><p>方法返回一个代理对象,该对象是一个<code>NSMutableArray</code>对象.</p><ul><li><code>mutableSetValueForKey:</code> 和 <code>mutableSetValueForKeyPath:</code></li></ul><p>方法返回一个代理对象,该对象是一个<code>NSMutableSet</code>对象.</p><ul><li><code>mutableOrderedSetValueForKey:</code> 和 <code>mutableOrderedSetValueForKeyPath:</code></li></ul><p>方法返回一个代理对象,该对象是一个<code>NSMutableOrderedSet</code>对象.</p><p>当操作一个代理对象时,从集合中添加.删除,替换对象,协议的默认实现会相应地修改对应的下标属性.这种方式比使用 valueForKey: 方法获取不可变集合效率更高,创建一个可变集合,然后使用setValue: forKey: 消息将元素存储到集合中. 在许多情况下, 与直接使用可变属性相比,这种方式效率更高.这些方法为集合中对象的键值观察提供了额外的好处.</p><hr><h3 id="使用集合运算符"><a href="#使用集合运算符" class="headerlink" title="使用集合运算符"></a>使用集合运算符</h3><p>当发送一个<code>valueForKeyPaht:</code>消息给键值兼容对象时,可以在key path 中嵌入一个集合运算符,集合运算符是关键字列表中的一个.在它前面有一个@符号,来表示在getter返回前,以某种方式执行数据操作. valueForKeyPath:的默认实现由NSObject来提供.<br>当一个 keyPath 包含一个集合运算符时,运算符前面的keyPath,称为left key path,表示该集合相对于消息接受者的操作. 如果将消息直接发送到集合对象,例如NSArray实例,则可以省略左边的key path.<br>运算符后面的keypath部分,称为right key Path,指定运算符要操作的集合中的对象属性.处理@count所有的集合运算符都需要一个right key path. Figure 4-1 阐明了运算符keypath格式.</p><p>下图为运算符 key path  格式</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-63cef07595f087a5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Figure 4-1"></p><hr><p>集合运算符的三种类型:<br>Aggregaion Operators, Array Operatiors, Nesting Operators</p><p>下面这段代码演示了如何执行每个运算符的相关操作.</p><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">Transaction </span>: NSObject <span class="hljs-variable">@property</span> (nonatomic) NSString* payee;   <span class="hljs-comment">// To whom</span><span class="hljs-variable">@property</span> (nonatomic) NSNumber* amount;  <span class="hljs-comment">// How much</span><span class="hljs-variable">@property</span> (nonatomic) NSDate* date;      <span class="hljs-comment">// When</span> <span class="hljs-variable">@end</span></code></pre><h4 id="Aggregation-Operators"><a href="#Aggregation-Operators" class="headerlink" title="Aggregation Operators"></a>Aggregation Operators</h4><p>@avg</p><p>当使用@avg运算符时,<code>valueForKeyPaht:</code>会根据Right key Path中指定的属性读取集合中每个对象相关的值.并且计算他们的平均值.然后会返回一个包含结果的NSNumber实例.</p><p>下面代码,可以获取集合中所有转账的平均值</p><pre><code class="hljs nginx"><span class="hljs-attribute">NSNumber</span> *transactionAverage = [self.transactions valueForKeyPath:@<span class="hljs-string">&quot;<span class="hljs-variable">@avg</span>.amount&quot;</span>];</code></pre><p>@count</p><p>使用@count 运算符, <code>valueForKeyPath: </code>返回一个NSNumber实例表示集合中对象的数量. right key path忽略.</p><p>获取转账的笔数:</p><pre><code class="hljs nginx"><span class="hljs-attribute">NSNumber</span> *numberOfTransactions = [self.transactions valueForKeyPath:@<span class="hljs-string">&quot;<span class="hljs-variable">@count</span>&quot;</span>];</code></pre><p>@max</p><p>当使用@max运算符时, 返回集合中right key path 对应属性的最大值. 内部是使用 compare:方法比较集合中该属性对应的值.在搜索right key path对应属性值时,会忽略集合中的nil值.</p><p>获取日期值的最大值,表示最近的转账日期.</p><pre><code class="hljs nginx"><span class="hljs-attribute">NSDate</span> *latestDate = [self.transactions valueForKeyPath:@<span class="hljs-string">&quot;<span class="hljs-variable">@max</span>.date&quot;</span>];</code></pre><p>@min</p><p>使用@min 运算符时, <code>valueForKeyPath: </code>方法搜索集合中righ key path 对应属的值.并且返回最小的一个.</p><p>返回转账日期中最早的日期.</p><pre><code class="hljs nginx"><span class="hljs-attribute">NSDate</span> *earliestDate = [self.transactions valueForKeyPath:@<span class="hljs-string">&quot;<span class="hljs-variable">@min</span>.date&quot;</span>];</code></pre><p>@sum</p><p>使用 @sum 运算符,计算集合中所有keypath对应属性值的总和.</p><pre><code class="hljs nginx"><span class="hljs-attribute">NSNumber</span> *amountSum = [self.transacitons valueForKeyPath:@<span class="hljs-string">&quot;<span class="hljs-variable">@sum</span>.amount&quot;</span>];</code></pre><h4 id="Array-Operators"><a href="#Array-Operators" class="headerlink" title="Array Operators"></a>Array Operators</h4><p>Array 运算符使用valueForkeyPath: 返回right key path 对应的对象集合.</p><blockquote><p>重要<br>如果使用数组运算符时,任何支对象是空值的话,valueForKeyPath: 方法会抛出异常,</p></blockquote><p>@distinctUnionOfObjects</p><p>使用@distinctUnionOfObjects 运算符, valueForKeyPath: 方法会创建并返回一个数组,该数组包含集合中对象的并集,这些对象与right key path 指定的属性对应.</p><p>获取 payee 属性值的集合.</p><pre><code class="hljs nginx"><span class="hljs-attribute">NSArray</span> *distincPayees = [self.transactions valueForKeyPath:@<span class="hljs-string">&quot;<span class="hljs-variable">@distinctUnionOfObjects</span>.payee&quot;</span>];</code></pre><blockquote><p>注意<br>@unionOfObjects 运算符提供相似的行为,但是不会移除重复的对象.</p></blockquote><p>@unionOfObjects</p><pre><code class="hljs nginx"><span class="hljs-attribute">NSArray</span> *payees = [self.transactions valueForKeyPath:@<span class="hljs-string">&quot;<span class="hljs-variable">@unionOfObjects</span>.payee&quot;</span>];</code></pre><h4 id="Nesting-Operators"><a href="#Nesting-Operators" class="headerlink" title="Nesting Operators"></a>Nesting Operators</h4><p>嵌套运算符在嵌套集合中使用.每个集合入口自身便包含一个集合.</p><blockquote><p>重要</p></blockquote><p>如果使用嵌套运算符时,任何支对象是nil的话,valueForKeyPath:方法会抛出一个异常.</p><p>下面的arrayOfArrays是一个嵌套数组</p><pre><code class="hljs fsharp">NSArray * moreTransactions = @<span class="hljs-meta">[&lt;# transacion data #&gt;]</span>;NSArray * arrayOfArrays    = @[self.transactions, moreTransactions];</code></pre><p>@distinctUnionOfArrays</p><p>使用该运算符时,返回一个数组,该数组包含所有集合中指定key path下所有属性对应的对象.</p><pre><code class="hljs nginx"><span class="hljs-attribute">NSArray</span> *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:@<span class="hljs-string">&quot;<span class="hljs-variable">@distinctUnionOfArrays</span>.payee&quot;</span>];</code></pre><blockquote><p>注意<br>@unionOfArrays 运算符与@distictUnionOfArrays运算符功能类似,但是不会移除重复对象.</p></blockquote><p>@unionOfArrays</p><pre><code class="hljs groovy">NSArray *collectedPayees = [arrayOfArrays <span class="hljs-attr">valueForKeyPath:</span>@<span class="hljs-string">&quot;unionOfArrays.payee&quot;</span>];</code></pre><p>@distincUnionOfSets</p><p>与@distincUnionOfArrays类似,假如示例数据是以集合存储而不是数组,则返回的是一个NSSet集合对象.</p><hr><h3 id="表示非对象类型值"><a href="#表示非对象类型值" class="headerlink" title="表示非对象类型值"></a>表示非对象类型值</h3><p>NSObject提供的键值编码协议方法的默认实现不仅适用于对象属性,在非对象属性中同样适用. 默认实现在对象参数,返回值,和非对象属性之间自动切换.这将允许基于key-based 签名的getter和setter方法保持一致,即使存储属性是一个标量或者结构体.</p><blockquote><p>注意<br>在Swift中所有属性是对象类型.本节只在OC属性中适用.</p></blockquote><p>当调用协议中的getter方法时,比如 valueForKey:, 默认实现决定调用某个特殊的访问器方法或者为指定key提供值的实例变量.如果返回值不是一个对象,getter使用该值去创建一个NSNumber对象(对于标量) 或者NSValue对象(对于结构体) 并且 返回NSNumber或者NSValue.</p><p>类似的,默认情况下,setter方法例如<code>setValue:forKey: </code>通过一个属性访问器或者实例变量来决定其数据类型.如果属性的数据类型不是对象类型,setter方法首先发送一个合适的<code>&lt;type&gt;Value </code>消息给传入的值对象,来提取下标数据,并且将设置的值存储进去.</p><blockquote><p>注意<br>当使用键值编码协议中的一个setter方法给一个非对象属性赋空值时,setter没有明显的执行行为.因而,它会给接受setter方法的对象发送一个<code>setNilValueForKey:</code>方法.默认会吊起一个<code>NSInvalidArgumentException</code>异常.但是子类可以重写改方法.</p></blockquote><h4 id="包装和解包标量类型"><a href="#包装和解包标量类型" class="headerlink" title="包装和解包标量类型"></a>包装和解包标量类型</h4><p>标量类型的默认键值编码实现是使用一个NSNumber实例包装起来,对于每种数据类型,使用下标属性的值创建一个NSNumber对象来提供一个getter返回值.同样该表也展示了使用的访问器方法,该方法是在一个赋值操作中,从setter输入参数中提取值.</p><p>标量类型被包装在NSNumber对象中.</p><blockquote><p>注意<br>在macOS中, 由于历史原因, BOOL的类型定义是作为signed char类型.KVC不会区分这些.所以,当key是一个BOLL类型值时,使用<code>setValue:forKey:</code>方法不能传递像@”true”或者@”YES”这样的值,KVC会尝试执行charValue(应为BOOL类型继承自char类型),但是NSString不会实现该方法,那样会导致一个运行时错误. 反而,只能传递一个NSNumber对象,比如@(1)或者@(YES),当Key时一个BOOL类型时,做为<code>setValue:forKey:</code>的参数.这种限制在iOS中不适用,BOOL类型被定义为本地Boolean类型bool并且KVC执行<code>boolValue</code>方法.这种设置值的方式对一个NSNumber对象或者一个合适格式的NSString对象都是适用的.</p></blockquote><h4 id="包装和解包结构体类型"><a href="#包装和解包结构体类型" class="headerlink" title="包装和解包结构体类型"></a>包装和解包结构体类型</h4><p>自动包装和解包不限于NSPoint,NSRange,NSSize,NSRect.结构体类型(OC编码的)都可以包装在一个NSValue对象中.</p><p><strong>Listing 5-1</strong> 使用一个自定义的结构体的示例类</p><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;        <span class="hljs-keyword">float</span> x, y, z;    &#125;ThreeFloats;<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span></span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) ThreeFloats threeFloats;<span class="hljs-keyword">@end</span></code></pre><p>使用该类的一个叫做myClass的实例,使用KVC获取threeFloats属性的值.</p><pre><code class="hljs applescript">NSValue *<span class="hljs-literal">result</span> = [myClass valueForKey:@:<span class="hljs-string">&quot;threeFloats&quot;</span>];</code></pre><p><code>valueForKey:</code>方法的默认实现调用<code>threeFloats</code>的getter方法.然后返回返回一个NSValue对象,该对象包装着返回值.</p><p>类似的,也可以使用KVC给treeFloats属性赋值</p><pre><code class="hljs groovy">ThreeFloats floats = &#123;<span class="hljs-number">1.</span>,<span class="hljs-number">2.</span>,<span class="hljs-number">3.</span>&#125;;NSValue * value = [NSValue <span class="hljs-attr">valueWithBytes:</span>&amp;floats <span class="hljs-attr">objCType:</span><span class="hljs-meta">@encode</span>(ThreeFloats)];[myClass <span class="hljs-attr">setValue:</span>value <span class="hljs-attr">forKey:</span>@<span class="hljs-string">&quot;ThreeFloats&quot;</span>];</code></pre><p>默认实现使用一个 <code>getValue:</code>消息来解包数据值,然后使用解包的结构体作为参数调用<code>setThreeFloats:</code>方法.</p><h4 id="校验属性"><a href="#校验属性" class="headerlink" title="校验属性"></a>校验属性</h4><p>键值编码协议定义了支持属性校验的方法.使用键值编码兼容对象,可以读取和写入属性数据.也可以使用通过一个key或者keyPath来校验一个属性.当调用<code> validateValue:forKey:error:</code>(或者 <code>validateValue:forKeyPath:error</code>)方法时, 协议的默认实现会为找到一个匹配格式<code> validate&lt;key&gt;:error:</code>的方法而去搜索接受校验信息的的对象,.如果对象没有这样的方法,默认校验成功,返回YES.当一个指定的属性校验方法存在时,返回该方法的调用结果.</p><blockquote><p>注意<br>仅在OC中使用校验.在swift中,属性校验依赖于可选类型和强引用类型检查的编译器来实现.</p></blockquote><p>因为属性指定校验方法通过引用接收值和错误参数.校验可能会有三种结果:</p><p>1.校验方法认为值对象有效,并且不改变值和错误参数,返回YES.<br>2.校验方法认为值对象无效,但是选择不改变值对象.在这种情况下,返回值为NO并且给NSErro对象设置一个错误引用来说明失败原因.<br>3.校验方法认为值对象无效,但是创建了一个新的,有效的值替换掉原来的值.在这种情况下,方法返回YES,而将错误对象保持不变。在返回之前，该方法修改了指向新值对象的值引用。当它进行修改时，方法总是创建一个新的对象，而不是修改旧的对象，即使值对象是可变的。</p><p><strong>Listing 6-1</strong> 属性名校验</p><pre><code class="hljs sas">Person <span class="hljs-comment">* person = [[Person alloc] init];</span>NSError <span class="hljs-comment">* error;</span>NSString <span class="hljs-comment">*name = @&quot;John&quot;;</span><span class="hljs-meta">if</span>(![person validateValue:<span class="hljs-variable">&amp;name</span> forKey:@<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-meta">error</span>:<span class="hljs-variable">&amp;error</span>])&#123;        N<span class="hljs-meta">SLog(</span>@<span class="hljs-string">&quot;%@&quot;</span>,<span class="hljs-meta">error</span>);&#125;</code></pre><h4 id="自动校验"><a href="#自动校验" class="headerlink" title="自动校验"></a>自动校验</h4><p>一般来讲,不管是键值编码协议还是对象的默认实现都没有定义自动执行校验的机制.在您的app需要该功能时,使用该方法校验.</p><h3 id="访问器搜索模式"><a href="#访问器搜索模式" class="headerlink" title="访问器搜索模式"></a>访问器搜索模式</h3><h4 id="基础-Getter-搜索模式"><a href="#基础-Getter-搜索模式" class="headerlink" title="基础 Getter 搜索模式"></a>基础 Getter 搜索模式</h4><p><code>valueForKey:</code>方法的默认实现,给定一个key作为输入参数,执行下面流程,从接受返回值的对象进行操作.</p><p>1.搜索访问器方法,根据 <code>get&lt;KEY&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>或者<code>_&lt;key&gt;</code>这样的名称和顺序来搜索.如果发现,调用并且执行步骤5返回结果.否则执行下一步.</p><p>2.如果没有一个访问器被发现,搜索匹配格式为<code>countOf&lt;Key&gt;</code>和<code>objectIn&lt;Key&gt;AtIndex:</code>和<code>&lt;key&gt;AtIndexes:</code>这些方法.<br>如果这些方法中的第一个和剩余两个方法中至少一个被找到.创建一个集合代理对象,该对象响应所有的NSArray方法,并且返回该集合对象.否则,执行步骤3.</p><p>3.如果没有一个访问器或者数组访问方法被找到,那么接着找 <code>countOf&lt;key&gt;</code>, <code>enumeratorOf&lt;Key&gt;</code>,<code>memberOf&lt;Key&gt;:</code> 这三个方法.</p><p>如果所有三个方法都被找到,创建一个集合代理对象,该对象的所有方法响应NSSet的所有方法,并且返回该对象.否则,执行步骤4</p><p>4.如果没有一个访问器方法或者组合访问方法被找到,并且接受对象的类方法 <code>accessInstanceVariablesDirectly</code>返回YES,接着按照顺序搜索名字为<code>_&lt;key&gt;</code>,<code>_is&lt;Key&gt;</code>,或者<code>is&lt;Key&gt;</code><br>的实例变量,如果找到,直接获取该实例变量的值,执行步骤5,否则执行步骤6</p><p>5.如果检索到的属性值是一个对象指针,返回该结果.<br>如果该值是一个NSNumber支持的标量类型,将它存储在一个NSNumber实例中,并且返回该实例.<br>如果结果是一个NSNumber不支持的标量类型,将其转换为NSValue对象并返回该对象.</p><p>6.如果以上所有的步骤都失败,调用<code>valueForUndefinedKey:</code>方法,默认吊起一个异常,但是子类重写.</p><h4 id="基础-Setter-搜索模式"><a href="#基础-Setter-搜索模式" class="headerlink" title="基础 Setter 搜索模式"></a>基础 Setter 搜索模式</h4><p><code>setValue:forKey:</code>方法执行下面流程:</p><ol><li><p>按照顺序set<Key>:, _set<Key>需要第一访问器.如果找到,使用输入值(或者未包装的值),执行该方法,结束.</p></li><li><p>如果没有访问器被找到,并且类方法 <code>accessInstanceVariablesDirectly</code>返回YES,按照名字为_<key>,_is<Key>,<key>,is<Key>的顺序寻找<br>实例变量.如果找到,则给实例变量直接赋值,结束.</p></li></ol><p>3.以上方法未找到访问器或实例变量,执行<code>setValue:forUndefinedKey:</code>方法,默认抛出异常,子类可以重写该方法.</p><p>Array 和 Set 的搜索格式与以上类似,不赘述.</p><hr><p>想要更多地了解关于 <code>KVC</code> 的API,请移步 <a href="https://www.jianshu.com/p/7f7360ae8e7b">KVC</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1">Key-Value Coding Programming Guide</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git SSH认证</title>
    <link href="/blog/2018/03/12/%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8SSH-%E5%85%AC%E9%92%A5%E8%AE%A4%E8%AF%81/"/>
    <url>/blog/2018/03/12/%E5%B7%A5%E5%85%B7/Git%E4%BD%BF%E7%94%A8SSH-%E5%85%AC%E9%92%A5%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h6 id="许多-Git-服务器都使用-SSH-公钥进行认证。-为了向-Git-服务器提供-SSH-公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。-这个过程在所有操作系统上都是相似的。"><a href="#许多-Git-服务器都使用-SSH-公钥进行认证。-为了向-Git-服务器提供-SSH-公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。-这个过程在所有操作系统上都是相似的。" class="headerlink" title="许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。"></a>许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。</h6><ol><li>首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 <code> ~/.ssh</code> 目录下。 </li></ol><p><img src="http://upload-images.jianshu.io/upload_images/3340896-1b010822f8d11e9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件目录"></p><p>进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥,进去以后是这个样子,说明已经拥护密钥,将 <code>id_rsa.pub</code>文件发送给git管理员,让管理员添加进去.<br><img src="http://upload-images.jianshu.io/upload_images/3340896-44cfaed89c9a17a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="密钥文件"><br>如果没有找到,直接看步骤3</p><ol start="2"><li>打开SouceTree 选择 <code>新建</code> -&gt; <code>从URL克隆</code></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/3340896-646609abed39b165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择从URL克隆"></p><p><code>源URL</code> 填写 <code>git</code>仓库地址, <code>目标路径</code> 选择本地仓库地址,如果仓库链接成功,底下会显示<code>git</code>仓库名称,选择 <code>克隆</code> ,ok,完成项目拷贝,可以开心地使用SourceTree了.<br><img src="http://upload-images.jianshu.io/upload_images/3340896-369777c21dcf1a2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加源路径,目标路径"></p><ol start="3"><li>如果没有在目录下找到<code>id_rsa.pub</code>文件,进入终端,执行以下命令</li></ol><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span></code></pre><p>显示结果</p><pre><code class="hljs groovy">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span>Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.Enter file <span class="hljs-keyword">in</span> which to save the key (<span class="hljs-regexp">/home/</span>schacon<span class="hljs-regexp">/.ssh/</span>id_rsa):Created directory <span class="hljs-string">&#x27;/home/schacon/.ssh&#x27;</span>.Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):Enter same passphrase <span class="hljs-attr">again:</span>Your identification has been saved <span class="hljs-keyword">in</span> <span class="hljs-regexp">/home/</span>schacon<span class="hljs-regexp">/.ssh/</span>id_rsa.Your <span class="hljs-keyword">public</span> key has been saved <span class="hljs-keyword">in</span> <span class="hljs-regexp">/home/</span>schacon<span class="hljs-regexp">/.ssh/</span>id_rsa.pub.The key fingerprint <span class="hljs-attr">is:</span><span class="hljs-attr">d0:</span><span class="hljs-number">82</span>:<span class="hljs-number">24</span>:<span class="hljs-number">8</span><span class="hljs-attr">e:</span><span class="hljs-attr">d7:</span><span class="hljs-attr">f1:</span><span class="hljs-attr">bb:</span><span class="hljs-number">9</span><span class="hljs-attr">b:</span><span class="hljs-number">33</span>:<span class="hljs-number">53</span>:<span class="hljs-number">96</span>:<span class="hljs-number">93</span>:<span class="hljs-number">49</span>:<span class="hljs-attr">da:</span><span class="hljs-number">9</span><span class="hljs-attr">b:</span>e3 你的邮箱</code></pre><p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），点<code>回车键</code>,选择默认存储位置,然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。重新执行步骤1和2就ok了</p><h6 id="想要了解更多Git相关内容-请参考"><a href="#想要了解更多Git相关内容-请参考" class="headerlink" title="想要了解更多Git相关内容,请参考"></a>想要了解更多Git相关内容,请参考</h6><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93">git-scm.com</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShellScript</title>
    <link href="/blog/2018/03/09/Linux/Shell-Script/"/>
    <url>/blog/2018/03/09/Linux/Shell-Script/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs applescript"><span class="hljs-comment">#str    #输出字符串长度</span><span class="hljs-comment">#array[@]     #输出数组长度</span>echo $array[@]    <span class="hljs-comment">#打印数组</span>source ./test1.sh  <span class="hljs-comment">#导入外部文件,可以引用外部文件的变量</span><span class="hljs-comment"># shell script 追踪与debug</span>sh [-nvx] xxx.shOptions:-n: 不需要执行<span class="hljs-keyword">script</span>,仅检查语法问题-v: 在执行<span class="hljs-keyword">script</span>前,先将<span class="hljs-keyword">script</span>内容输出到屏幕上-x:将使用到的<span class="hljs-keyword">script</span>内容显示到屏幕</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天路旅途（三）</title>
    <link href="/blog/2018/02/11/%E9%9A%8F%E7%AC%94/%E5%A4%A9%E8%B7%AF%E6%97%85%E9%80%94%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/blog/2018/02/11/%E9%9A%8F%E7%AC%94/%E5%A4%A9%E8%B7%AF%E6%97%85%E9%80%94%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>旅行路上睡觉质量一般都不太好，晚上醒来好几次，感觉有点喘不过气，但是困意毕竟挡不住，还是昏昏沉沉睡到了天亮。6点多的时候，我起床,简单洗漱了一下，便开始欣赏晨曦中的高原。</p><p>6点钟的时刻,车厢里大部分人还停留在睡梦中,偶尔传过来几声鼾响。望向窗外,阳光穿过云层,将沉睡了一晚的大地唤醒。拉货的卡车也三三两两地留迹于视野。崭新美好的一天,开始了!<br><img src="http://upload-images.jianshu.io/upload_images/3340896-bb07572951c66f15.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阳光穿透云层"><br>旅途上,你要问我什么最美? 我会毫不犹豫地回答:”高原上的云！”清晨从火车窗外望去，漂亮的鳞状云齐整整地排满半边天，仿佛一群绵羊，悠闲地漫步在这湛蓝的天空上。这群绵羊脚下的大地，也在它们的踩踏声中逐渐苏醒。<br><img src="http://upload-images.jianshu.io/upload_images/3340896-1ef43feb6295f554.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="漂亮的鳞状云"><br>有羊的地方，必然水草丰美。高原独特的地理环境，特别适合草甸生长，加上来自雪山的融水，给草甸提供充足的养分，于是便形成了这一望无际的水草肥美之地。<br> <img src="http://upload-images.jianshu.io/upload_images/3340896-e5cc0d011bf08529.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝天与草甸交相辉映"><br>当思想还徜徉在蓝天碧草之时，列车已进入堆龙德庆段，地势陡然变化，由刚才的一望无际，到眼前的重山叠峦。远处的山峰被云雾环绕，近处的河流在山谷间流淌。雪山上的融水，形成无数小小的支流，绕过山谷间冲击形成的平地，绕过平地上生长的阔叶林，汇聚成一条小河，沿着山谷，奔向远方…</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-9eeb941c2bf628ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="列车进入堆龙德庆"><br>列车行至堆龙德庆，也意味着漫长的车厢旅途即将结束。快到拉萨站的时候，列车从奔腾的拉萨河上跨过，在白云和群山之下，眺望远处的布达拉宫，我在心中激动地呐喊——“拉萨，我来啦…”<br><img src="http://upload-images.jianshu.io/upload_images/3340896-0d06f79a099fcb92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="列车上远眺布达拉"></p><p><a href="https://www.jianshu.com/p/bc5b71a337f5">天路旅途 (四)</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YYCategories介绍</title>
    <link href="/blog/2018/02/09/iOS/YYCategories-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/blog/2018/02/09/iOS/YYCategories-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>功能丰富的 Category 类型工具库</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h6 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __has_include(<span class="hljs-meta-string">&lt;YYCategories/YYCategories.h&gt;)</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;YYCategories/YYCategoriesMacro.h&gt;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;YYCategories/NSObject+YYAdd.h&gt;</span></span>...<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;YYCategoriesMacro.h&quot;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;NSObject+YYAdd.h&quot;</span></span>...<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6><p>这样做可以提高编译效率.如果指定文件路径,则搜索的更快一些.<br>一般我们使用YYCategories导入的时候都是库文件,所以指定目录位置搜索更快一些</p><pre><code class="hljs xl">＃<span class="hljs-keyword">import</span> &lt; &gt; 引用系统文件，它用于对系统自带的头文件的引用，编译器会在系统文件目录下去查找该文件.#<span class="hljs-keyword">import</span> <span class="hljs-string">&quot; &quot;</span>  用户自定义的文件用双引号引用，编译器首先会在用户目录下查找，然后到安装目录中查</code></pre><hr><h6 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs cpp">FOUNDATION_EXPORT <span class="hljs-keyword">double</span> YYCategoriesVersionNumber;FOUNDATION_EXPORT <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> YYCategoriesVersionString[];</code></pre><h6 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h6><p>例如比较两个字符串</p><p><code>FOUNDATION_EXPORT</code> 直接使用<code>stringInstance == MyFirstConstant</code>来比较,比较的是指针地址<br><code>define</code>使用<code>[stringInstance isEqualToString:MyFirstConstant]</code><br>比较字符串的每一个字符是否相等<br><code>FOUNDATION_EXPORT</code>效率更高</p><pre><code class="hljs objectivec"><span class="hljs-built_in">NS_ASSUME_NONNULL_BEGIN</span><span class="hljs-comment">/**</span><span class="hljs-comment"> Provides extensions for `UIBarButtonItem`.</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UIBarButtonItem</span> (<span class="hljs-title">YYAdd</span>)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> The block that invoked when the item is selected. The objects captured by block</span><span class="hljs-comment"> will retained by the ButtonItem.</span><span class="hljs-comment"> </span><span class="hljs-comment"> @discussion This param is conflict with `target` and `action` property.</span><span class="hljs-comment"> Set this will set `target` and `action` property to some internal objects.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^actionBlock)(<span class="hljs-keyword">id</span>);<span class="hljs-keyword">@end</span><span class="hljs-built_in">NS_ASSUME_NONNULL_END</span></code></pre><p>该段代码使用了<code>NS_ASSUME_NONNULL_BEGIN</code>,<code>NS_ASSUME_NONNULL_END</code> </p><p>两个宏中间包含的属性,参数值,返回值,默认是 <code>nonnull</code> 类型.</p><p>如果想要某个属性,参数值或者返回值为可选类型,则单独在该属性,参数值,或者返回值前单独标明<code>nullable</code>.</p><h6 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __cplusplus</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YY_EXTERN_C_BEGIN  extern <span class="hljs-meta-string">&quot;C&quot;</span> &#123;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YY_EXTERN_C_END  &#125;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YY_EXTERN_C_BEGIN</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YY_EXTERN_C_END</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h6 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h6><p>在C++环境中有定义 <code>__cplusplus</code> 这个宏,如果在C++环境中, <code>YY_EXTERN_C_BEGIN</code>和 <code>YY_EXTERN_C_END</code>中间的代码,编译器用C语言的编译格式来编译.因为 C++ 为了实现函数重载会把函数名和参数等联合起来合成一个中介的函数名，如果 C 函数也被这样编译会出问题.</p><h6 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs reasonml">#ifndef YY_SWAP <span class="hljs-comment">// swap two value</span>#define <span class="hljs-constructor">YY_SWAP(<span class="hljs-params">_a_</span>, <span class="hljs-params">_b_</span>)</span>  <span class="hljs-keyword">do</span> &#123; <span class="hljs-constructor">__typeof__(<span class="hljs-params">_a_</span>)</span> _tmp_ = (_a_); (_a_) = (_b_); (_b_) = _tmp_; &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)#endif</code></pre><h6 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h6><p>交换两个值</p><h6 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs angelscript">#ifndef YYSYNTH_DUMMY_CLASS#define YYSYNTH_DUMMY_CLASS(_name_) \@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">YYSYNTH_DUMMY_CLASS_</span> ## <span class="hljs-symbol">_name_</span> : <span class="hljs-symbol">NSObject</span> @<span class="hljs-symbol">end</span> \@<span class="hljs-symbol">implementation</span> <span class="hljs-symbol">YYSYNTH_DUMMY_CLASS_</span> ## <span class="hljs-symbol">_name_</span> @<span class="hljs-symbol">end</span>#<span class="hljs-symbol">endif</span></code></pre><h6 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h6><p>如果条件成立,执行断言.</p><h6 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs angelscript">#ifndef YYSYNTH_DUMMY_CLASS#define YYSYNTH_DUMMY_CLASS(_name_) \@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">YYSYNTH_DUMMY_CLASS_</span> ## <span class="hljs-symbol">_name_</span> : <span class="hljs-symbol">NSObject</span> @<span class="hljs-symbol">end</span> \@<span class="hljs-symbol">implementation</span> <span class="hljs-symbol">YYSYNTH_DUMMY_CLASS_</span> ## <span class="hljs-symbol">_name_</span> @<span class="hljs-symbol">end</span>#<span class="hljs-symbol">endif</span></code></pre><h6 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h6><p>在ios开发过程中，有时候会用到第三方的静态库(.a文件)，OC没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，会出现selector not recognized的错误，从而导致app闪退。使用这段宏定义他可以虚拟新建一个与名字category 相同.h.m 让编译器 编译通过。即可解决上面的问题。</p><h6 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs less"><span class="hljs-selector-id">#ifndef</span> <span class="hljs-selector-tag">YYSYNTH_DYNAMIC_PROPERTY_OBJECT</span><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">YYSYNTH_DYNAMIC_PROPERTY_OBJECT</span>(_getter_, _setter_, _association_, _type_) \<span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">_setter_</span> : (_type_)<span class="hljs-selector-tag">object</span> &#123; \    <span class="hljs-selector-attr">[self willChangeValueForKey:@#_getter_]</span>; \    <span class="hljs-selector-tag">objc_setAssociatedObject</span>(self, _cmd, object, OBJC_ASSOCIATION_ ## _association_); \    <span class="hljs-selector-attr">[self didChangeValueForKey:@#_getter_]</span>; \&#125; \<span class="hljs-selector-tag">-</span> (_type_)<span class="hljs-selector-tag">_getter_</span> &#123; \    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">objc_getAssociatedObject</span>(self, <span class="hljs-variable">@selector</span>(<span class="hljs-attribute">_setter_</span>:)); \&#125;<span class="hljs-selector-id">#endif</span></code></pre><h6 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h6><p>使用runtime,合成类别中定义的属性的<code>Setter</code> 和 <code>Getter</code>方法.</p><h6 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs clean">#ifndef weakify    #<span class="hljs-keyword">if</span> DEBUG        #<span class="hljs-keyword">if</span> __has_feature(objc_arc)        #define weakify(object) autoreleasepool&#123;&#125; __weak __typeof__(object) weak##_##object = object;        #else        #define weakify(object) autoreleasepool&#123;&#125; __block __typeof__(object) block##_##object = object;        #endif    #else        #<span class="hljs-keyword">if</span> __has_feature(objc_arc)        #define weakify(object) try&#123;&#125; @finally&#123;&#125; &#123;&#125; __weak __typeof__(object) weak##_##object = object;        #else        #define weakify(object) try&#123;&#125; @finally&#123;&#125; &#123;&#125; __block __typeof__(object) block##_##object = object;        #endif    #endif#endif#ifndef strongify    #<span class="hljs-keyword">if</span> DEBUG        #<span class="hljs-keyword">if</span> __has_feature(objc_arc)        #define strongify(object) autoreleasepool&#123;&#125; __typeof__(object) object = weak##_##object;        #else        #define strongify(object) autoreleasepool&#123;&#125; __typeof__(object) object = block##_##object;        #endif    #else        #<span class="hljs-keyword">if</span> __has_feature(objc_arc)        #define strongify(object) try&#123;&#125; @finally&#123;&#125; __typeof__(object) object = weak##_##object;        #else        #define strongify(object) try&#123;&#125; @finally&#123;&#125; __typeof__(object) object = block##_##object;        #endif    #endif#endif</code></pre><h6 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h6><p>生成一个若引用或者强引用.</p><p>Example:</p><pre><code class="hljs elixir"><span class="hljs-variable">@weakify</span>(<span class="hljs-keyword">self</span>)[<span class="hljs-keyword">self</span> doSomething^&#123;    <span class="hljs-variable">@strongify</span>(<span class="hljs-keyword">self</span>)    if (!<span class="hljs-keyword">self</span>) <span class="hljs-keyword">return</span>;    ...&#125;];</code></pre><h6 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">YYBenchmark</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (^block)(<span class="hljs-keyword">void</span>), <span class="hljs-keyword">void</span> (^complete)(<span class="hljs-keyword">double</span> ms))</span> </span>&#123;    <span class="hljs-comment">// &lt;sys/time.h&gt; version</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">t0</span>, <span class="hljs-title">t1</span>;</span>    gettimeofday(&amp;t0, <span class="hljs-literal">NULL</span>);    block();    gettimeofday(&amp;t1, <span class="hljs-literal">NULL</span>);    <span class="hljs-keyword">double</span> ms = (<span class="hljs-keyword">double</span>)(t1.tv_sec - t0.tv_sec) * <span class="hljs-number">1e3</span> + (<span class="hljs-keyword">double</span>)(t1.tv_usec - t0.tv_usec) * <span class="hljs-number">1e-3</span>;    complete(ms);&#125;</code></pre><h6 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h6><p>这个函数还是挺实用的,可以用来计算block内代码的执行时间,通过该函数来测试写的代码执行效率.</p><p>返回值为毫秒,double类型.</p><pre><code class="hljs excel">/** Profile <span class="hljs-built_in">time</span> cost. @param block     <span class="hljs-built_in">code</span> to benchmark @param complete  <span class="hljs-built_in">code</span> <span class="hljs-built_in">time</span> cost (millisecond)  Usa<span class="hljs-symbol">ge:</span>    YYBenchmark(^&#123;        // <span class="hljs-built_in">code</span>    &#125;, ^(double ms) &#123;        NSLog(<span class="hljs-string">&quot;time cost: %.2f ms&quot;</span>,ms);    &#125;);  */</code></pre><h6 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-built_in">NSDate</span> *_YYCompileTime(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *time) &#123;    <span class="hljs-built_in">NSString</span> *timeStr = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%s %s&quot;</span>,data,time];    <span class="hljs-built_in">NSLocale</span> *locale = [[<span class="hljs-built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="hljs-string">@&quot;en_US&quot;</span>];    <span class="hljs-built_in">NSDateFormatter</span> *formatter = [[<span class="hljs-built_in">NSDateFormatter</span> alloc] init];    [formatter setDateFormat:<span class="hljs-string">@&quot;MMM dd yyyy HH:mm:ss&quot;</span>];    [formatter setLocale:locale];    <span class="hljs-keyword">return</span> [formatter dateFromString:timeStr];&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> Get compile timestamp.</span><span class="hljs-comment"> @return A new date object set to the compile date and time.</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> YYCompileTime</span><span class="hljs-comment">// use macro to avoid compile warning when use pch file</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YYCompileTime() _YYCompileTime(__DATE__, __TIME__)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h6 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h6><p>获取编译开始时间.格式为”MMM dd yyyy HH:mm:ss”</p><h6 id="Code-10"><a href="#Code-10" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><span class="hljs-comment"> Submits a block for execution on a main queue and waits until the block completes.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatch_sync_on_main_queue</span><span class="hljs-params">(<span class="hljs-keyword">void</span> (^block)(<span class="hljs-keyword">void</span>))</span> </span>&#123;    <span class="hljs-keyword">if</span> (pthread_main_np()) &#123;        block();    &#125; <span class="hljs-keyword">else</span> &#123;        dispatch_sync(dispatch_get_main_queue(), block);    &#125;&#125;</code></pre><h6 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h6><p>提交blcok到主队列同步执行.下面提交block到主队列异步执行,使用起来还是蛮方便的.</p><h6 id="Code-NSArray-YYAdd"><a href="#Code-NSArray-YYAdd" class="headerlink" title="Code (NSArray + YYAdd)"></a>Code (NSArray + YYAdd)</h6><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><span class="hljs-comment"> Reverse the index of object in this array.</span><span class="hljs-comment"> Example: Before @[ @1, @2, @3 ], After @[ @3, @2, @1 ].</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">void</span>)<span class="hljs-keyword">reverse</span>;- (<span class="hljs-keyword">void</span>)<span class="hljs-keyword">reverse</span> &#123;    NSUInteger <span class="hljs-keyword">count</span> = self.<span class="hljs-keyword">count</span>;    <span class="hljs-keyword">int</span> mid = floor(<span class="hljs-keyword">count</span> / <span class="hljs-number">2.0</span>);    <span class="hljs-keyword">for</span> (NSUInteger i = <span class="hljs-number">0</span>; i &lt; mid; i++) &#123;        [self exchangeObjectAtIndex:i withObjectAtIndex:(<span class="hljs-keyword">count</span> - (i + <span class="hljs-number">1</span>))];    &#125;&#125;</code></pre><h6 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h6><p>数组翻转</p><h6 id="Code-NSDate-YYADD"><a href="#Code-NSDate-YYADD" class="headerlink" title="Code (NSDate + YYADD)"></a>Code (NSDate + YYADD)</h6><pre><code class="hljs applescript">/** Create data <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> <span class="hljs-keyword">in</span> main bundle (similar <span class="hljs-keyword">to</span> [UIImage imageNamed:]).  @param <span class="hljs-built_in">name</span> The <span class="hljs-built_in">file</span> <span class="hljs-built_in">name</span> (<span class="hljs-keyword">in</span> main bundle).  @<span class="hljs-literal">return</span> A new data create <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span>. */+ (nullable NSData *)dataNamed:(NSString *)<span class="hljs-built_in">name</span>;</code></pre><h6 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h6><p>返回main bundle 下指定文件的的二进制数据.</p><h6 id="Code-NSNumber-YYAdd"><a href="#Code-NSNumber-YYAdd" class="headerlink" title="Code (NSNumber + YYAdd)"></a>Code (NSNumber + YYAdd)</h6><pre><code class="hljs nim">/** <span class="hljs-type">Creates</span> <span class="hljs-keyword">and</span> returns an <span class="hljs-type">NSNumber</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">from</span> a <span class="hljs-built_in">string</span>. <span class="hljs-type">Valid</span> format: @<span class="hljs-string">&quot;12&quot;</span>, @<span class="hljs-string">&quot;12.345&quot;</span>, @<span class="hljs-string">&quot; -0xFF&quot;</span>, @<span class="hljs-string">&quot; .23e99 &quot;</span>...  @param <span class="hljs-built_in">string</span>  <span class="hljs-type">The</span> <span class="hljs-built_in">string</span> described an number.  @<span class="hljs-keyword">return</span> an <span class="hljs-type">NSNumber</span> <span class="hljs-keyword">when</span> parse succeed, <span class="hljs-keyword">or</span> <span class="hljs-keyword">nil</span> <span class="hljs-keyword">if</span> an error occurs. */+ (nullable <span class="hljs-type">NSNumber</span> *)numberWithString:(<span class="hljs-type">NSString</span> *)<span class="hljs-built_in">string</span>;</code></pre><h6 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h6><p>将一个字符串对象解析为NSNumber类型对象,很实用.</p><h6 id="Code-NSObject-YYAdd"><a href="#Code-NSObject-YYAdd" class="headerlink" title="Code (NSObject+YYAdd)"></a>Code (NSObject+YYAdd)</h6><pre><code class="hljs haxe">+ (BOOL)swizzleInstanceMethod:<span class="hljs-type"></span>(SEL)originalSel with:<span class="hljs-type"></span>(SEL)<span class="hljs-keyword">new</span><span class="hljs-type">Sel</span> &#123;    Method originalMethod = class_getInstanceMethod(self, originalSel);    Method <span class="hljs-keyword">new</span><span class="hljs-type">Method</span> = class_getInstanceMethod(self, <span class="hljs-keyword">new</span><span class="hljs-type">Sel</span>);    <span class="hljs-keyword">if</span> (!originalMethod || !<span class="hljs-keyword">new</span><span class="hljs-type">Method</span>) <span class="hljs-keyword">return</span> NO;        class_addMethod(self,                    originalSel,                    class_getMethodImplementation(self, originalSel),                    method_getTypeEncoding(originalMethod));    class_addMethod(self,                    <span class="hljs-keyword">new</span><span class="hljs-type">Sel</span>,                    class_getMethodImplementation(self, <span class="hljs-keyword">new</span><span class="hljs-type">Sel</span>),                    method_getTypeEncoding(<span class="hljs-keyword">new</span><span class="hljs-type">Method</span>));        method_exchangeImplementations(class_getInstanceMethod(self, originalSel),                                   class_getInstanceMethod(self, <span class="hljs-keyword">new</span><span class="hljs-type">Sel</span>));    <span class="hljs-keyword">return</span> YES;&#125;</code></pre><h6 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h6><p>runtime 黑魔法,方法实现交换.</p><h6 id="Code-11"><a href="#Code-11" class="headerlink" title="Code"></a>Code</h6><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic push</span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic ignored <span class="hljs-meta-string">&quot;-相关命令&quot;</span></span>    <span class="hljs-comment">//需要操作的代码</span><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> clang diagnostic pop</span></code></pre><h6 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h6><p>消除编译器警告⚠️</p><table><thead><tr><th>相关命令</th><th>含义</th></tr></thead><tbody><tr><td>“-Wdeprecated-declarations”</td><td>弃用的警告⚠️</td></tr><tr><td>“-Wincompatible-pointer-types”</td><td>不兼容指针类型⚠️</td></tr><tr><td>“-Warc-retain-cycles”</td><td>循环引用⚠️</td></tr><tr><td>“-Wunused-variable”</td><td>未使用变量 ⚠️</td></tr><tr><td>“-Wcovered-switch-default”</td><td>未使用default ⚠️</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h6 id="Code-UIBarButtonItem-YYAdd"><a href="#Code-UIBarButtonItem-YYAdd" class="headerlink" title="Code (UIBarButtonItem+YYAdd)"></a>Code (UIBarButtonItem+YYAdd)</h6><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">_YYUIBarButtonItemBlockTarget</span> : <span class="hljs-title">NSObject</span></span><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^block)(<span class="hljs-keyword">id</span> sender);- (<span class="hljs-keyword">id</span>)initWithBlock:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-keyword">id</span> sender))block;- (<span class="hljs-keyword">void</span>)invoke:(<span class="hljs-keyword">id</span>)sender;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">_YYUIBarButtonItemBlockTarget</span></span>- (<span class="hljs-keyword">id</span>)initWithBlock:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-keyword">id</span> sender))block&#123;    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;        _block = [block <span class="hljs-keyword">copy</span>];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;&#125;- (<span class="hljs-keyword">void</span>)invoke:(<span class="hljs-keyword">id</span>)sender &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.block) <span class="hljs-keyword">self</span>.block(sender);&#125;<span class="hljs-keyword">@end</span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIBarButtonItem</span> (<span class="hljs-title">YYAdd</span>)</span>- (<span class="hljs-keyword">void</span>)setActionBlock:(<span class="hljs-keyword">void</span> (^)(<span class="hljs-keyword">id</span> sender))block &#123;    _YYUIBarButtonItemBlockTarget *target = [[_YYUIBarButtonItemBlockTarget alloc] initWithBlock:block];    objc_setAssociatedObject(<span class="hljs-keyword">self</span>, &amp;block_key, target, OBJC_ASSOCIATION_RETAIN_NONATOMIC);        [<span class="hljs-keyword">self</span> setTarget:target];    [<span class="hljs-keyword">self</span> setAction:<span class="hljs-keyword">@selector</span>(invoke:)];&#125;- (<span class="hljs-keyword">void</span> (^)(<span class="hljs-keyword">id</span>)) actionBlock &#123;    _YYUIBarButtonItemBlockTarget *target = objc_getAssociatedObject(<span class="hljs-keyword">self</span>, &amp;block_key);    <span class="hljs-keyword">return</span> target.block;&#125;</code></pre><h6 id="功能-16"><a href="#功能-16" class="headerlink" title="功能"></a>功能</h6><p>通过创建一个中间对象,让UIBarButtonItem的Target指向该对象,同时让self 调用该对象的方法.来达到点击事件调用block而无需再设置selector的目的.</p><p>通过这种方式,<code>YYCategories</code>将多种类似点击控件,调用selector的方式,修改为block.</p><blockquote><p><strong>注意</strong> 使用block给控件添加点击事件后,就不能再给该控件添加selector,否则会引起冲突.</p></blockquote><h6 id="Code-UIColor-YYAdd"><a href="#Code-UIColor-YYAdd" class="headerlink" title="Code  (UIColor+YYAdd)"></a>Code  (UIColor+YYAdd)</h6><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> UIColorHex</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UIColorHex(_hex_)   [UIColor colorWithHexString:((__bridge NSString *)CFSTR(#_hex_))]</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><h6 id="功能-17"><a href="#功能-17" class="headerlink" title="功能"></a>功能</h6><p>16进制颜色转换<br>Example: UIColorHex(0xF0F), UIColorHex(66ccff), UIColorHex(#66CCFF88)<br>支持的格式是如此之多, #RGB #RGBA #RRGGBB #RRGGBBAA 0xRGB …</p><h6 id="Code-UIImage-YYAdd"><a href="#Code-UIImage-YYAdd" class="headerlink" title="Code  (UIImage+YYAdd)"></a>Code  (UIImage+YYAdd)</h6><pre><code class="hljs objectivec"><span class="hljs-comment">/**</span><span class="hljs-comment"> Returns a new rotated image (relative to the center).</span><span class="hljs-comment"> </span><span class="hljs-comment"> @param radians   Rotated radians in counterclockwise.⟲</span><span class="hljs-comment"> </span><span class="hljs-comment"> @param fitSize   YES: new image&#x27;s size is extend to fit all content.</span><span class="hljs-comment">                  NO: image&#x27;s size will not change, content may be clipped.</span><span class="hljs-comment"> */</span>- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">UIImage</span> *)imageByRotate:(<span class="hljs-built_in">CGFloat</span>)radians fitSize:(<span class="hljs-built_in">BOOL</span>)fitSize;</code></pre><h6 id="功能-18"><a href="#功能-18" class="headerlink" title="功能"></a>功能</h6><p>图片翻转,超级实用<br>…</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>YYCategories</code>中对<code>UIKit</code>, <code>Foundation</code>, <code>Quartz</code>中的常用类添加分类,里面还有好多实用的API来供我们项目开发使用,想要进一步了解并使用其中的API,可以参阅<code>YYCategories</code>中的头文件.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/ibireme/YYCategories">YYCategories</a><br><a href="http://clang.llvm.org/docs/UsersManual.html#diagnostics_pragmas">clang.llvm.org</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>YYCategories</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScriptCore</title>
    <link href="/blog/2018/02/06/iOS/JavaScriptCore/"/>
    <url>/blog/2018/02/06/iOS/JavaScriptCore/</url>
    
    <content type="html"><![CDATA[<p>运行应用程序中的JavaScript程序，并支持在应用程序编写JavaScript。</p><h2 id="通览"><a href="#通览" class="headerlink" title="通览"></a>通览</h2><p>JavaScriptCore框架能够在Swift, Objective-C和C等环境中运行JS脚本.也可以使用JavaScriptCore框架插入自定义的对象到JS脚本中.</p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><h4 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h4><h6 id="Class-JSContext"><a href="#Class-JSContext" class="headerlink" title="Class JSContext"></a>Class JSContext</h6><p>一个JSContext对象表示一个JavaScript执行环境.你创建和使用JavaScript contexts去运行来自OC或者Swift代码编写的JavaScript脚本.来访问JavaScript中定义的或计算的值，并使JavaScript能够访问本地对象、方法或函数。</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建一个JavaScript context<span class="hljs-regexp">//</span>Discussion<span class="hljs-regexp">//</span>初始化创建context时,会伴随一个新的,独立的virtual machine(一个JSVirtual Machine 对象).您无法在包含在不同virtual machines中的context之间传递JavaScript values(JSValue 对象).创建共享一个virtual machine的context,使用下面的初始化方法init!()<span class="hljs-regexp">//</span>创建一个JavaScript context, 与一个具体的virtual machine关联.<span class="hljs-regexp">//</span>Discussion<span class="hljs-regexp">//</span>默认情况下,每个context拥有一个独立的virtual machine(一个 JSVirtualMachine对象).您无法在不同的virtual machine中的context传递JavaScript value.使用该方法创建的context,可以和其他的contexts共享它的virtual machine,从而允许在不同的context中传递JSValue对象.init!(virturalMachine: JSVirturalmachine!)/**    执行具体的JavaScript代码    参数:   需要评估的JavaScript 源码    返回值: 脚本最后生成的值. 注意,脚本可以导致未定义的JavaScript值 */ <span class="hljs-regexp">//</span>Discussion <span class="hljs-regexp">//</span>一个脚本运行任何级高级别代码并且给context的全局对象对象添加方法和对象定义.<span class="hljs-keyword">func</span> evaluateScript(String!)<span class="hljs-regexp">//</span>执行性具体的JavaScript代码,指定的URL用来对它定位.(调试的时候可以使用)<span class="hljs-keyword">func</span> evaluateScript(String!, withSourceURL: URL!)<span class="hljs-regexp">//</span>在一个运行的context中检查回调状态<span class="hljs-regexp">//</span>返回当前执行JS的contextclass <span class="hljs-keyword">func</span> current()<span class="hljs-regexp">//</span>返回当前执行的JS方法class <span class="hljs-keyword">func</span> currentCallee()<span class="hljs-regexp">//</span>返回当前执行JS代码中这个关键字的值class <span class="hljs-keyword">func</span> currentThis()<span class="hljs-regexp">//</span>返会从JS代码到当前本地回调的参数class <span class="hljs-keyword">func</span> currentArguments()<span class="hljs-regexp">//</span>与Context关联的JS全局对象var globalObject: JSValue!<span class="hljs-regexp">//</span>脚本执行中被抛出的异常var exception: JSValue!<span class="hljs-regexp">//</span>一个block用来处理JS脚本执行中抛出的异常var exceptionHandler: ((JSContext?, JSValue?) -&gt; Void)!<span class="hljs-regexp">//</span>当前context所在的JavaScript virtual machine var virtualMachine: JSVirtualMachine!<span class="hljs-regexp">//</span>context 的描述var name: String!<span class="hljs-regexp">//</span>允许通过下标语法,返回在context的全局对象中的具体JS属性值<span class="hljs-keyword">func</span> objectForKeyedSubscript(Any!)<span class="hljs-regexp">//</span>允许通过下标语法,给context的全局对象设定指定JS属性<span class="hljs-keyword">func</span> setObject(Any!, forKeyedSubscript: (NSCoping &amp; NSobject Protocol)!)<span class="hljs-regexp">//</span>举个例子JSContext *context = [[JSContext alloc] init];context[@<span class="hljs-string">&quot;makeNSColor&quot;</span>] = ^(NSDictionary *rgb)&#123;    float r = rgb[@<span class="hljs-string">&quot;red&quot;</span>].floatValue;    float g = rgb[@<span class="hljs-string">&quot;green&quot;</span>].floatValue;    float b = rgb[@<span class="hljs-string">&quot;blue&quot;</span>].floatValue;    return [NSColor colorWithRed:(r <span class="hljs-regexp">/ 255.f) green:(g /</span> <span class="hljs-number">255</span>.f) blue:(b / <span class="hljs-number">255</span>.f) alpha:<span class="hljs-number">1.0</span>];&#125;;</code></pre><h6 id="Class-JSManageValue"><a href="#Class-JSManageValue" class="headerlink" title="Class JSManageValue"></a>Class JSManageValue</h6><p>一个JSManagedValue对象包装了一个JSValue对象.添加”条件引用”行为,以实现对值的自动内存管理.对于一个管理值,主要用例是在一个OC或者Swift对象中存储一个JavaScript值,该OC或者Swift对象本身被导出到JavaScript.</p><h6 id="Class-JSValue"><a href="#Class-JSValue" class="headerlink" title="Class JSValue"></a>Class JSValue</h6><p>一个JSValue实例是对一个JavaScript 值的参照.您可以使用JSValue类转换JavaScript和objective - c 或者 Swift 之间的基本值(例如数字和字符串)，以便在本地代码和JavaScript代码之间传递数据。您还可以使用这个类创建JavaScript对象，这些对象包装自定义类的本地对象或JavaScript函数，这些函数的实现由本地方法或Block提供。</p><pre><code class="hljs swift"><span class="hljs-comment">// JS类型与本地类型转换</span><span class="hljs-type">OC</span>(<span class="hljs-type">Swift</span>) <span class="hljs-type">Types</span>           <span class="hljs-type">JS</span> <span class="hljs-type">Types</span>           <span class="hljs-type">Notes</span>-----------------------------------------------------<span class="hljs-literal">nil</span>                       undefined -----------------------------------------------------<span class="hljs-type">NSNull</span>                    null-----------------------------------------------------<span class="hljs-type">NSString</span> (<span class="hljs-type">String</span> )        <span class="hljs-type">String</span> -----------------------------------------------------<span class="hljs-type">NSNumber</span>                  <span class="hljs-type">Number</span>,<span class="hljs-type">Boolean</span>-----------------------------------------------------<span class="hljs-type">NSDictionary</span>(<span class="hljs-type">Dictionary</span>)  <span class="hljs-type">Object</span>-----------------------------------------------------<span class="hljs-type">NSArray</span> (<span class="hljs-type">Array</span>)           <span class="hljs-type">Array</span>----------------------------------------------------<span class="hljs-type">NSDate</span>                    <span class="hljs-type">Date</span>-----------------------------------------------------<span class="hljs-type">Object</span> (<span class="hljs-type">AnyObject</span>)        <span class="hljs-type">Object</span> <span class="hljs-type">Classs</span> (<span class="hljs-type">AnyClass</span>)-----------------------------------------------------<span class="hljs-type">NSRange</span>,<span class="hljs-type">CGRect</span>,           <span class="hljs-type">Object</span>          其他结构体类型不支持<span class="hljs-type">CGPoint</span>,<span class="hljs-type">CGSize</span>-----------------------------------------------------<span class="hljs-type">Block</span>(<span class="hljs-type">Closure</span>)            <span class="hljs-type">Function</span>        <span class="hljs-type">JS</span>函数不转换本地block/闭包除非通过一个本地blcok/closure 返回-----------------------------------------------------<span class="hljs-comment">//创建一个JS 值来转换指定的本地对象</span><span class="hljs-keyword">init</span>!(object: <span class="hljs-type">Any!</span>, <span class="hljs-keyword">in</span>: <span class="hljs-type">JSContext!</span>)<span class="hljs-comment">//创建一个JS 值来表示指定的布尔值</span><span class="hljs-keyword">init</span>!(bool: <span class="hljs-type">Bool</span>, <span class="hljs-keyword">in</span>: <span class="hljs-type">JSContext!</span>)<span class="hljs-comment">//创建一个JS 值来表示指定的Double类型值</span><span class="hljs-keyword">init</span>!(double: <span class="hljs-type">Double</span>, <span class="hljs-keyword">in</span>: <span class="hljs-type">JSContext!</span>)<span class="hljs-comment">//创建一个空的JS对象</span><span class="hljs-keyword">init</span>!(newObjectIn: <span class="hljs-type">JSContext!</span>)<span class="hljs-comment">//创建一个空的JS数组</span><span class="hljs-keyword">init</span>!(newArrayIn: <span class="hljs-type">JSContext!</span>)<span class="hljs-comment">//创建一个JSError</span><span class="hljs-keyword">init</span>!(neewErrorFromMessage: <span class="hljs-type">String!</span>, <span class="hljs-keyword">in</span>: <span class="hljs-type">JSContext!</span>)...<span class="hljs-comment">//读取并转换JS值为本地类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toObject</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toObjectOf</span><span class="hljs-params">(AnyClass!)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toBool</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toDouble</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toDate</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toArray</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toDictionary</span><span class="hljs-params">()</span></span><span class="hljs-comment">//类型判断</span><span class="hljs-keyword">var</span> isUndefined: <span class="hljs-type">Bool</span><span class="hljs-keyword">var</span> isNull     : <span class="hljs-type">Bool</span><span class="hljs-keyword">var</span> isBoolean  : <span class="hljs-type">Bool</span><span class="hljs-keyword">var</span> isNumber   : <span class="hljs-type">Bool</span>...<span class="hljs-comment">//JS值比较</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(to: <span class="hljs-keyword">Any</span>!)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isEqualWithTypeCoercion</span><span class="hljs-params">(to: <span class="hljs-keyword">Any</span>!)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isInstance</span><span class="hljs-params">(of: <span class="hljs-keyword">Any</span>!)</span></span><span class="hljs-comment">//方法调用</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invokeMethod</span><span class="hljs-params">(String!, withArguments: [<span class="hljs-keyword">Any</span>]!)</span></span><span class="hljs-comment">//容器值</span><span class="hljs-comment">//定义一个JS对象的属性或者修改属性的定义</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defineProperty</span><span class="hljs-params">(String!, descriptor: <span class="hljs-keyword">Any</span>!)</span></span><span class="hljs-comment">//删除JS对象的属性</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteProperty</span><span class="hljs-params">(String!)</span></span><span class="hljs-comment">//根据下标赋值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>!, at: Int)</span></span><span class="hljs-comment">//根据下标取值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">atIndex</span><span class="hljs-params">(Int)</span></span><span class="hljs-comment">//给指定属性赋值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>!, forProperty: String!)</span></span><span class="hljs-comment">//根据指定属性取值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forProperty</span><span class="hljs-params">(String!)</span></span><span class="hljs-comment">//获取持有这个值的context</span><span class="hljs-keyword">var</span> context: <span class="hljs-type">JSContext!</span><span class="hljs-comment">//通过下标语法获取值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objectAtIndexedSubscript</span><span class="hljs-params">(Int)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setObject</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>!, atIndexedSubscript: Int)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objectForkeyedSubscript</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>!)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setObject</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>!, forKeyedSubscritp: <span class="hljs-params">(NSCoping &amp; NSObjectProtocol)</span></span></span>!)</code></pre><h6 id="Class-JSVirtualMachine"><a href="#Class-JSVirtualMachine" class="headerlink" title="Class JSVirtualMachine"></a>Class JSVirtualMachine</h6><p>一个JSVirtualMachine 实例表示JavaScript执行中的一个独立环境.您可以使用该类用于两个主要目的:去支撑并发的JavaScript执行,管理JavaScript与OC,Swift之间桥接过来的对象内存.</p><h6 id="Protocol-JSExport"><a href="#Protocol-JSExport" class="headerlink" title="Protocol JSExport"></a>Protocol JSExport</h6><p>实现该协议用来导出OC类和他们的实例方法,类方法,属性到JavaScript代码中.</p><p>Listing 1  Exporting an Objective-C Class to JavaScript</p><pre><code class="hljs groovy"><span class="hljs-meta">@protocol</span> MyPointExports &lt;JSExport&gt;<span class="hljs-meta">@property</span> <span class="hljs-keyword">double</span> x;<span class="hljs-meta">@property</span> <span class="hljs-keyword">double</span> y;- (NSString *)description;- (instancetype)<span class="hljs-attr">initWithX:</span>(<span class="hljs-keyword">double</span>)x <span class="hljs-attr">y:</span>(<span class="hljs-keyword">double</span>)y;+ (MyPoint *)<span class="hljs-attr">makePointWithX:</span>(<span class="hljs-keyword">double</span>)x <span class="hljs-attr">y:</span>(<span class="hljs-keyword">double</span>)y;<span class="hljs-meta">@end</span> <span class="hljs-meta">@interface</span> <span class="hljs-attr">MyPoint :</span> NSObject &lt;MyPointExports&gt;- (<span class="hljs-keyword">void</span>)myPrivateMethod;  <span class="hljs-comment">// Not in the MyPointExports protocol, so not visible to JavaScript code.</span><span class="hljs-meta">@end</span> <span class="hljs-meta">@implementation</span> MyPoint<span class="hljs-comment">// ...</span><span class="hljs-meta">@end</span></code></pre><p>Listing 2 Useing an Exported Objectiv-C Class from JavaScript</p><pre><code class="hljs smali">// Objective-C properties become fields.point.x;point.x = 10;// Objective-C<span class="hljs-built_in"> instance </span>methods become functions.point.description();// Objective-C initializers can be called with<span class="hljs-keyword"> constructor</span> syntax.var p = MyPoint(1, 2);// Objective-C class methods become functions on the<span class="hljs-keyword"> constructor</span> object.var q = MyPoint.makePointWithXY(0, 0);</code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/documentation/javascriptcore?language=occ">JavaScriptCore</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScriptCore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runtime编程指南</title>
    <link href="/blog/2018/01/16/iOS/Runtime-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <url>/blog/2018/01/16/iOS/Runtime-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Objective-C语言从编译、链接、到运行都有很多决策。只要有可能，它都是动态的。这意味着该语言不仅需要编译器，还需要运行时系统来执行编译后的代码。运行时系统作为Objective-C语言的一种操作系统;这就是语言的作用。<br>本文档关注NSObject类，以及Objective-C程序如何与运行时系统交互。特别是，它检查了在运行时动态加载新类的范例，并将消息转发给其他对象。它还提供关于在程序运行时如何查找对象信息的相关内容。<br>您应该阅读本文档以了解Objective-C运行时系统如何工作以及如何利用它。但是，通常情况下，您不需要知道和理解这些材料来编写Cocoa应用程序。</p><h2 id="Runtime-版本和平台（省略）"><a href="#Runtime-版本和平台（省略）" class="headerlink" title="Runtime 版本和平台（省略）"></a>Runtime 版本和平台（省略）</h2><h2 id="Runtime交互"><a href="#Runtime交互" class="headerlink" title="Runtime交互"></a>Runtime交互</h2><p>OC在三个不同层面跟runtime系统交互: 通过OC源代码;通过Foundation框架下NSObject定义的方法;通过直接调用runtime函数.</p><h3 id="Objective-C-源码"><a href="#Objective-C-源码" class="headerlink" title="Objective-C 源码"></a>Objective-C 源码</h3><p>在大多数情况下，运行时系统会自动地在幕后工作。您只需编写和编译Objective-C源代码就可以使用它。</p><p>当编译包含Objective-C类和方法的代码时，编译器会创建实现语言动态特性的数据结构和函数调用。数据结构捕获在类和类别定义,协议声明中发现的信息;它们包括在Objective-C编程语言中定义的类对象和协议对象，以及方法选择器、实例变量的模板和从源代码中提取的其他信息。runtime最重要的函数是发送消息的函数，如<em>消息传递</em>中所描述的那样。它是由源代码消息表达式调用的。</p><h3 id="NSObject-方法"><a href="#NSObject-方法" class="headerlink" title="NSObject 方法"></a>NSObject 方法</h3><p>Cocoa中的大多数对象都是NSObject类的子类，所以大多数对象继承了它定义的方法。(值得注意的例外是NSProxy类;参见<em>消息转发</em>以获取更多信息。因此，它的方法建立了每个实例和每个类对象固有的行为。然而，在少数情况下，NSObject类仅仅定义了应该如何做的模板;它没有提供所有必要的代码。</p><p>例如，NSObject类定义了一个描述实例方法，该方法返回描述类内容的字符串。这主要用于调试——GDB打印对象命令打印从该方法返回的字符串。NSObject的这个方法的实现不知道类包含什么，所以它返回一个带有对象名称和地址的字符串。NSObject的子类可以实现这个方法来返回更多的细节。例如，Foundation类NSArray返回它所包含的对象的描述列表。</p><p>一些NSObject方法简单地查询运行时系统的信息。这些方法允许对象执行内部自检。此类方法的示例是类方法，该类要求对象标识其类;<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>测试对象在继承层次结构中的位置;<code>respondsToSelector:</code>表示一个对象是否可以接受特定的消息;<code>conformsToProtocol:</code>表示一个对象是否实现了特定协议中定义的方法;和<code>methodForSelector:</code>，它提供了方法实现的地址。像这样的方法给了一个对象自检的能力。</p><h3 id="Runtime-函数"><a href="#Runtime-函数" class="headerlink" title="Runtime 函数"></a>Runtime 函数</h3><p>运行时系统是一个动态共享库，其公共接口由位于目录/usr/include/objc中的头文件中的一组函数和数据结构组成。许多这些函数允许您使用plain C来复制编译器在编写Objective-C代码时所做的工作。其他则是通过NSObject类方法导出的功能的基础。这些功能使开发运行时系统的其他接口成为可能，并生成增强开发环境的工具;在Objective-C中编程时不需要它们。然而，在编写Objective-C程序时，一些运行时函数可能会非常有用。所有这些功能都记录在Objective-C运行时引用中。</p><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>本章描述如何将消息表达式转换为<code>objc_msgSend</code>函数调用，以及如何通过名称引用方法。然后它解释了如何利用<code>objc_msgSend</code>，如果需要的话，可以绕过动态绑定。</p><h3 id="objc-msgSend-函数"><a href="#objc-msgSend-函数" class="headerlink" title="objc_msgSend 函数"></a>objc_msgSend 函数</h3><p>在Objective-C中，消息直到运行时才绑定到方法实现。编译器将消息表达式转换为对消息传递函数<code>objc_msgSend</code>的调用。该函数接受消息的接收者和消息中提到的方法的名称，即方法selector—作为它的两个主要参数:</p><pre><code class="hljs reasonml">objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">receiver</span>, <span class="hljs-params">selector</span>)</span></code></pre><p>消息中传送过来的任何参数也通过<code>objc_msgSend</code>来处理:</p><pre><code class="hljs reasonml">objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">receiver</span>, <span class="hljs-params">selector</span>, <span class="hljs-params">arg1</span>, <span class="hljs-params">arg2</span>, <span class="hljs-operator">...</span>)</span></code></pre><p>消息传递函数为实现动态绑定所做的必要事情:</p><ul><li>它首先查找选择器引用的过程(方法实现)。由于相同的方法可以通过不同的类实现不同的实现，因此它所发现的精确过程取决于接收者的类。</li><li>然后在调用程序中，将接收对象(指向它的数据的指针)传递，以及为该方法指定的任何参数。</li><li>最后，它将程序的返回值作为其本身的返回值传递。</li></ul><blockquote><p>注意: 编译器通常调用消息传递函数.不要在你写的代码中直接调用它.</p></blockquote><p>消息传递的关键在于编译器为每个类和对象构建的结构。每个类结构包括这两个基本要素:</p><ul><li>指向父类的指针。</li><li>一个类分派表。这个表有关联方法选择器和它们识别的方法的类特定地址的条目。<code>setOrigin</code>方法的选择器与其实现地址相关联;<code>display</code>方法的选择器与其实现地址相关联，等等。</li></ul><p>创建新对象时，将分配内存，并初始化其实例变量。对象的首个变量是指向其类结构的指针。这个指针称为isa，它使对象可以访问它的类，并通过该类对它继承的所有类进行访问。</p><blockquote><p>虽然这不是语言的一部分，但是需要isa指针来处理Objective-C运行时系统。在结构定义的任何字段中，对象需要“等效”到struct objc_object(在objc/objc.h中定义)。然而，您很少需要创建自己的根对象，而从NSObject或NSProxy继承的对象会自动拥有isa变量。</p></blockquote><p>这些类元素和对象结构在 <em>Figure 3- 1</em> 中阐述.</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-dc0283a1fceff976.gif?imageMogr2/auto-orient/strip" alt="Figure 3-1 消息传递结构"></p><p>当消息被发送到一个对象时，消息传递函数会跟随对象的isa指针到类结构，它在分派表中查找方法选择器。如果它在那里找不到选择器，<code>objc_msgSend</code>会跟随指向父类的指针，并试图在它的分派表中找到选择器。连续的失败导致<code>objc_msgSend</code>爬升类层次结构，直到它到达NSObject类。一旦它定位了选择器，函数调用表中的该方法并将接收对象的数据结构传递给它。</p><p>这是在运行时选择方法实现的方式——或者，用面向对象编程的行话来说，方法是动态绑定到消息的。</p><p>为了加快消息传递进程，运行时系统将缓存选择器和方法的地址。每个类都有一个单独的缓存，它可以包含用于继承方法的选择器以及类中定义的方法。在搜索调度表之前，消息传递例程首先检查接收对象的类的缓存(关于可能再次使用的方法可能会再次使用的理论)。如果方法选择器在缓存中，消息传递只比函数调用稍微慢一点。一旦程序运行足够长的时间来“预热”它的缓存，它发送的几乎所有消息都会找到一个缓存的方法。当程序运行时，缓存会动态地增长以容纳新的消息。</p><h3 id="使用隐藏的参数"><a href="#使用隐藏的参数" class="headerlink" title="使用隐藏的参数"></a>使用隐藏的参数</h3><p>当<code>objc_msgSend</code>找到实现方法的过程时，它调用该过程并将消息中的所有参数传递给它。同时传递隐藏的两个参数:</p><ul><li>接收对象</li><li>方法的选择器。<br>这些参数提供了关于调用它的消息表达式的另一半显式信息。它们被认为是“隐藏的”，因为它们没有在定义方法的源代码中声明。当代码被编译时，它们被插入到实现中。</li></ul><p>虽然这些参数没有显式地声明，但是源代码仍然可以引用它们(就像它可以引用接收对象的实例变量一样)。方法将接收对象作为self，并将它的方法选择器作为_cmd。在下面的示例中，_cmd 引用方法选择器作为strange的方法,引用self做为strange消息的接收对象。</p><pre><code class="hljs monkey">- strange&#123;    id  target = getTheReceiver();    SEL <span class="hljs-function"><span class="hljs-keyword">method</span> =</span> getTheMethod();     <span class="hljs-keyword">if</span> ( target == <span class="hljs-built_in">self</span> || <span class="hljs-function"><span class="hljs-keyword">method</span> =</span>= _cmd )        <span class="hljs-keyword">return</span> nil;    <span class="hljs-keyword">return</span> [target performSelector:<span class="hljs-function"><span class="hljs-keyword">method</span>];</span>&#125;</code></pre><p>self是两个参数中比较有用的一个。实际上，接收对象的实例变量的方式可以用于方法定义。</p><h3 id="获取一个方法的地址"><a href="#获取一个方法的地址" class="headerlink" title="获取一个方法的地址"></a>获取一个方法的地址</h3><p>规避动态绑定的唯一方法是获取方法的地址，并直接调用它，就像它是一个函数一样。这可能适用于极少数情况下，特定的方法将连续多次执行，并且您希望在每次执行方法时避免消息传递的开销。</p><p>使用NSObject类中定义的方法，methodForSelector:，您可以要求一个指向方法实现的指针，然后使用指针来调用该过程。methodForSelector:返回的指针必须小心地转换为合适的函数类型。返回类型和参数类型都应该包含在转换中。</p><p>下面的示例展示了实现<code>setFilled</code>方法可能调用的流程:</p><pre><code class="hljs objectivec"><span class="hljs-keyword">void</span> (*<span class="hljs-keyword">setter</span>)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-built_in">BOOL</span>);<span class="hljs-keyword">int</span> i; <span class="hljs-keyword">setter</span> = (<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-built_in">BOOL</span>))[target    methodForSelector:<span class="hljs-keyword">@selector</span>(setFilled:)];<span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ; i++ )    <span class="hljs-keyword">setter</span>(targetList[i], <span class="hljs-keyword">@selector</span>(setFilled:), <span class="hljs-literal">YES</span>);</code></pre><p>传递给流程的前两个参数是接收对象(self)和方法选择器(_cmd)。这些参数隐藏在方法语法中，但是当方法被调用为函数时，必须显式地进行说明。</p><p>使用methodForSelector:规避动态绑定可以节省消息传递所需的大部分时间。但是，只有在一个特定的消息重复多次的情况下，才会有显著的节省，如上面所示的for循环。</p><p>注意，methodForSelector:由Cocoa运行时系统提供;这不是Objective-C语言本身的特性。</p><h2 id="动态方法解决方案"><a href="#动态方法解决方案" class="headerlink" title="动态方法解决方案"></a>动态方法解决方案</h2><p>本章描述如何动态地提供方法的实现。</p><h3 id="动态方法解决方案-1"><a href="#动态方法解决方案-1" class="headerlink" title="动态方法解决方案"></a>动态方法解决方案</h3><p>有些情况下，您可能希望动态地提供方法的实现。例如，Objective-C声明的属性特性(参见Objective-C编程语言中的声明属性)包括@dynamic指令:</p><pre><code class="hljs css"><span class="hljs-keyword">@dynamic</span> propertyName;</code></pre><p>它告诉编译器将动态地提供与属性关联的方法。</p><p>您可以实现方法resolveInstanceMethod:和resolveClassMethod:为实例和类方法动态地提供给定选择器的实现。</p><p>Objective-C方法仅仅是一个C函数，它至少需要两个参数-self和_cmd。您可以使用函数<code>class_addMethod</code>将函数添加到类中。因此，给定以下函数:</p><pre><code class="hljs reasonml">void dynamic<span class="hljs-constructor">MethodIMP(<span class="hljs-params">id</span> <span class="hljs-params">self</span>, SEL <span class="hljs-params">_cmd</span>)</span> &#123;    <span class="hljs-comment">// implementation ....</span>&#125;</code></pre><p>可以动态地将其添加到一个类作为一个方法(称为resolveThisMethodDynamically)使用resolveInstanceMethod:是这样的:</p><pre><code class="hljs less"><span class="hljs-variable">@implementation</span> MyClass+ (BOOL)<span class="hljs-attribute">resolveInstanceMethod</span>:(SEL)aSEL&#123;    <span class="hljs-selector-tag">if</span> (aSEL == <span class="hljs-variable">@selector</span>(resolveThisMethodDynamically)) &#123;          <span class="hljs-selector-tag">class_addMethod</span>([self class], aSEL, (IMP) dynamicMethodIMP, <span class="hljs-string">&quot;v@:&quot;</span>);          <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">YES</span>;    &#125;    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-attr">[super resolveInstanceMethod:aSEL]</span>;&#125;@<span class="hljs-selector-tag">end</span></code></pre><p>转发方法(如消息转发中所描述的)和动态方法解析在很大程度上是正交的。类有机会在转发机制启动之前动态解析方法。如果调用<code>respondsToSelector</code>或<code>instancesRespondToSelector:</code>方法,动态方法解析器就有机会给选择器提供一个IMP。如果您实现了<code>resolveInstanceMethod:</code>但是希望特定的选择器通过转发机制来转发，给这些方法选择器返回NO.</p><h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>Objective-C程序可以在运行时加载和链接新的类和类别。新代码合并到程序中，并在开始时对加载的类和类别进行相同的处理。</p><p>动态加载可以用来做很多不同的事情。例如，系统首选项应用程序中的各个模块是动态加载的。</p><p>在Cocoa环境中，动态加载通常用于允许定制应用程序。其他人可以编写程序在运行时加载的模块——就像接口构建器加载自定义面板和OS X系统首选项应用程序加载自定义的偏好模块一样。可加载模块扩展了应用程序的功能。他们以你允许的方式对它做出贡献，但却无法预见或定义你自己。您提供了框架，但其他人提供了代码。</p><p>虽然有一个运行时函数，在Mach-O文件中执行Objective-C模块的动态加载(objc /objc-load.h中定义的objc_loadmodule)，但Cocoa的NSBundle类为动态加载提供了一个更方便的接口，这是面向对象的，并与相关的服务集成在一起。在Foundation框架参考中查看NSBundle类规范，了解关于NSBundle类及其使用的信息。请参阅OS X ABI Mach-O文件格式参考，以获取关于Mach-O文件的信息。</p><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>向不处理该消息的对象发送消息是错误的。然而，在宣布错误之前，运行时系统会再给接收对象一个机会来处理该消息。</p><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>如果您向一个不处理该消息的对象发送消息，在宣布一个错误之前，运行时将向对象发送对象一个<code>forwardInvocation:</code>消息,并携带一个<code>NSInvocation</code>对象参数——NSInvocation对象封装了原始消息和传递给它的参数。</p><p>您可以实现一个<code>forwardInvocation:</code>方法来提供对消息的默认响应，或者以其他方式避免错误。正如其名称所暗示的,<code>forwardInvocation</code>通常用于将消息转发到另一个对象。</p><p>为了查看转发的范围和意图，请想象以下场景:假设您正在设计一个对象，该对象可以响应一个名为<code>negotiate</code>的消息，您希望它的响应包含另一类型对象的响应。通过在您实现<code>negotiate</code>方法的主体中传递一个<code>negotiate</code>消息到其他对象，您可以轻松完成这一任务。</p><p>更进一步，假设您希望您的对象对<code>negotiate</code>消息的响应完全在另一个类中实现。实现这一点的一种方法是让您的类继承其他类的方法。然而，这样安排是不可能的。也许有很好的理由来说明为什么不可能.</p><p>即使您的类不能继承<code>negotiate</code>方法，您仍然可以通过将消息传递给其他类的实例方法来“借用”它:</p><pre><code class="hljs less"><span class="hljs-selector-tag">-</span> (id)<span class="hljs-selector-tag">negotiate</span>&#123;    <span class="hljs-selector-tag">if</span> ( [someOtherObject <span class="hljs-attribute">respondsTo</span>:<span class="hljs-variable">@selector</span>(negotiate)] )        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-attr">[someOtherObject negotiate]</span>;    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">self</span>;&#125;</code></pre><p>这样做可能会有点麻烦，特别是如果有许多消息需要您的对象传递给其他对象时。您必须实现一种方法来覆盖您想要从其他类中借用的每个方法。此外，在您编写代码时，您不知道您可能想要转发的完整的消息集是不可能处理的。该集合可能依赖于运行时的事件，并且随着新的方法和类在将来实现，它可能会发生变化。</p><p><code>forwardInvocation:</code>提供的第二次机会为这个问题提供了一个的临时解决方案，它是动态的，而不是静态的。它的工作原理是这样的:当一个对象不能响应消息时，因为它没有找到与消息中的选择器匹配的方法，运行时系统通过发送一个<code>forwardInvocation:</code>消息来通知对象。每个对象都继承了来自NSObject类的<code>forwardInvocation:</code>方法。然而,NSObject版本的方法只是简单地调用<code>doesNotRecognizeSelector:</code>。通过重写NSObject的版本并实现您自己的版本，您可以利用<code>forwardInvocation:</code>消息将消息转发给其他对象。</p><p>要转发一条消息，所有<code>forwardInvocation:</code>方法需要做的是:</p><ul><li>确定消息应该发送到哪里，以及。</li><li>将原始参数发送到那里.</li></ul><p>可以用<code>invokeWithTarget:</code>方法发送消息:</p><pre><code class="hljs groovy">- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">forwardInvocation:</span>(NSInvocation *)anInvocation&#123;    <span class="hljs-keyword">if</span> ([someOtherObject <span class="hljs-attr">respondsToSelector:</span>            [anInvocation selector]])        [anInvocation <span class="hljs-attr">invokeWithTarget:</span>someOtherObject];    <span class="hljs-keyword">else</span>        [<span class="hljs-built_in">super</span> <span class="hljs-attr">forwardInvocation:</span>anInvocation];&#125;</code></pre><p>转发消息的返回值将返回给原始发送方。所有类型的返回值都可以传递给发送方，包括id、结构和双精度浮点数。</p><p><code>forwardInvocation:</code>方法可以作为 <strong>未识别</strong> 消息的分发中心，将它们分配给不同的接收者。或者它可以是一个传输站，将所有的消息发送到同一个目的地。它可以将一个消息转换成另一个消息，或者简单地“吞下”一些消息，因此没有响应，没有错误。<code>forwardInvocation</code>方法还可以将多个消息合并为一个响应。<code>forwardInvocation</code> 是由实现者决定的。它为对象链到转发链提供了一个机会，这也为相关程序设计提供了可能。</p><blockquote><p><strong>注意:</strong> <code>forwardInvocation:</code>只有在名义接收方不调用现有方法的情况下，该方法才可以处理消息。例如，如果您希望您的对象转发<code>negotiate</code>消息给另一个对象，那么它就不能拥有自己的<code>negotiate</code>方法。如果是这样，消息将永远不会到达<code>forwardInvocation:</code>。</p></blockquote><p>有关转发和调用的更多信息，请参阅基础框架引用中的NSInvocation类规范。</p><h3 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h3><p>转发模仿继承，并可用于向Objective-C程序提供多继承的一些影响。如图5-1所示，通过转发来响应消息的对象似乎可以借用或“继承”在另一个类中定义的方法实现。<br><img src="http://upload-images.jianshu.io/upload_images/3340896-e628ceb1736d6121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5-1"></p><p>在这个例子中，一个战士类的实例将一个协商消息转发给一个外交官类的实例。战士会像外交官一样谈判。它似乎会对谈判的信息作出回应，而且对于所有实际的目的而言，它确实会做出回应(尽管它确实是一名从事这项工作的外交官)。</p><p>因此，转发消息的对象从继承层次结构的两个分支中“继承”方法——它自己的分支和响应消息的对象的分支。在上面的例子中，似乎战士层级继承了外交官和它自己的父类。</p><p>转发提供了您通常希望从多个继承中获得的大部分特性。然而，两者之间有一个重要的区别:多重继承将不同的功能组合在一个对象中。它倾向于大的、多层面的对象。而转发是将不同的责任分配给不同的对象。它将问题分解成更小的对象，由这些小的对象来处理相关消息。</p><h3 id="Surrogate对象"><a href="#Surrogate对象" class="headerlink" title="Surrogate对象"></a>Surrogate对象</h3><p>转发不仅可以模仿多重继承，还可以开发轻量级对象,这个对象可以表示或者涵盖更多实用的功能。Surrogate代表另一个对象，并将消息传递给它。</p><p>在Objective-C编程语言中“远程消息传递”中讨论的Surrogate是这样的代理。Surrogate处理消息转发到远程接收器的细节，确保在连接中复制和检索参数值，等等。但它并没有尝试去做其他的事情;它不会复制远程对象的功能，而是简单地给远程对象一个本地地址，一个可以在另一个应用程序中接收消息的地方。</p><p>其他类型的Surrogate对象也是可能的。例如，假设您有一个处理大量数据的对象，可能会创建一个复杂的映像或读取磁盘上文件的内容。设置这个对象可能非常耗时，所以您更喜欢在实际需要时或系统资源临时空闲时使用它。与此同时，为了使应用程序中的其他对象能够正常工作，您至少需要一个占位符来支持该对象。</p><p>在这种情况下，您可以开始创建，而不是完全的对象，而是一个轻量级的Surrogate。这个对象可以自己做一些事情，比如回答关于数据的问题，但大多数情况下，它只会为较大的对象保留一个位置，当时间到来时，将消息转发给它。当Surrogate的<code>forwardInvocation:</code>方法接收一个转发给另一个对象的消息时，它将确保该对象存在，并且如果它不存在，将创建它。对于较大对象的所有消息都通过Surrogate，因此，就程序的其余部分而言，Surrogate和较大的对象将是相同的。</p><h3 id="转发和继承"><a href="#转发和继承" class="headerlink" title="转发和继承"></a>转发和继承</h3><p>尽管转发模仿继承，NSObject类从不混淆两者。方法类似respondsToSelector:和isKindOfClass:只查看继承层次结构，而不关注转发链。例如，如果询问一个战士对象是否响应协商消息，</p><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> ( [aWarrior <span class="hljs-attribute">respondsToSelector</span>:<span class="hljs-variable">@selector</span>(negotiate)] )    ...</code></pre><p>答案是否定的，即使它可以在没有错误的情况下接受协商，并且在某种意义上，通过将它们转发给一个外交官来回应。(见图5 - 1)。</p><p>在很多情况下，答案是否定的。但事实可能并非如此。如果您使用转发来设置代理对象或扩展类的功能，则转发机制应该像继承一样透明。如果您希望您的对象表现得好像它们确实继承了它们转发消息的对象的行为，那么您将需要重新实现respondsToSelector:和isKindOfClass:方法来包含您的转发算法:</p><pre><code class="hljs objectivec">- (<span class="hljs-built_in">BOOL</span>)respondsToSelector:(SEL)aSelector&#123;    <span class="hljs-keyword">if</span> ( [<span class="hljs-keyword">super</span> respondsToSelector:aSelector] )        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">/* Here, test whether the aSelector message can     *</span><span class="hljs-comment">         * be forwarded to another object and whether that  *</span><span class="hljs-comment">         * object can respond to it. Return YES if it can.  */</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;</code></pre><p>除了<code>respondsToSelector:</code> <code>isMemberOfClass:</code>和<code>isKindOfClass:</code>,<code>instancesRespondToSelector:</code>方法也应该实现转发算法。如果使用了协议，那么<code>conformsToProtocol:</code>方法也应该被添加到列表中。类似地,如果一个对象将任何远程转发消息接收,它应该有一个版本的<code>methodSignatureForSelector:</code>可以返回准确的描述方法,最终回复转发消息;例如,如果一个对象将消息转发给Surrogate,您将实现<code>methodSignatureForSelector:</code>如下:</p><pre><code class="hljs groovy">- (NSMethodSignature*)<span class="hljs-attr">methodSignatureForSelector:</span>(SEL)selector&#123;    NSMethodSignature* signature = [<span class="hljs-built_in">super</span> <span class="hljs-attr">methodSignatureForSelector:</span>selector];    <span class="hljs-keyword">if</span> (!signature) &#123;       signature = [surrogate <span class="hljs-attr">methodSignatureForSelector:</span>selector];    &#125;    <span class="hljs-keyword">return</span> signature;&#125;</code></pre><p>您可能会考虑将转发算法放在私有代码的某个地方，并拥有所有这些方法，<code>forwardInvocation:</code>包括，调用它。</p><blockquote><p>注意: 这是一种先进的技术，只适用于没有其他解决方案的情况下。它不是用来代替继承的。如果您必须使用这种技术，请确保您完全理解了正在转发的类的行为和转发的类。<br>本节中提到的方法在Foundation框架引用中的NSObject类规范中进行了描述。有关<code>invokeWithTarget</code>的信息,在Foundation框架引用中查看NSInvocation类规范。</p></blockquote><h2 id="类型编码"><a href="#类型编码" class="headerlink" title="类型编码"></a>类型编码</h2><p>为了帮助运行时系统，编译器为字符串中的每个方法编码返回和参数类型，并将字符串与方法选择器关联起来。它所使用的编码方案在其他上下文中也很有用，因此可以通过公开的@encode()编译器指令。当给定一个类型规范时，@encode()将返回一个编码该类型的字符串。类型可以是基本类型，例如int、指针、标记的结构体或union，或者类名称——任何类型，实际上都可以用作对C sizeof()操作符的参数。</p><pre><code class="hljs java"><span class="hljs-keyword">char</span> *buf1 = <span class="hljs-meta">@encode(int **)</span>;<span class="hljs-keyword">char</span> *buf2 = <span class="hljs-meta">@encode(struct key)</span>;<span class="hljs-keyword">char</span> *buf3 = <span class="hljs-meta">@encode(Rectangle)</span>;</code></pre><p>下表列出了类型代码。请注意，它们中的许多都与为存档或分发目的而编码对象时使用的代码重叠。但是，这里列出的代码是在编写代码时不能使用的，而且在编写代码时，您可能想要使用一些代码，这些代码不是由@encode()生成的。(请参阅Foundation框架参考中的NSCoder类规范，以获得关于用于存档或分发的编码对象的更多信息)。</p><p><strong>Table 6-1</strong> Objectiv-C 类型编码</p><table><thead><tr><th>Code</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>char</td></tr><tr><td>i</td><td>int</td></tr><tr><td>s</td><td>short</td></tr><tr><td>l</td><td>long</td></tr><tr><td>q</td><td>long long</td></tr><tr><td>C</td><td>unsingned char</td></tr><tr><td>I</td><td>unsigned int</td></tr><tr><td>S</td><td>unsigned short</td></tr><tr><td>L</td><td>unsigned long</td></tr><tr><td>Q</td><td>unsigned long long</td></tr><tr><td>f</td><td>float</td></tr><tr><td>d</td><td>double</td></tr><tr><td>B</td><td>C++ bool 或者 C99 _Bool</td></tr><tr><td>v</td><td>void</td></tr><tr><td>*</td><td>A character string(char *)</td></tr><tr><td>@</td><td>object(不管是静态类型或者id类型)</td></tr><tr><td>#</td><td>class object (Class)</td></tr><tr><td>:</td><td>method selector(SEL)</td></tr><tr><td>[array type]</td><td>array</td></tr><tr><td>{name=type…}</td><td>structure</td></tr><tr><td>(name=type…)</td><td>union</td></tr><tr><td>bnum</td><td>A bit field of <em>num</em> bits</td></tr><tr><td>^type</td><td>A pointer to type</td></tr><tr><td>?</td><td>unknown type(among other things, this code is used for function pointers)</td></tr></tbody></table><blockquote><p><strong>重要</strong>: Objective-C 不支持 long double 类型.@encode(long double)返回 d,编码形式跟 double一样.</p></blockquote><p>数组的类型代码括在方括号内;数组中元素的数量是在数组类型之前，在打开括号之后立即指定的。例如，浮点数的12个指针的数组将被编码为:</p><pre><code class="hljs clojure">[<span class="hljs-number">12</span><span class="hljs-comment">^f</span>]</code></pre><p>结构是在大括号内指定的，而在括号内的结合。结构标记首先列出，然后是一个等号和序列中列出的结构域的代码。例如,结构体</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example</span> &#123;</span>    id   anObject;    <span class="hljs-keyword">char</span> *aString;    <span class="hljs-keyword">int</span>  anInt;&#125; Example;</code></pre><p>会像这样编码:</p><pre><code class="hljs routeros">&#123;<span class="hljs-attribute">example</span>=@*i&#125;</code></pre><p>同样的编码结果，无论定义的类型名称(Example)还是结构标记(example)都传递给@encode()。结构指针的编码包含与结构字段相同的信息量:</p><pre><code class="hljs routeros">^&#123;<span class="hljs-attribute">example</span>=@*i&#125;</code></pre><p>然而,另一层间接移除了内部具体的类型:</p><pre><code class="hljs dust"><span class="xml">^^</span><span class="hljs-template-variable">&#123;example&#125;</span></code></pre><p>对象被看做结构体.举例来说,传递一个NSObject类名可以这样编码:</p><pre><code class="hljs routeros">&#123;<span class="hljs-attribute">NSObject</span>=#&#125;</code></pre><p>NSObject类只声明了一个类的实例变量isa。</p><p>注意，虽然@encode()指令没有返回它们，但是运行时系统使用表6-2中列出的附加编码，用于在协议中声明方法的类型限定符。</p><p><strong>Table 6-2</strong> Objective-C 方法编码</p><table><thead><tr><th>Code</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>const</td></tr><tr><td>n</td><td>in</td></tr><tr><td>N</td><td>inout</td></tr><tr><td>o</td><td>out</td></tr><tr><td>O</td><td>bycopy</td></tr><tr><td>R</td><td>byref</td></tr><tr><td>V</td><td>oneway</td></tr></tbody></table><h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><p>当编译器遇到属性声明(在Objective-C编程语言中看到已声明的属性)时，它会生成与封装类、类别或协议相关的描述性元数据。您可以使用支持在类或协议上查找属性的函数来访问此元数据，获取属性的类型为@encode字符串，并将属性的属性列表复制为C字符串数组。每个类和协议都有一个声明的属性列表。</p><h3 id="属性-类型和函数"><a href="#属性-类型和函数" class="headerlink" title="属性 类型和函数"></a>属性 类型和函数</h3><p>属性结构为属性描述符定义了一个不透明的句柄。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_property</span> *<span class="hljs-title">Property</span>;</span></code></pre><p>您可以使用函数<code>class_copyPropertyList</code>和<code>protocol _copypropertylist</code>检索与类(包括已经加载的类别)关联属性的数组，以及一个协议:</p><pre><code class="hljs reasonml">objc_property_t *<span class="hljs-keyword">class</span><span class="hljs-constructor">_copyPropertyList(Class <span class="hljs-params">cls</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">outCount</span>)</span>objc_property_t *protocol<span class="hljs-constructor">_copyPropertyList(Protocol <span class="hljs-operator">*</span><span class="hljs-params">proto</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">outCount</span>)</span></code></pre><p>例如，给定以下类声明:</p><pre><code class="hljs angelscript">@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">Lender</span> : <span class="hljs-symbol">NSObject</span> &#123;    <span class="hljs-built_in">float</span> alone;&#125;@<span class="hljs-keyword">property</span> <span class="hljs-built_in">float</span> alone;@end</code></pre><p>您可以使用以下方法获取属性列表:</p><pre><code class="hljs reasonml">id LenderClass = objc<span class="hljs-constructor">_getClass(<span class="hljs-string">&quot;Lender&quot;</span>)</span>;unsigned <span class="hljs-built_in">int</span> outCount;objc_property_t *properties = <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyPropertyList(LenderClass, &amp;<span class="hljs-params">outCount</span>)</span>;</code></pre><p>您可以使用<code>property_getName</code>函数来发现属性的名称:</p><pre><code class="hljs reasonml">const <span class="hljs-built_in">char</span> *property<span class="hljs-constructor">_getName(<span class="hljs-params">objc_property_t</span> <span class="hljs-params">property</span>)</span></code></pre><p>您可以使用函数<code>class_getProperty</code>和<code>protocol _getproperty</code>来获得类和协议中给定名称的属性的引用:</p><pre><code class="hljs reasonml">objc_property_t <span class="hljs-keyword">class</span><span class="hljs-constructor">_getProperty(Class <span class="hljs-params">cls</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>)</span>objc_property_t protocol<span class="hljs-constructor">_getProperty(Protocol <span class="hljs-operator">*</span><span class="hljs-params">proto</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>, BOOL <span class="hljs-params">isRequiredProperty</span>, BOOL <span class="hljs-params">isInstanceProperty</span>)</span></code></pre><p>您可以使用<code>property_getAttributes</code>函数来发现属性的名称和@encode类型字符串。有关编码类型字符串的详细信息，请参阅类型编码;有关此字符串的详细信息，请参见属性类型字符串和属性属性描述示例。</p><pre><code class="hljs reasonml">const <span class="hljs-built_in">char</span> *property<span class="hljs-constructor">_getAttributes(<span class="hljs-params">objc_property_t</span> <span class="hljs-params">property</span>)</span></code></pre><p>将这些组合在一起，您可以使用以下代码打印与类关联的所有属性:</p><pre><code class="hljs reasonml">id LenderClass = objc<span class="hljs-constructor">_getClass(<span class="hljs-string">&quot;Lender&quot;</span>)</span>;unsigned <span class="hljs-built_in">int</span> outCount, i;objc_property_t *properties = <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyPropertyList(LenderClass, &amp;<span class="hljs-params">outCount</span>)</span>;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; outCount; i++) &#123;    objc_property_t property = properties<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;    fprintf(stdout, <span class="hljs-string">&quot;%s %s\n&quot;</span>, property<span class="hljs-constructor">_getName(<span class="hljs-params">property</span>)</span>, property<span class="hljs-constructor">_getAttributes(<span class="hljs-params">property</span>)</span>);&#125;</code></pre><h3 id="属性-类型字符串"><a href="#属性-类型字符串" class="headerlink" title="属性 类型字符串"></a>属性 类型字符串</h3><p>您可以使用<code>property_getAttributes</code>函数来发现属性的名称、@encode类型字符串和属性的其他属性。</p><p>字符串以一个T开头，后面是@encode类型和一个逗号，最后是一个V，后面跟着一个支持实例变量的名称。在他们之间，填充属性描述符，由逗号分隔:</p><p>详细内容请看<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html"><strong>Table 7-1</strong></a>和属性特性描述示例</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要关注关注runtime 消息的动态解析与转发，主要包含三个方法：</p><ul><li><code>resolveInstanceMethod:</code><br>当实例对象无法找到 sel 实现时，首先调用此方法，对sel做处理</li><li><code>resolveClassMethod:</code><br>当类对象无法找到 sel 实现时，首先调用此方法，对sel做处理</li><li><code>forwardTargetForSelector:</code><br>sel 仍未处理，接着调用此方法，在这里可以对sel做处理</li><li><code>methodSignatureForSelector:</code><br>sel 仍未处理，runtime会通过<code>methodSigntureForSelector</code>方法尝试获取本次消息调用的具体环境信息，包括消息的参数与返回值类型。并封装成NSInvocation对象。我们可以在<code>forwardInvocation</code>方法内部对该对象作进一步的处理，并使之能够成功的完成消息处理。如果末能成功获取NSInvocation对象，那么程序就会发送<code>doesNotRecognizeSelector</code>消息抛出<code>unrecognized Selector send to xxx</code>的异常。</li></ul><p>关于runtime的更多有趣的使用，可以在<a href="https://www.jianshu.com/p/6a72f21bf521">Objective-C Runtime</a>中寻找对应的API来探索，里面有runtime 各方法的说明。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/913868456/OCDemo">Runtime_Demo</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/e6a9492995a5">iOS runtime之消息机制</a><br><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418855-forwardingtargetforselector">forwardTargetForSelector:</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1">Objective-C Runtime Programming Guide</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/blog/2018/01/05/iOS/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <url>/blog/2018/01/05/iOS/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p><strong>常用算法</strong></p><table><thead><tr><th></th><th>对称加密算法</th><th>非对称加密算法</th><th>散列算法</th></tr></thead><tbody><tr><td>常用算法</td><td>DES、 3DES、 AES</td><td>RSA 、DSA、 ECC</td><td>MD5 、  SHA   、 HMAC</td></tr><tr><td>优点</td><td>算法公开、计算量小、加密速度快、加密效率高</td><td>与对称加密比较,安全性更好,秘钥管理方便</td><td>常用于验证消息完整性</td></tr><tr><td>缺点</td><td>秘钥容易泄露,秘钥管理负担过重</td><td>加密和解密花费时间长、速度慢，只适合对少量数据进行加密</td><td></td></tr><tr><td>应用</td><td>保存用户手机号、身份证信息等信息</td><td>一般用于签名和认证</td><td>校验文件下载正确性,存储用户敏感信息,如密码.卡号等不可解密信息</td></tr></tbody></table><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>从GitHub上和各大博客平台查阅相关资料，比较了一下，感觉GitHub上<a href="https://github.com/kelp404/CocoaSecurity">CocoaSecurity</a>对各算法总结的比较全面，里面包含了AES、SHA、MD5、HMAC各种算法的加密解密和计算。能够满足项目中的需求,另外在Demo中我还参考了<a href="https://github.com/ideawu">ideawu</a>的<a href="https://github.com/ideawu/Objective-C-RSA">RSA</a>的使用，便于我们对RSA的理解和认识。<a href="https://github.com/reejosamuel/RSA">reejosamuel/RSA</a>也不错，里面包含了RSA公钥和私钥的生成，保存和加密解密等方法，很详细，很实用，推荐使用。</p><blockquote><p>注意： CocoaSecurity 使用的时候可能会缺少 Base64 文件，将Demo中的Base64文件添加进去就行了。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/913868456/OCDemo">OCDemo</a> 下的 Encryption Demo有AES RSA SHA MD5 HMAC使用示例。如果对您有用的话，麻烦给个Star.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/kelp404/CocoaSecurity">kelp404/CocoaSecurity</a><br><a href="https://github.com/reejosamuel/RSA">reejosamuel/RSA</a><br><a href="https://github.com/ideawu/Objective-C-RSA">ideawu/Objective-C-RSA</a><br><a href="https://www.jianshu.com/p/8a55423f2742">常用加密算法解析</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreBluetooth 编程指南</title>
    <link href="/blog/2018/01/03/iOS/Core-Bluetooth-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <url>/blog/2018/01/03/iOS/Core-Bluetooth-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Core Bluetooth 框架给iOS和Mac apps 提供与外部蓝牙设备交互的能力.例如,您的app能够发现,扫描,并且跟外部设备交互.比如心率计和数码恒温计.同样 Mac 和 iOS 设备也可以作为低功耗外部设备,给其他设备提供数据.</p><p>在Core Bluetooth 中,中心设备和外部设备作为主要参与者.通常情况下我们通过一个app来实现中心设备角色,Core Bluetooth 也可以将我们的本地设备作为外部设备角色来实现.</p><h3 id="iOS-App-状态影响蓝牙行为"><a href="#iOS-App-状态影响蓝牙行为" class="headerlink" title="iOS App 状态影响蓝牙行为"></a>iOS App 状态影响蓝牙行为</h3><p>当app处于后台或者挂起状态时,这种情况会影响蓝牙相关功能.默认情况下,app在后台或者挂起状态时,不能执行蓝牙任务.如果想要app在后台执行蓝牙任务,可以声明该app支持Core Bluetooth后台执行模式中的一项或者两项都支持.当app处于后台状态时,同一蓝牙任务的操作是不同的.在设计app时,要考虑这些差异.</p><p>即使app支持后台操作,当内存不足时系统会随时终止后台应用,来给前台运行的app提供内存空间.iOS 7后,Core Bluetooth支持保存中心设备和外部设备管理者对象的状态.可以使用该特性去支持长时间调用蓝牙设备的操作.</p><h3 id="遵循最佳实践来提高用户体验"><a href="#遵循最佳实践来提高用户体验" class="headerlink" title="遵循最佳实践来提高用户体验"></a>遵循最佳实践来提高用户体验</h3><p>由于无线广播会给设备电池造成不利影响.因此,设计app的时候尽可能减少无线广播的使用.遵循最佳实践来减少该方面的不利影响同时提高用户的体验.</p><h2 id="Core-Bluetooth-概述"><a href="#Core-Bluetooth-概述" class="headerlink" title="Core Bluetooth 概述"></a>Core Bluetooth 概述</h2><p>本章节主要介绍开始使用Core Bluetooth 开发时需要了解的专业词汇和概念.</p><blockquote><p>重要: 一个 iOS app 在 iOS 10.0 之后的版本,必须在info.plist 文件中描述需要访问的数据类型,否则会崩溃.访问外部设备的指定数据,在info.plist 文件中必须包含 NSBluetoothPeripheralUsageDescription.</p></blockquote><h3 id="中心设备和外部设备-以及他们在蓝牙通信中的角色"><a href="#中心设备和外部设备-以及他们在蓝牙通信中的角色" class="headerlink" title="中心设备和外部设备,以及他们在蓝牙通信中的角色"></a>中心设备和外部设备,以及他们在蓝牙通信中的角色</h3><p>中心设备和外部设备是低功耗蓝牙通信中的来个主要参与者.中心设备使用来自与外部设备的信息去完成某项特定任务.下面的例子中,表示一个mac 或者 iOS app 用一种对用户来讲更友好的方式来展示来自于心率检测器的信息.</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-c9641636941a7f71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="中心设备发现并连接外围正在广播的设备"><a href="#中心设备发现并连接外围正在广播的设备" class="headerlink" title="中心设备发现并连接外围正在广播的设备"></a>中心设备发现并连接外围正在广播的设备</h4><p>外部设备以 advertising packet 的格式来发送广播.广播数据中包含外部设备的名称和主要功能.一个中心设备可用浏览和听取正在广播的外部设备内容.一个中心设备可以请求连接任何发现正在广播的外部设备.</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-5c28cac2a725ceed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="一个外部设备的数据如何构建"><a href="#一个外部设备的数据如何构建" class="headerlink" title="一个外部设备的数据如何构建"></a>一个外部设备的数据如何构建</h4><p>外部设备包含一项或者多项服务.一个服务是一个数据集合.举例子,一个心率计的服务可以用来显示来自于心率传感器的的心率数据.</p><p>服务本身由特性或者其中包含的其他服务组成.一个特性提供外部设备服务的详细信息.举例子,心率服务包含两个特性,一个特性描述设备传感器的监听位置.另外一个特性传输测量的数据.</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-11772f3214f18ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="中心设备扫描并且跟一个外部设备数据交互"><a href="#中心设备扫描并且跟一个外部设备数据交互" class="headerlink" title="中心设备扫描并且跟一个外部设备数据交互"></a>中心设备扫描并且跟一个外部设备数据交互</h4><p>一个中心设备和外部设备成功建立连接后,可以发现外部设备提供的所有服务和特性.<br>中心设备可以通过读写服务特性的值来跟外部设备的服务进行交互.举例来说,app 请求当前房间的室温.或者提供给恒温计一个值来设定室温.</p><h3 id="中心设备-外部设备-以及外部设备数据如何表示"><a href="#中心设备-外部设备-以及外部设备数据如何表示" class="headerlink" title="中心设备,外部设备,以及外部设备数据如何表示"></a>中心设备,外部设备,以及外部设备数据如何表示</h3><p>本地中心设备管理者通过 CBCentralManager 对象表示.这个对象用来管理远程外部设备的遍历,发现,连接正在发送广播的外部设备.</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-cc9e991217247c05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Core Bluetooth objects on the central side"></p><p>远程外部设备 用CBPeripheral对象来表示, 它的数据通过 CBService 和 CBCharacteristic 对象来表示.<br><img src="http://upload-images.jianshu.io/upload_images/3340896-0fd143eeaa33aada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>外部设备管理者 用CBPeripheralManager对象来表示. 这些对象用来管理发布的服务和相关特性.并且通过广播来给远程中心设备(CBCentral 对象)发送服务. Peripheral manager对象也用来响应远程中心设备的读写请求.<br><img src="http://upload-images.jianshu.io/upload_images/3340896-3b76d790666594fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>外部设备管理者(CBPeripheralManger)的数据通过CBMutableService 和 CBMutableCharacteristic 对象来表示.<br><img src="http://upload-images.jianshu.io/upload_images/3340896-6bb597fc20300ec7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A local peripheral&#39;s tree of services and characteristics"></p><h2 id="执行中心角色任务"><a href="#执行中心角色任务" class="headerlink" title="执行中心角色任务"></a>执行中心角色任务</h2><p>本节学习内容:</p><ul><li>启动一个中心设备管理者对象</li><li>发现并链接正在广播的外部设备</li><li>扫描链接的外部设备数据</li><li>给一个外部设备服务特性值发送读写请求</li><li>订阅一个特性值的变动通知</li></ul><h3 id="启动一个中心设备管理者"><a href="#启动一个中心设备管理者" class="headerlink" title="启动一个中心设备管理者"></a>启动一个中心设备管理者</h3><p>创建CBCentralManager</p><pre><code class="hljs crystal">myCentralManager = [[CBCentralManager alloc] <span class="hljs-symbol">initWithDelegate:</span> <span class="hljs-keyword">self</span> <span class="hljs-symbol">queue:</span><span class="hljs-literal">nil</span> <span class="hljs-symbol">options:</span><span class="hljs-literal">nil</span>];</code></pre><p>self 必须实现 centralMangerDidUpdateState: 代理方法.更多内容请看<a href="https://developer.apple.com/documentation/corebluetooth/cbcentralmanagerdelegate">CBCentralManagerDelegate Protocol Reference</a></p><h3 id="发现正在广播的外部设备"><a href="#发现正在广播的外部设备" class="headerlink" title="发现正在广播的外部设备"></a>发现正在广播的外部设备</h3><pre><code class="hljs crystal">[myCentralManager <span class="hljs-symbol">scanForPeripheralsWithServices:</span><span class="hljs-literal">nil</span> <span class="hljs-symbol">options:</span><span class="hljs-literal">nil</span>];</code></pre><blockquote><p>注意: 如果给第一个参数指定为nil,central manager返回所有发现的外部设备.在真实情况中,一般会指定一个CBUUID对象组成的数组,每个对象表示一个服务的唯一标识.当指定好UUID对象数组后,central manager 仅返回正在广播相关服务的外部设备.浏览最感兴趣的外部设备.<br>UUIDs,和CBUUID对象详细内容请看<a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/PerformingCommonPeripheralRoleTasks/PerformingCommonPeripheralRoleTasks.html#//apple_ref/doc/uid/TP40013257-CH4-SW8">Services and Characteristics Are Identified by UUIDs</a></p></blockquote><p>central manager 每次发现外部设备,就会调用代理对象的  cetralManager:didDiscoverPeripheral:advertisementData:RSSI: 方法.新发现的外部设备以 CBPeripheral 对象返回.如果打算链接发现的外部设备,给该对象一个强引用,系统就不会释放它.</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>centralManager:<span class="hljs-params">(CBCentralManager *)</span>central didDiscoverPeripheral:<span class="hljs-params">(CBPeripheral *)</span>peripheral advertisementData:<span class="hljs-params">(NSDictionary *)</span>advertisementData RSSI:<span class="hljs-params">(NSNUmber *)</span>RSSI &#123;    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Discovered %@&quot;</span>, peripheral.name)</span>;    self.discoverdPeripheral = peripheral;    ...</code></pre><p>如果希望链接多个设备,需要用一个NSArray来存储发现的外部设备.一旦所有想连接的设备都被发现,停止浏览其他设备来节省电量:</p><pre><code class="hljs ini"><span class="hljs-section">[myCentralManager stopScan]</span><span class="hljs-comment">;</span></code></pre><h3 id="链接发现的外部设备"><a href="#链接发现的外部设备" class="headerlink" title="链接发现的外部设备"></a>链接发现的外部设备</h3><pre><code class="hljs groovy">[myCentralManager <span class="hljs-attr">connectPeripheral:</span>peripheral <span class="hljs-attr">options:</span>nil];</code></pre><p>如果链接请求成功,central manager 调用代理对象的centralManager:didConnectPeripheral:方法.在跟外部设备交互前,设置它的代理来确保代理接受到了合适的回调:</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>centralManager:<span class="hljs-params">(CBCentralManager *)</span>central didConnectPeripheral:<span class="hljs-params">(CBPeripheral *)</span>peripheral &#123;        NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Peripheral connected&quot;</span>)</span>;    peripheral.delegate = self;    ...</code></pre><h3 id="发现链接外部设备的服务"><a href="#发现链接外部设备的服务" class="headerlink" title="发现链接外部设备的服务"></a>发现链接外部设备的服务</h3><p>跟一个外部设备建立连接后,可以浏览它的数据.首先浏览外部设备提供的可用服务.由于外部设备发送广播的数据限制,会发现一个外部设备提供的服务比广播的更多.可以使用discoverServices: 方法来发现一个外部设备提供的所有服务.</p><pre><code class="hljs ini"><span class="hljs-section">[peripheral discoverServices:nil]</span><span class="hljs-comment">;</span></code></pre><blockquote><p>注意: 在一个app中,一般不给参数传nil,因为这样会返回所有的可用服务.由于一个外部设备有许多不相关的服务,发现所有可用服务不仅浪费电量而且浪费时间.因此,指定服务的UUIDs来发现指定的服务.</p></blockquote><p>当指定的服务发现后,连接的外部设备(CBPeripheral对象)调用代理对象的 peripheral:didDiscoverServices: 方法.Core Bluetooth 创建一个CBService数组—</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>peripheral:<span class="hljs-params">(CBPeripheral *)</span>peripheral didDiscoverServices:<span class="hljs-params">(NSerror *)</span>error&#123;        for <span class="hljs-params">(CBService *service in peripheral.services)</span> &#123;                NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Discovered service %@&quot;</span>, service)</span>;        ...    &#125;    ...</code></pre><h3 id="发现一个服务的特性"><a href="#发现一个服务的特性" class="headerlink" title="发现一个服务的特性"></a>发现一个服务的特性</h3><pre><code class="hljs groovy">NSLog (@<span class="hljs-string">&quot;Discovering characteristics for service %@&quot;</span>, interestingService);[peripheral <span class="hljs-attr">discoverCharacteristics:</span>nil <span class="hljs-attr">forService:</span>interestingService];</code></pre><blockquote><p>注意: 真实环境中,第一个参数一般不传nil,通常指定想要找的特性UUIDs</p></blockquote><p>当指定服务的特性被发现后,外部设备调用代理对象的 peripheral:didDiscoverCharacteristicsForService:error: 方法.Core Bluetooth创建一个包含CBCharacteristic对象的数组来包含所有发现的特性.</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>peripheral:<span class="hljs-params">(CBPeripheral *)</span>peripheral didDiscoverCharacteristicsForService:<span class="hljs-params">(CBService *)</span>service error:<span class="hljs-params">(NSError *)</span>error &#123;        for <span class="hljs-params">(CBCharacteristic *characteristic in service.characteristics)</span> &#123;                NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Discovered characteristic %@&quot;</span>, characteristic)</span>;        ...    &#125;    ...</code></pre><h3 id="获取一个特性的值"><a href="#获取一个特性的值" class="headerlink" title="获取一个特性的值"></a>获取一个特性的值</h3><p>直接读取特性的value或者订阅它来获取特性的值.</p><h4 id="读取特性值"><a href="#读取特性值" class="headerlink" title="读取特性值"></a>读取特性值</h4><pre><code class="hljs less"><span class="hljs-selector-tag">NSLog</span>(@<span class="hljs-string">&quot;Reading value for characteristic %@&quot;</span>, interestingCharacteristic);<span class="hljs-selector-attr">[peripheral readValueForCharacteristic:interestingCharacteristic]</span>;</code></pre><p>当尝试读取特性值时,外部设备调用代理对象的 peripheral:didUpdateValueForCharacteristic:error:方法来获取特性值.</p><pre><code class="hljs groovy">- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">peripheral:</span> (CBPeripheral *)peripheral <span class="hljs-attr">didUpdateValueForCharacteristic:</span>(CBCharacteristic *)characteristic <span class="hljs-attr">error:</span>(NSError *)error &#123;        NSData *data = characteristic.value;    <span class="hljs-comment">//parse the data as needed </span>    ...</code></pre><blockquote><p>注意:不是所有的特性都是可读的.通过CBCharacteristicPropertyRead属性常量来检测特性是否可读.如果不可读,会返回适当的错误.</p></blockquote><h4 id="订阅一个特性值"><a href="#订阅一个特性值" class="headerlink" title="订阅一个特性值"></a>订阅一个特性值</h4><pre><code class="hljs groovy">[peripheral <span class="hljs-attr">setNotifyValue:</span>YES <span class="hljs-attr">forCharacteristic:</span> interestingCharacteristic];</code></pre><pre><code class="hljs erlang">当订阅失败时,可以实现下面方法来获取订阅失败原因.- <span class="hljs-params">(void)</span>peripheral:<span class="hljs-params">(CBPeripheral *)</span>peripheral didUpdateNotificationStateForCharacteristic:<span class="hljs-params">(CBCharacteristic *)</span>characteristic error:<span class="hljs-params">(NSError *)</span>error &#123;        if <span class="hljs-params">(error)</span> &#123;               NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Error changing notification state: %@&quot;</span>, [error localizedDescription])</span> ;    &#125;    ...</code></pre><blockquote><p>注意:不是所有的特性都可订阅.可以通过属性的CBCharacteristicPropertyNotify或者CBCharacteristicPropertyIndicate常量来检测属性是否可被订阅.</p></blockquote><h3 id="给一个特性写入值"><a href="#给一个特性写入值" class="headerlink" title="给一个特性写入值"></a>给一个特性写入值</h3><pre><code class="hljs groovy">NSLog(@<span class="hljs-string">&quot;Wrriting value for characteristic %@&quot;</span>, interestingCharacteristic);[peripheral <span class="hljs-attr">writeValue:</span>dataToWrite <span class="hljs-attr">forCharacteristic:</span>interestingCharacteristic <span class="hljs-attr">type:</span>CBCharacteristicWriteWithResponse];</code></pre><p>代理对象调用下面方法,通过CBCharacteristicWriteWithResponse来告诉app写入是否成功.</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>peripheral:<span class="hljs-params">(CBPeripheral *)</span>peripheraldidWriteValueForCharacteristic:<span class="hljs-params">(CBCharacteristic *)</span>characteristic             error:<span class="hljs-params">(NSError *)</span>error &#123;     if <span class="hljs-params">(error)</span> &#123;        NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Error writing characteristic value: %@&quot;</span>,</span><span class="hljs-params">            [error localizedDescription])</span>;    &#125;    ...</code></pre><blockquote><p>注意:特性仅支持特定的写入类型.可以通过一个特性的CBCharacteristicPropertyWriteWithoutResponse 或者 CBCharacteristicPropertyWrite 常量来检查支持的写入类型.</p></blockquote><h2 id="执行外部角色任务"><a href="#执行外部角色任务" class="headerlink" title="执行外部角色任务"></a>执行外部角色任务</h2><p>本节学习内容:</p><ul><li>启动一个外部设备管理对象</li><li>设置本地外部设备的服务和特性</li><li>给设备的本地数据库发布服务和特性</li><li>广播服务</li><li>响应一个连接的中心设备的读写请求</li><li>给订阅的中心设备发送更新后的特性值</li></ul><h3 id="启动一个外部设备管理者"><a href="#启动一个外部设备管理者" class="headerlink" title="启动一个外部设备管理者"></a>启动一个外部设备管理者</h3><pre><code class="hljs crystal">myPeripheralManager = [[CBPeripheralManager alloc] <span class="hljs-symbol">initWithDelegate:</span><span class="hljs-keyword">self</span> <span class="hljs-symbol">queue:</span><span class="hljs-literal">nil</span> <span class="hljs-symbol">options:</span> <span class="hljs-literal">nil</span>];</code></pre><p>创建CBPeripheralManager对象后 self 必须实现 peripheralMangagerDidUpdateState: 方法.  详细内容请看 <a href="">CBPeripheralManagerDelegate Protocol Reference</a> </p><h3 id="设置外部设备管理者的服务和特性"><a href="#设置外部设备管理者的服务和特性" class="headerlink" title="设置外部设备管理者的服务和特性"></a>设置外部设备管理者的服务和特性</h3><p>一个本地外部设备服务和特性的数据库以类似于树状的方式组成.必须以这种方式去组织本地外部设备的服务和特性. 在执行这些任务中首先要理解如何识别这些服务和特性.</p><h4 id="服务和特性通过UUIDs来识别"><a href="#服务和特性通过UUIDs来识别" class="headerlink" title="服务和特性通过UUIDs来识别"></a>服务和特性通过UUIDs来识别</h4><p>iOS中通过CBUUID对象来表示外部设备指定的服务和特性.比如,128位的UUID心率服务可以使用CBUUID 对象的 UUIDWithString 方法来表示预定义的16位UUID.</p><pre><code class="hljs groovy">CBUUID *heartRateServiceUUID = [CBUUID <span class="hljs-attr">UUIDWithString:</span> @<span class="hljs-string">&quot;180D&quot;</span>];</code></pre><p>当从一个预定义的16位UUID中创建一个CBUUID对象时,Core Bluetooth 会用Bluetooth base UUID 预填128位UUID的剩下的部分.</p><h4 id="创建自有的UUIDs来自定义服务和特性"><a href="#创建自有的UUIDs来自定义服务和特性" class="headerlink" title="创建自有的UUIDs来自定义服务和特性"></a>创建自有的UUIDs来自定义服务和特性</h4><p>使用命令行实用工具 uuidgen 很容易生成一个128位的UUIDs.</p><pre><code class="hljs angelscript">$ uuidgen <span class="hljs-number">71</span>DA3FD1<span class="hljs-number">-7E10</span><span class="hljs-number">-41</span>C1-B16F<span class="hljs-number">-4430</span>B506CDE7</code></pre><p>然后使用这个UUID去创建一个CBUUID对象</p><pre><code class="hljs subunit">CBUID *myCustomServiceUUID = [CBUUID UUIDWithString:@&quot;71DA3FD1<span class="hljs-string">-7</span>E10<span class="hljs-string">-41</span>C1-B16F<span class="hljs-string">-4430</span>B506CDE7&quot;];</code></pre><h4 id="创建服务和特性树"><a href="#创建服务和特性树" class="headerlink" title="创建服务和特性树"></a>创建服务和特性树</h4><pre><code class="hljs groovy">myCharacteristic = [[CBMutableCharacteristic alloc] <span class="hljs-attr">initWithType:</span>myCharacteristicUUID <span class="hljs-attr">properties:</span>CBCharacteristicPropertyRead <span class="hljs-attr">Value:</span> myValue <span class="hljs-attr">permissions:</span>CBAttributePermissionsReadable];</code></pre><blockquote><p>注意:如果指定一个特性值.该值会缓存并且它的属性和许可被设置为可读.因此,如果你需要一个特性值可写,或者期望发布的服务特性能够被改变.必须指定value为nil.</p></blockquote><p>现在已经创建了一个可变特性,可以创建一个可变服务跟其相关联.按照下面方法做</p><pre><code class="hljs ini"><span class="hljs-attr">myService</span> = [[CBMutableService alloc] initWithType:myServiceUUID primary:<span class="hljs-literal">YES</span>]<span class="hljs-comment">;</span><span class="hljs-attr">myService.characteristics</span> = @[myCharacteristic]<span class="hljs-comment">;</span></code></pre><h3 id="发布服务和特性"><a href="#发布服务和特性" class="headerlink" title="发布服务和特性"></a>发布服务和特性</h3><pre><code class="hljs ini"><span class="hljs-section">[myPeripheralManager addService:myService]</span><span class="hljs-comment">;</span></code></pre><p>当调用这个方法去发布服务时,外部设备管理者会通过他的代理对象调用 peripheralManager:didAddService:error: 方法.如果过发生错误或者无法发布服务,则实现该代理方法来获取错误原因.</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>peripheralManager:<span class="hljs-params">(CBPeripheralManager *)</span>peripheral            didAddService:<span class="hljs-params">(CBService *)</span>service                    error:<span class="hljs-params">(NSError *)</span>error &#123;     if <span class="hljs-params">(error)</span> &#123;        NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Error publishing service: %@&quot;</span>, [error localizedDescription])</span>;    &#125;    ...</code></pre><blockquote><p>当给外部设备的数据库发布一个服务和相关特性后,服务被缓存并且无法修改.</p></blockquote><h3 id="广播服务"><a href="#广播服务" class="headerlink" title="广播服务"></a>广播服务</h3><pre><code class="hljs scheme">[<span class="hljs-name">myPeripheralManager</span> startAdvertising:@&#123; CBAdvertisementDataServiceUUIDsKey : @[<span class="hljs-name">myFirstService.UUID</span>, mySecondService.UUID]&#125;]<span class="hljs-comment">;</span></code></pre><p>当在本地外部设备发送广播时,外部设备管者的代理对象调用 peripheralManagerDidStartAdvertising:error: 方法.如果出现错误或者服务无法广播.实现该方法来获取错误信息.</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>peripheralManagerDidStartAdvertising:<span class="hljs-params">(CBPeripheralManager *)</span>peripheral                                       error:<span class="hljs-params">(NSError *)</span>error &#123;     if <span class="hljs-params">(error)</span> &#123;        NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Error advertising: %@&quot;</span>, [error localizedDescription])</span>;    &#125;    ...</code></pre><p>一旦广播数据开始,远程中心设备能够发现并和本地外部设备建立连接.</p><h3 id="响应中心设备的读写请求"><a href="#响应中心设备的读写请求" class="headerlink" title="响应中心设备的读写请求"></a>响应中心设备的读写请求</h3><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>peripheralManager:<span class="hljs-params">(CBPeripheralManager *)</span>peripheral didReceiveReadRequest:<span class="hljs-params">(CBATTRequest *)</span>request &#123;        if <span class="hljs-params">([request.characteristic.UUID isEqual:myCharacteristic.UUID])</span> &#123;        ...</code></pre><p>如果特性的UUID匹配,下一步确定请求的索引位置是否超出特性值的边界.</p><pre><code class="hljs applescript"><span class="hljs-keyword">if</span> (request.<span class="hljs-built_in">offset</span> &gt; myCharacteristic.value.<span class="hljs-built_in">length</span>) &#123;        [myPeripheralManager respondToRequest:request withResult:CBATTErrorInvalidOffset];    <span class="hljs-built_in">    return</span>;&#125;</code></pre><p>加入请求的offset合格.现在给请求特性属性赋值.</p><pre><code class="hljs ini"><span class="hljs-attr">request.value</span> = [myCharacteristic.value subdataWithRange:NSMakeRange(request.<span class="hljs-literal">off</span>set, myCharacteristic.value.length - request.<span class="hljs-literal">off</span>set)]<span class="hljs-comment">;</span></code></pre><p>设置好值后,响应远程中心设备请求.</p><pre><code class="hljs groovy">[myPeripheralManager <span class="hljs-attr">respondToRequest:</span>request <span class="hljs-attr">withResult:</span>CBATTErrorSuccess];...</code></pre><p>每调用 peripheralManager:didReceiveReadRequest: 方法一次,就会调用 respondToRequst:withResult: 一次.</p><blockquote><p>注意: 如果特性UUID不匹配或者无法完成读请求.调用 respondToRequest:withResult: 方法,并返回合适的错误原因.(CBATTError Constants)</p></blockquote><p>处理一个写入请求,直接将CBATTRequest 对象的值写入特性.</p><pre><code class="hljs ini"><span class="hljs-attr">myCharacteristic.value</span> = request.value<span class="hljs-comment">;</span></code></pre><p>传入的写入请求数组中包含CBATTRequest 对象.每个对象写入特性都会调用  respondToRequest:withResult: 方法.</p><pre><code class="hljs scheme">[<span class="hljs-name">myPeripheralManager</span> respondToRequest:[<span class="hljs-name">request</span> objectAtIndeex:0] withResult:CBATTErrorSuccess]<span class="hljs-comment">;</span></code></pre><h3 id="给订阅的中心设备发送更新的特性值"><a href="#给订阅的中心设备发送更新的特性值" class="headerlink" title="给订阅的中心设备发送更新的特性值"></a>给订阅的中心设备发送更新的特性值</h3><p>中心设备订阅通知后会调用该方法</p><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>peripheralManager:<span class="hljs-params">(CBPeripheralManager *)</span>peripheral central:<span class="hljs-params">(CBCentral *)</span>central didSubscribeToCharacteristic:<span class="hljs-params">(CBCharacteristic *)</span>characteristic &#123;        NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;Central subscribed to characteristic %@&quot;</span>, characteristic)</span>;    ...</code></pre><pre><code class="hljs groovy">NSData *updatedValue = <span class="hljs-comment">//fetch the characteristic&#x27;s new value </span>BOOL didSendValue = [myPeripheralManager <span class="hljs-attr">updateValue:</span>updatedValue <span class="hljs-attr">forCharacteristic:</span>characteristic <span class="hljs-attr">onSubscribedCentrals:</span>nil];</code></pre><h2 id="iOS-Apps-中-Core-Bluetooth-的后台处理"><a href="#iOS-Apps-中-Core-Bluetooth-的后台处理" class="headerlink" title="iOS Apps 中 Core Bluetooth 的后台处理"></a>iOS Apps 中 Core Bluetooth 的后台处理</h2><p>对于iOS apps,了解app在后台还是前台运行非常重要.一个app在后台的行为必须不同于前台.因为系统提供的资源是有限的.对于在iOS上所有的后台操作讨论,请看<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4">Background Execution</a> in <a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072">App Programming Guide for iOS</a></p><p>默认情况下,许多普通的Core Bluetooth 任务—中心设备和外部设备都有— 在后台或者挂起模式下都是禁用的.也就是说,您需要声明您的app去支持Core Bluetooth后台执行模式,从而允许您的app能够从挂起状态中唤醒去处理某些蓝牙相关的事件.即使您的app不需要所有范围内的后台处理支持.当重要事件发生后仍然可以要求系统提示.</p><p>即使您的app支持一种或者两种Core Bluetooth 后台执行模式,但是它也不能永远运行. 某些情况下,系统会中为了给前台运行的app释放内存从而终止您的app.从而使app激活的或者添加的链接丢失.</p><h3 id="只在前台使用Core-Bluetooth的Apps"><a href="#只在前台使用Core-Bluetooth的Apps" class="headerlink" title="只在前台使用Core Bluetooth的Apps"></a>只在前台使用Core Bluetooth的Apps</h3><p>绝大多数apps,除非您请求后台执行特定任务的许可,否则您的app短暂进入后台状态后就会转到挂起状态.在挂起状态下,您的app无法执行蓝牙相关任务.也不能感知任何蓝牙相关事件,直到它恢复到前台运行.</p><p>在中心设备这边,只在前台执行的apps—那些没有声明支持Core Bluetooth后台执行模式任何一种的app,在后台状态或者挂起状态是无法浏览或者发现正在广播的外部设备. 在外部设备这边,当一个仅支持前台模式的app处于挂起状态时，所有蓝牙相关的事件发生时将通过系统添加到队列。并且当app恢复到前台时发送给它。也就是说，Core Bluetooth 提供一种方式，当某些中心设备角色事件发生时提醒用户。用户然后能够利用这些提示来决定是否一个特殊事件许可app返回到前台。<br>您可以在调用CBCentralManager 类的 connectPeripheral:options: 方法使用下列的外部设备链接可选项，利用这些提示来链接一个远程外部设备。</p><ul><li>CBConnectPeripheralOptionNotifyOnConnectionKey</li><li>CBConnectPeripheralOptionNotifyOnDisconnectionKey</li><li>CBConnectPeripheralOptionNotifyOnNotificationKey</li></ul><h4 id="Core-Bluetooth-后台执行模式"><a href="#Core-Bluetooth-后台执行模式" class="headerlink" title="Core Bluetooth 后台执行模式"></a>Core Bluetooth 后台执行模式</h4><p>当需要app在后台执行一些蓝牙相关任务时，必须在info.plist 文件中声明它支持一种蓝牙后台执行模式。<br>info.plist 中文件 添加 key 为 UIBackgroundModes, 然后给一个数组中添加下面的字符串：</p><ul><li>bluetooth-central</li><li>bluetooth-peripheral</li></ul><h4 id="蓝牙-中心设备后台执行模式"><a href="#蓝牙-中心设备后台执行模式" class="headerlink" title="蓝牙-中心设备后台执行模式"></a>蓝牙-中心设备后台执行模式</h4><p>记住在后台浏览外部设备的操作跟在前台时不同的。</p><ul><li>CBCentralManagerScanOptionAllowDuplicatesKey 浏览可选键 被忽略，并且多个正在广播的外部设备发现合并成一个发现事件。</li><li>如果所有正在扫描外部设备的app都在后台，中心设备的内部扫描广播的包也相继增长。结果，发现一个正在广播的外部设备的时间也会变长。<br>这些变动帮助最小化无限广播的使用,并且提高电池使用寿命。</li></ul><h4 id="蓝牙-外部设备-后台执行模式"><a href="#蓝牙-外部设备-后台执行模式" class="headerlink" title="蓝牙-外部设备 后台执行模式"></a>蓝牙-外部设备 后台执行模式</h4><p>当app处于后台状态 时，广播跟前台是不同的：</p><ul><li>CBAdvertisementDataLocalNameKey 被忽略，本地外部设备的名字也不会被广播。</li><li>所有包含在CBAdvertisementDataServiceUUIDsKey对应值下的服务UUIDs被放置在一个特殊的“溢出”区。只有一个iOS设备明确要求扫描特它们时，才能被发现。</li><li>如果所有正在广播的apps在后台状态，外部设备发送广播的频率会降低。</li></ul><h3 id="更好地使用后台执行模式"><a href="#更好地使用后台执行模式" class="headerlink" title="更好地使用后台执行模式"></a>更好地使用后台执行模式</h3><p>由于处理蓝牙相关事件会使用无线电，无线电的使用会给电池寿命带来负面影响<br>最小化在后台状态下的工作量。app被唤醒的蓝牙相关事件应该尽快处理以便它能再次挂起。<br>任何声明支持核心蓝牙后台执行模式的app 必须遵循一些原则：</p><ul><li>Apps 应该基于会话类 并且提供一个接口允许用户决定何时开始和结束蓝牙相关事件的发送。</li><li>在被唤醒状态下，一个app有大约10秒时间去处理一项任务。 理想情况下，应该尽快处理任务并且允许再次进入后台。Apps 在后台执行过长时间会被系统限制或者杀死。</li><li>Apps 不应该将唤醒作为一个机会去处理跟唤醒不相关的任务。</li></ul><h3 id="在后台执行长时间操作"><a href="#在后台执行长时间操作" class="headerlink" title="在后台执行长时间操作"></a>在后台执行长时间操作</h3><h4 id="状态保存和恢复"><a href="#状态保存和恢复" class="headerlink" title="状态保存和恢复"></a>状态保存和恢复</h4><p>对于一个给定的CBCentralManager对象， 系统记录下面内容：</p><ul><li>中心管理者的当时正在搜索的服务（并且包含开始扫描时所有指定扫描的可选项）</li><li>中心管理者当时正在尝试连接或者已经连接的外部设备</li><li>中心管理者当时订阅的特性</li></ul><p>对于CBPeripheralManager对象，系统记录下面内容：</p><ul><li>外部设备管理者当时正在广播的数据</li><li>外部设备管理者发布给设备数据库的服务</li><li>订阅外部设备服务特性值的中心设备。</li></ul><p>在创建中心管理者对象的时候就需要添加状态保存和恢复策略</p><pre><code class="hljs groovy">myCentralManager = [[CBCentralManager alloc] <span class="hljs-attr">initWithDelegate:</span>self <span class="hljs-attr">queue:</span>nil <span class="hljs-attr">options:</span>@&#123; <span class="hljs-attr">CBCentralManagerOptionRestoreIdentifierKey :</span> @“myCentralManagerIdentifer”&#125;];</code></pre><p>外部设备管理者使用CBPeripheralManagerOptionRestoreIdentiferKey 来初始化。</p><p>app重新启动时，可以获取所有系统保存的唯一标识</p><pre><code class="hljs objectivec">- (<span class="hljs-built_in">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)applicationdidFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions &#123;     <span class="hljs-built_in">NSArray</span> *centralManagerIdentifiers =        launchOptions[<span class="hljs-built_in">UIApplicationLaunchOptionsBluetoothCentralsKey</span>];    ...</code></pre><h4 id="实现合适的恢复代理方法"><a href="#实现合适的恢复代理方法" class="headerlink" title="实现合适的恢复代理方法"></a>实现合适的恢复代理方法</h4><blockquote><p>重要:对于存储状态并需要恢复状态的app,当app重启进入后台处理蓝牙相关事件时,先调用 centralManager:willRestoreState: 和 peripheralManager:willRestoreState: 方法.如果没有保存状态,则调用 centralManagerDidUpdateState: 和 peripheralManagerDidUpdateState: 代理方法.</p></blockquote><pre><code class="hljs pf">- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary *)<span class="hljs-keyword">state</span>&#123;        NSArray *peripherals = <span class="hljs-keyword">state</span>[CBCentralManagerRestoredStatePeripheralKey];    ...</code></pre><h4 id="更新初始化进程"><a href="#更新初始化进程" class="headerlink" title="更新初始化进程"></a>更新初始化进程</h4><pre><code class="hljs objectivec"><span class="hljs-built_in">NSUInteger</span> serviceUUIDIndex =    [peripheral.services indexOfObjectPassingTest:^<span class="hljs-built_in">BOOL</span>(CBService *obj,    <span class="hljs-built_in">NSUInteger</span> index, <span class="hljs-built_in">BOOL</span> *stop) &#123;        <span class="hljs-keyword">return</span> [obj.UUID isEqual:myServiceUUIDString];    &#125;]; <span class="hljs-keyword">if</span> (serviceUUIDIndex == <span class="hljs-built_in">NSNotFound</span>) &#123;    [peripheral discoverServices:@[myServiceUUIDString]];    ...</code></pre><h2 id="中心设备和远程外部设备交互最佳实践"><a href="#中心设备和远程外部设备交互最佳实践" class="headerlink" title="中心设备和远程外部设备交互最佳实践"></a>中心设备和远程外部设备交互最佳实践</h2><h3 id="注意广播的使用和电量消耗"><a href="#注意广播的使用和电量消耗" class="headerlink" title="注意广播的使用和电量消耗"></a>注意广播的使用和电量消耗</h3><p>尽可能最小化广播的使用.因为无线广播会给iOS设备硬件的电池寿命造成负面影响.</p><ul><li>只有需要的时候才扫描设备</li><li>只有必要时才去指明CBCentralManagerScanOptionAllowDuplicatesKey Option</li><li>正确地浏览外部设备数据<pre><code class="hljs scheme">[<span class="hljs-name">peripheral</span> discoverServices:@[<span class="hljs-name">firstServiceUUID</span>, secondServiceUUID]]<span class="hljs-comment">;</span></code></pre>查找服务特性也同样适用这种方式.</li><li>订阅经常变动的特性值</li><li>所有需求数据满足时取消设备连接<pre><code class="hljs ini"><span class="hljs-section">[myCentralManager cancelPeripheralConnection:peripheral]</span><span class="hljs-comment">;</span></code></pre></li></ul><h3 id="外部设备重连"><a href="#外部设备重连" class="headerlink" title="外部设备重连"></a>外部设备重连</h3><p>使用下面三种方式去重连外部设备:</p><ul><li>取回已知外部设备列表<br>使用 retrievePeripheralsWithIdentifiers: 方法.</li><li>取回当前系统连接的外部设备列表<br>使用 retriveConnectedPeripheralsWithServices: 方法.如果要查找的外部设备在列表中,连接它.</li><li>扫描并查找外部设备.<br>使用 scanForPeripheralsWithServices:options 方法.如果找到.连接它.</li></ul><p>下面是一个重连的流程示例:<br><img src="http://upload-images.jianshu.io/upload_images/3340896-6d4adcc223f2f43a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重连流程"></p><h2 id="设置本地设备作为外部设备最佳实践"><a href="#设置本地设备作为外部设备最佳实践" class="headerlink" title="设置本地设备作为外部设备最佳实践"></a>设置本地设备作为外部设备最佳实践</h2><h3 id="广播时要考虑的内容"><a href="#广播时要考虑的内容" class="headerlink" title="广播时要考虑的内容"></a>广播时要考虑的内容</h3><p>遵循广播数据限制.<br>当创建一个广播字典时,只能指定 CBAdvertisementDataLocalNameKey, CBAdvertisementDataServiceUUIDsKey.如果指定其他key会报错.<br>同样广播数据占用的空间也要限制.至多使用28字节的空间来初始化广播数据.</p><p>仅在需要的时候去广播数据,使用下面方法来停止广播</p><pre><code class="hljs ini"><span class="hljs-section">[myPeripheralManager stopAdvetising]</span><span class="hljs-comment">;</span></code></pre><p>让用户来决定何时广播</p><h3 id="配置外部设备特性"><a href="#配置外部设备特性" class="headerlink" title="配置外部设备特性"></a>配置外部设备特性</h3><p>下面两个分组帮助我们在需要执行以下任务是提供一些指导:</p><ul><li>允许链接的中心设备订阅您的特性</li><li>保护敏特性值,防止未配对中心设备的访问</li></ul><p>配置特性来支持通知</p><pre><code class="hljs groovy">myCharacteristic = [[CBMutableCharacteristic alloc] <span class="hljs-attr">initWithType:</span>myCharacteristicUUID <span class="hljs-attr">properties:</span>CBCharacteristicPropertyRead | CBCharacteristicPropertyNotify <span class="hljs-attr">value:</span>nil <span class="hljs-attr">permissions:</span>CBAttributePermissionsReadable];</code></pre><p>要求一个配对设备来访问敏感数据</p><pre><code class="hljs groovy">emailCharacterristic = [[CBMutableCharacteristic alloc] <span class="hljs-attr">initWithType:</span>emailCharacteristicUUID <span class="hljs-attr">properties:</span>CBCharacteristicPropertyRead | CBCharacteristicPropertyNotifyEncryptionRequired <span class="hljs-attr">value:</span>nil <span class="hljs-attr">permission:</span>CBAttributePermissionsReadEncryptionRequired];</code></pre><h1 id="项目Demo"><a href="#项目Demo" class="headerlink" title="项目Demo"></a>项目Demo</h1><p><a href="https://github.com/913868456/OCDemo">蓝牙4.0 Core Bluetooth Demo</a><br>上面链接是 <strong>Core Bluetooth</strong> 编程的Demo，能够对<strong>Core Bluetooth</strong> 有一个基本的了解。本项目使用一个蓝牙手环作为测试设备，读取蓝牙手环内的一些服务。如果想要使用其他蓝牙设备运行项目，把 <strong>“MH08”</strong> 替换为自己的设备名称前缀即可。</p><pre><code class="hljs objectivec"><span class="hljs-keyword">if</span> ([peripheral.name hasPrefix:<span class="hljs-string">@&quot;MH08&quot;</span>] ) &#123;       <span class="hljs-keyword">self</span>.bandPeripheral = peripheral;        <span class="hljs-comment">//强引用外部设备对象,否则会释放</span>       [<span class="hljs-keyword">self</span>.centralManager stopScan];          <span class="hljs-comment">//发现指定外设后,为了保护电池寿命和节约电量,中心管理者停止扫描</span>       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;链接外部设备: %@&quot;</span>, peripheral.name);       [<span class="hljs-keyword">self</span>.centralManager connectPeripheral:peripheral options:<span class="hljs-literal">nil</span>];   &#125;</code></pre><h1 id="GitHub-优秀开源"><a href="#GitHub-优秀开源" class="headerlink" title="GitHub 优秀开源"></a>GitHub 优秀开源</h1><p>由于使用官方提供的API编程特别凌乱，所以Github上有优秀开发者对其进行了封装。<br>详情请看<a href="https://github.com/coolnameismy/BabyBluetooth">BabyBluetooth </a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1">Core Bluetooth Programming Guide</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreBluetooth</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Block编程</title>
    <link href="/blog/2017/12/19/iOS/Block-%E7%BC%96%E7%A8%8B/"/>
    <url>/blog/2017/12/19/iOS/Block-%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Block对象是一个C语言层面的语法和运行时特色.Block类似于标准的C函数,但是除了包含可执行代码之外，它们还可以包含变量绑定到自动(栈)或托管(堆)内存。因此，Block可以维护一组状态(数据)，以便在执行时影响行为。</p><p>可以使用block组成函数表达式.这些表达式可以传递给API,可选地存储,并且通过多线程使用.Block作为一个回调非常有用.因为Block不仅可以包含在回调上执行的代码,还可以包含执行过程中需要用到的数据.</p><p>在OS X v10.6 和 iOS 4.0 之后可以使用block. block runtime 是 开源的,并且在 <a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/">LLVM’s compiler-rt subproject respository</a>中可以找到<br>Block同样被表示为标准的C语言工作组.由于Objective-C 和 C ++ 都是派生自C. Block在这三种语言中都能使用.</p><p>通过阅读这个文档去学习什么是block对象,如何在C,C++,OC中使用.</p><p>这篇文档的组成</p><p>这个文档包含以下章节:</p><ul><li><a href="">开始使用Block</a> 提供关于Block的介绍一个快速.实用的使用.</li><li><a href="">概念通览</a> 提供关于Block概念方面的介绍</li><li><a href="">声明和创建Block</a> 展示如何声明block变量和如何实现block</li><li><a href="">Block 和 变量</a> 描述了Block和变量之间的交互,还有定义__block存储类型的修改者.</li><li><a href="">使用Block</a> 阐述了Block的多种使用方式</li></ul><h1 id="开始使用Block"><a href="#开始使用Block" class="headerlink" title="开始使用Block"></a>开始使用Block</h1><p>下面内容帮助您使用实用的例子开始使用Block.</p><h2 id="声明和使用一个Block"><a href="#声明和使用一个Block" class="headerlink" title="声明和使用一个Block"></a>声明和使用一个Block</h2><p>使用^操作符去声明一个block变量并且去表示一个block字面量的开始.Block内容包含在{}中.正如这个例子中展示的(跟在C语言中一样, ;表示声明的结束):</p><pre><code class="hljs dart"><span class="hljs-built_in">int</span> multiplier = <span class="hljs-number">7</span>;<span class="hljs-built_in">int</span> (^myBlock)(<span class="hljs-built_in">int</span>)  = ^(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">num</span> * multiplier;&#125;;</code></pre><p>示例可以用下图来阐述:</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-2b3f81f0fddab136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p><p>注意block能够在它定义域内作为变量使用.如果你声明一个block变量,你可以像使用函数一样使用它.</p><pre><code class="hljs dart"><span class="hljs-built_in">int</span> multiplier = <span class="hljs-number">7</span>;<span class="hljs-built_in">int</span> (^myBlock)(<span class="hljs-built_in">int</span>) = ^(<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">num</span> * multiplier;  &#125;;printf(<span class="hljs-string">&quot;%d&quot;</span>, myBlock(<span class="hljs-number">3</span>));<span class="hljs-comment">// prints &quot;21&quot;</span></code></pre><h2 id="直接使用一个Block"><a href="#直接使用一个Block" class="headerlink" title="直接使用一个Block"></a>直接使用一个Block</h2><p>在许多情况下,您不需要声明block变量;只需要在需要作为参数的地方简单写一个block字面量即可.下面的例子使用 qsort_b 函数.qsort_b 函数类似于标准的 qsort_r 函数,但是携带一个block作为最后的参数.</p><pre><code class="hljs nim"><span class="hljs-built_in">char</span> *myCharacters[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&quot;TomJohn&quot;</span>, <span class="hljs-string">&quot;George&quot;</span>, <span class="hljs-string">&quot;Charles codomine&quot;</span>&#125;;qsort_b(myCharacters, <span class="hljs-number">3</span>, sizeof(<span class="hljs-built_in">char</span> *), ^(<span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span> *l, <span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span> *r)&#123;       <span class="hljs-built_in">char</span> *left = * (<span class="hljs-built_in">char</span> **)l;   <span class="hljs-built_in">char</span> *right = *(cahr **)r;      <span class="hljs-keyword">return</span> strncmp(left, right, l);    &#125;);// myCharacters <span class="hljs-keyword">is</span> now &#123;<span class="hljs-string">&quot;Charles Condomine&quot;</span>, <span class="hljs-string">&quot;George&quot;</span>, <span class="hljs-string">&quot;TomJohn&quot;</span>&#125;</code></pre><h2 id="Blocks-with-Cocoa"><a href="#Blocks-with-Cocoa" class="headerlink" title="Blocks with Cocoa"></a>Blocks with Cocoa</h2><p>在Cocoa框架下的一些方法会携带一个block作为参数,通常用来在一个集合内对象执行操作,或者作为一个操作结束后的回调来使用.下面的例子展示了如何在NSArray的<code>sortedArrayUsingComparator:</code>方法中使用一个Block.该方法携带单个参数-Block.为了方面阐述.在这个例子中,block被定义为一个NSComparator类型的本地变量:</p><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *stringsArray = @[<span class="hljs-string">@&quot;string 1&quot;</span>, <span class="hljs-string">@&quot;String 21&quot;</span>, <span class="hljs-string">@&quot;string 12&quot;</span>, <span class="hljs-string">@&quot;String 11&quot;</span>, <span class="hljs-string">@&quot;String 02&quot;</span>];<span class="hljs-keyword">static</span> <span class="hljs-built_in">NSStringCompareOptions</span> comparisonOptions = <span class="hljs-built_in">NSCaseInsensitiveSearch</span> | <span class="hljs-built_in">NSNumericSearch</span> | <span class="hljs-built_in">NSWidthInsensitiveSearch</span> | <span class="hljs-built_in">NSForceOrderingSearch</span>;<span class="hljs-built_in">NSLocale</span> *currentLocale = [<span class="hljs-built_in">NSLocale</span> currentLocale];<span class="hljs-built_in">NSComparator</span> finderSortBlock = ^(<span class="hljs-keyword">id</span> string1, <span class="hljs-keyword">id</span> stirng2) &#123;        <span class="hljs-built_in">NSRange</span> string1Range = <span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, [string1 length]);    <span class="hljs-keyword">return</span> [stirng1 compare:string2 options:comparisonOptions range:string1Range locale:currentLocale];&#125;;<span class="hljs-built_in">NSArray</span> *finderSortArray = [stringsArray sortedArrayUsingComparator:finderSortBlock];<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;finderSortArray:%@&quot;</span>, finderSortArray);<span class="hljs-comment">/*</span><span class="hljs-comment"> </span><span class="hljs-comment"> output:</span><span class="hljs-comment"> </span><span class="hljs-comment"> finderSortArray: (</span><span class="hljs-comment"> </span><span class="hljs-comment">    &quot;string 1&quot;,</span><span class="hljs-comment">    &quot;String 02&quot;,</span><span class="hljs-comment">    &quot;String 11&quot;,</span><span class="hljs-comment">    &quot;string 12&quot;,</span><span class="hljs-comment">    &quot;String 21&quot;</span><span class="hljs-comment"> )</span><span class="hljs-comment"> */</span></code></pre><h2 id="block-变量"><a href="#block-变量" class="headerlink" title="__block 变量"></a>__block 变量</h2><p>block的一个强大的特性是在同一作用域内,它们能够修改变量.使用__block存储类型修饰符标记一个在block中可以修改的外部变量. 改变 <strong>Blocks with Cocoa</strong>中的示例,可以使用一个block变量去计算多少个字符串被用来比较. 为了阐述方便,在这个例子中直接使用block,使用<strong>currentLocale</strong>作为block中的一个只读变量.</p><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *stringsArray = @[ <span class="hljs-string">@&quot;string 1&quot;</span>,                          <span class="hljs-string">@&quot;String 21&quot;</span>, <span class="hljs-comment">// &lt;-</span>                          <span class="hljs-string">@&quot;string 12&quot;</span>,                          <span class="hljs-string">@&quot;String 11&quot;</span>,                          <span class="hljs-string">@&quot;Strîng 21&quot;</span>, <span class="hljs-comment">// &lt;-</span>                          <span class="hljs-string">@&quot;Striñg 21&quot;</span>, <span class="hljs-comment">// &lt;-</span>                          <span class="hljs-string">@&quot;String 02&quot;</span> ]; <span class="hljs-built_in">NSLocale</span> *currentLocale = [<span class="hljs-built_in">NSLocale</span> currentLocale];__block <span class="hljs-built_in">NSUInteger</span> orderedSameCount = <span class="hljs-number">0</span>; <span class="hljs-built_in">NSArray</span> *diacriticInsensitiveSortArray = [stringsArray sortedArrayUsingComparator:^(<span class="hljs-keyword">id</span> string1, <span class="hljs-keyword">id</span> string2) &#123;     <span class="hljs-built_in">NSRange</span> string1Range = <span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, [string1 length]);    <span class="hljs-built_in">NSComparisonResult</span> comparisonResult = [string1 compare:string2 options:<span class="hljs-built_in">NSDiacriticInsensitiveSearch</span> range:string1Range locale:currentLocale];     <span class="hljs-keyword">if</span> (comparisonResult == <span class="hljs-built_in">NSOrderedSame</span>) &#123;        orderedSameCount++;    &#125;    <span class="hljs-keyword">return</span> comparisonResult;&#125;]; <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;diacriticInsensitiveSortArray: %@&quot;</span>, diacriticInsensitiveSortArray);<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;orderedSameCount: %d&quot;</span>, orderedSameCount); <span class="hljs-comment">/*</span><span class="hljs-comment">Output:</span><span class="hljs-comment"> </span><span class="hljs-comment">diacriticInsensitiveSortArray: (</span><span class="hljs-comment">    &quot;String 02&quot;,</span><span class="hljs-comment">    &quot;string 1&quot;,</span><span class="hljs-comment">    &quot;String 11&quot;,</span><span class="hljs-comment">    &quot;string 12&quot;,</span><span class="hljs-comment">    &quot;String 21&quot;,</span><span class="hljs-comment">    &quot;Str\U00eeng 21&quot;,</span><span class="hljs-comment">    &quot;Stri\U00f1g 21&quot;</span><span class="hljs-comment">)</span><span class="hljs-comment">orderedSameCount: 2</span><span class="hljs-comment">*/</span></code></pre><p>详细内容请看 <strong>Blocks 和 变量</strong> 这一章节</p><h1 id="概念通览"><a href="#概念通览" class="headerlink" title="概念通览"></a>概念通览</h1><p>Block对象为您提供一种方式去创建一个ad hoc函数体作为在C,和C的衍生语言中的表达方式.在其他的语言和环境中.一个block对象有时也叫做闭包.</p><h2 id="Block功能"><a href="#Block功能" class="headerlink" title="Block功能"></a>Block功能</h2><p>block是一个内联的匿名代码集合:</p><ul><li>像函数一样有一个类型参数列表</li><li>拥有推导的或者声明的返回类型</li><li>能够捕获定义作用域内的状态</li><li>能够可选地修改作用域内的状态</li><li>能够与在同一作用域内定义的其他Block共享修改的可能性</li><li>能够在(栈结构)已经被销毁后,仍然可以继续分享和修改(栈结构)下定义的状态.</li></ul><p>您可以拷贝一个block甚至传递它到其他线程用来延迟执行.在生命周期内编译器和运行时将所有被引用的变量保存副本。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Block 表示一个小的,内部包含的代码片段.正因为这样,他们常被用来作为执行并行工作单元的一种方式.或者作为集合中的项目,或者作为一个操作结束后的回调.</p><p>Blocks作为传统的回调函数主要有两个原因:</p><ol><li>它们允许您在方法实现的上下文中执行编写的代码.<br>Block通常作为框架方法的参数</li><li>它们允许作为方法的局部变量.<br>与其使用需要一个包含所有需要执行操作的上下文信息的数据结构的回调函数，您只需直接使用该局部变量.</li></ol><h1 id="声明和创建-Blocks"><a href="#声明和创建-Blocks" class="headerlink" title="声明和创建 Blocks"></a>声明和创建 Blocks</h1><h2 id="声明一个Block-引用"><a href="#声明一个Block-引用" class="headerlink" title="声明一个Block 引用"></a>声明一个Block 引用</h2><p>Block变量持有Block的引用.使用声明一个函数指针类似的语法声明它们.除了使用^代替*.block类型和C类型系统兼容.下面的block变量声明都是有效的:</p><pre><code class="hljs lisp">void (^blockReturningVoidWithVoidArgument)(<span class="hljs-name">void</span>)<span class="hljs-comment">;</span>int (^blockReturningIntWithIntAndCharArguments)(<span class="hljs-name">int</span>, char)<span class="hljs-comment">;</span>void (^arrayOfTenBlocksReturningVoidWithIntArgument[<span class="hljs-number">10</span>])(<span class="hljs-name">int</span>)<span class="hljs-comment">;</span></code></pre><p>Block同样支持可变参数.一个block如果不含参数必须在参数列表中指明void.</p><p>在许多地方,使用一个类型别名声明一个Block类型能够更好地使用block.</p><pre><code class="hljs protobuf">typedef <span class="hljs-built_in">float</span> (MyBlockType)(<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>);MyBlockType myFirstBlock = <span class="hljs-comment">// ...;</span>MyBlockType mySecondBlock = <span class="hljs-comment">// ...;</span></code></pre><h2 id="创建一个Block"><a href="#创建一个Block" class="headerlink" title="创建一个Block"></a>创建一个Block</h2><p>使用^操作符表示一个block字面量的开始.它后面通常使用()来包含一个参数列表.block体包含在{}中.下面的例子定义了一个简单的block,block末尾用;结尾.</p><pre><code class="hljs nim"><span class="hljs-built_in">float</span> (^oneFrom)(<span class="hljs-built_in">float</span>);oneFrom = ^(<span class="hljs-built_in">float</span> aFloat) &#123;    <span class="hljs-built_in">float</span> <span class="hljs-literal">result</span> = aFloat - <span class="hljs-number">1</span>.<span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> <span class="hljs-literal">result</span>;    &#125;;</code></pre><p>如果没有明确声明一个Block表达式的返回值类型,它会自动推导其类型.如果返回值是被推导的并且参数列表是void,您也可以忽略void参数.当出现多个返回语句时，它们必须完全匹配(在必要时使用转换)。</p><h2 id="全局Block"><a href="#全局Block" class="headerlink" title="全局Block"></a>全局Block</h2><p>在文件层面,您可以使用一个block作为全局字面量</p><pre><code class="hljs angelscript">#<span class="hljs-keyword">import</span> &lt;stdio.h&gt;<span class="hljs-built_in">int</span> GlobalInt = <span class="hljs-number">0</span>;<span class="hljs-built_in">int</span> (^getGlobalInt)(<span class="hljs-built_in">void</span>) = ^(<span class="hljs-keyword">return</span> GlobalInt;);</code></pre><h1 id="Blocks-和-变量"><a href="#Blocks-和-变量" class="headerlink" title="Blocks 和 变量"></a>Blocks 和 变量</h1><p>本节主要描述blocks和变量之间的交互,包括内存管理.</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>在block体的代码内,变量可以用5种不同方式处理.<br>您可以参考三种标准的变量类型,就像从函数中得到的那样.</p><ul><li>全局变量,包含静态局部变量</li><li>全局函数(技术上来讲不是变量)</li><li>来自作用域内的局部变量和参数</li></ul><p>Blocks同样支持两种其他类型的变量:</p><p>1.在函数层面是__block 变量.__block变量在block内是可变的,如果正在引用的block被拷贝到堆上,__block变量会被保存起来.<br>2.<strong>const</strong> 导入的变量.</p><p>最后,在一个方法实现内,block可能会引用OC实例变量—请看下面的 <a href="">对象和Block变量</a> 章节.</p><p>下面的规则适用于block中使用的变量:</p><ol><li>全局变量是可访问的,包含作用域内存在的静态变量.</li><li>传递到block中的参数是可访问的(就像函数的参数一样)</li><li>作用域内的栈变量(非静态变量)被捕获作为常量.       (block内使用的外部栈存储的变量(非静态变量)在block内部会作为常量来使用)<br>变量的值在程序中block表达式的位置上捕获的.在嵌套block中,该值从最近的作用域内被捕获.</li><li>__block修饰的局部变量是通过引用来提供访问的,并且这些变量在block内部是可修改的.<br>任何作用域内的改变都会被映射,包括在同一作用域内其他定义的block的改变同样也会被映射.这些内容在”__block 存储类型”中被详细讨论.</li><li>block作用域内声明的局部变量,其行为跟函数内的局部变量几乎相同.<br>block的每次调用都会提供那个变量的新的副本. 这些变量依次作为在block内的常量或者引用变量来使用.</li></ol><p>下面的例子阐述了非静态局部变量的使用:</p><pre><code class="hljs perl"><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span> = <span class="hljs-number">123</span>;vooid (^printXAndY)(<span class="hljs-keyword">int</span>) = ^(<span class="hljs-keyword">int</span> <span class="hljs-keyword">y</span>) &#123;  <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, <span class="hljs-keyword">x</span>,<span class="hljs-keyword">y</span>);  &#125;;printXAndY(<span class="hljs-number">456</span>); <span class="hljs-regexp">//prints</span>: <span class="hljs-number">123</span> <span class="hljs-number">456</span></code></pre><p>如上所述, 试着在blocke内给x赋值会造成错误:</p><pre><code class="hljs gml">int <span class="hljs-symbol">x</span> = <span class="hljs-number">123</span>;void (^printXAndY)(int) = ^(int <span class="hljs-symbol">y</span>) &#123;        <span class="hljs-symbol">x</span> = <span class="hljs-symbol">x</span> + <span class="hljs-symbol">y</span>; <span class="hljs-comment">// error</span>    printf(<span class="hljs-string">&quot;%d %d&quot;</span>, <span class="hljs-symbol">x</span>, <span class="hljs-symbol">y</span>);  &#125;;</code></pre><p>想要在block内部对外部变量进行修改,您可以使用__block存储类型修饰符.</p><h2 id="block-存储类型"><a href="#block-存储类型" class="headerlink" title="__block 存储类型"></a>__block 存储类型</h2><p>您可以使用__block 修饰符使block外部导入的变量在其内部可修改.__block存储类似于局部变量的寄存器,内部的自动,静态存储类型。<br>存储区域内的__block变量会与作用域内的变量、所有的block、block副本之间共享.因此,在末尾声明的block副本存在,那么在栈结构销毁时,这块内存将会幸存.同一作用域内的多个block可以同时使用一个共享变量.<br>作为优化.block存储从栈开始,就像block本身一样.如果使用Block_copy复制,则会将变量复制到堆中.因此,__block变量的地址可能随时变化.<br>对于__block变量有两个进一步的限制:它们不能是可变数组，也不能是包含C99可变长度数组的结构体。</p><p>下面的例子阐述了一个__block变量的使用:</p><pre><code class="hljs gml">__block int <span class="hljs-symbol">x</span> = <span class="hljs-number">123</span>; <span class="hljs-comment">// x lives in block storage</span>void (^printXAndY)(int) = ^(int <span class="hljs-symbol">y</span>) &#123;        <span class="hljs-symbol">x</span> = <span class="hljs-symbol">x</span> + <span class="hljs-symbol">y</span>;    printf(<span class="hljs-string">&quot;%d %D\n&quot;</span>, <span class="hljs-symbol">x</span>, <span class="hljs-symbol">y</span>);&#125;;printXAndY(<span class="hljs-number">456</span>); <span class="hljs-comment">// prints: 579 456</span><span class="hljs-comment">// x is now 579</span></code></pre><p>下面的例子展示了block和几种类型变量的交互:</p><pre><code class="hljs objectivec"><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSInteger</span> CounterGlobal;<span class="hljs-keyword">static</span> <span class="hljs-built_in">NSInteger</span> CounterStatic;&#123;    <span class="hljs-built_in">NSInteger</span> localCounter = <span class="hljs-number">42</span>;    __block <span class="hljs-keyword">char</span> localCharacter;        <span class="hljs-keyword">void</span> (^aBlock)(<span class="hljs-keyword">void</span>) = ^(<span class="hljs-keyword">void</span>) &#123;      ++CounterGlobal;        ++CounterStatic;      CounterGlobal = localCounter; <span class="hljs-comment">// localCounter fixed at block creation</span>      localCharacter = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// sets localCharacter in enclosing scope    </span>    &#125;;        ++localCounter; <span class="hljs-comment">//unseen by the block</span>    localCharacter = <span class="hljs-string">&#x27;b&#x27;</span>;        aBlock();  <span class="hljs-comment">// execute the block </span>    <span class="hljs-comment">// localCharacter now &#x27;a&#x27;</span>&#125;</code></pre><h2 id="对象和Block变量"><a href="#对象和Block变量" class="headerlink" title="对象和Block变量"></a>对象和Block变量</h2><h3 id="Objective-C-对象"><a href="#Objective-C-对象" class="headerlink" title="Objective-C 对象"></a>Objective-C 对象</h3><p>当一个block被复制,它会对block内的对象变量创建强引用.如果在方法实现内使用一个block:</p><ul><li>如果您通过引用访问一个实例变量,会创建一个强引用指向self;</li><li>如果您通过值访问一个对象变量,会创建一个强引用指向该变量.</li></ul><p>下面的例子阐述了两个不同的情况:</p><pre><code class="hljs xquery">dispathch_async(queue, ^&#123;      // instanceVariable <span class="hljs-literal">is</span> userd <span class="hljs-keyword">by</span> reference, a strong reference <span class="hljs-literal">is</span> made <span class="hljs-keyword">to</span> self       doSomethingWithObject(instanceVariable);    &#125;);id localVariable = instanceVariable;dispatch_async(queue, ^&#123;   /*       localVariable <span class="hljs-literal">is</span> used <span class="hljs-keyword">by</span> <span class="hljs-keyword">value</span>, a strong reference <span class="hljs-literal">is</span> made <span class="hljs-keyword">to</span> localvariable (<span class="hljs-keyword">and</span><span class="hljs-built_in"> not</span> <span class="hljs-keyword">to</span> self)      */    doSomethingWithObject(localVariable);    &#125;);</code></pre><p>如果想要在block内修改外部的局部对象变量,您可以使用__block标记该变量.</p><h3 id="C-对象"><a href="#C-对象" class="headerlink" title="C++对象"></a>C++对象</h3><p>一般来说，可以在一个block中使用c++对象。在成员函数中，对成员变量和函数的引用通过隐式导入该指针，因此看起来是可变的。如果一个block被复制，有两个考虑因素:</p><p>如果您有一个__block存储类，它是一个基于堆栈的c++对象，那么通常使用的是copy构造函数。<br>如果您在一个block中使用任何其他c++基于堆栈的对象，那么它必须有一个const copy构造函数。然后使用该构造函数复制c++对象。</p><h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>当您拷贝一个block时,在block内的其他block引用都会被拷贝如果必要的话.如果您在block内拥有一个block变量或者引用了一个block,那个block将会被拷贝.</p><h1 id="使用Blocks"><a href="#使用Blocks" class="headerlink" title="使用Blocks"></a>使用Blocks</h1><h2 id="调用一个Block"><a href="#调用一个Block" class="headerlink" title="调用一个Block"></a>调用一个Block</h2><p>声明一个block变量,将其作为一个函数,如下所示:</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> (^oneFrom)(<span class="hljs-built_in">int</span>) = ^(<span class="hljs-built_in">int</span> anInt)&#123;        <span class="hljs-keyword">return</span> anInt - <span class="hljs-number">1</span>;&#125;;printf(<span class="hljs-string">&quot;1 from 10 is %d&quot;</span>, oneFrom(<span class="hljs-number">10</span>));<span class="hljs-comment">// Prints &quot;1 from 10 is 9&quot;</span><span class="hljs-built_in">float</span> (^distanceTraveled)(<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>) = ^(<span class="hljs-built_in">float</span> startingSpeed, <span class="hljs-built_in">float</span> acceleration, <span class="hljs-built_in">float</span> time) &#123;        <span class="hljs-built_in">float</span> distance = (startingSpeed * time) + (<span class="hljs-number">0.5</span> * acceleration * time * time);    <span class="hljs-keyword">return</span> distance;&#125;;<span class="hljs-built_in">float</span> howFar = distanceTraveled(<span class="hljs-number">0.0</span>, <span class="hljs-number">9.8</span>, <span class="hljs-number">1.0</span>);<span class="hljs-comment">// howFar = 4.9</span></code></pre><h2 id="使用Block作为函数参数"><a href="#使用Block作为函数参数" class="headerlink" title="使用Block作为函数参数"></a>使用Block作为函数参数</h2><pre><code class="hljs nim"><span class="hljs-built_in">char</span> *myCharacters[<span class="hljs-number">3</span>] = &#123; <span class="hljs-string">&quot;TomJohn&quot;</span>, <span class="hljs-string">&quot;George&quot;</span>, <span class="hljs-string">&quot;Charles Condomine&quot;</span> &#125;; qsort_b(myCharacters, <span class="hljs-number">3</span>, sizeof(<span class="hljs-built_in">char</span> *), ^(<span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span> *l, <span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span> *r) &#123;    <span class="hljs-built_in">char</span> *left = *(<span class="hljs-built_in">char</span> **)l;    <span class="hljs-built_in">char</span> *right = *(<span class="hljs-built_in">char</span> **)r;    <span class="hljs-keyword">return</span> strncmp(left, right, <span class="hljs-number">1</span>);&#125;);// <span class="hljs-type">Block</span> implementation ends at <span class="hljs-string">&quot;&#125;&quot;</span> // myCharacters <span class="hljs-keyword">is</span> now &#123; <span class="hljs-string">&quot;Charles Condomine&quot;</span>, <span class="hljs-string">&quot;George&quot;</span>, <span class="hljs-string">&quot;TomJohn&quot;</span> &#125;</code></pre><p>注意block包含在函数的参数列表中.</p><h2 id="使用Block作为方法参数"><a href="#使用Block作为方法参数" class="headerlink" title="使用Block作为方法参数"></a>使用Block作为方法参数</h2><p>Cocoa 提供了许多使用block的方法. 您将一个block作为方法参数使用就像使用其他参数一样. </p><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *array = @[<span class="hljs-string">@&quot;A&quot;</span>, <span class="hljs-string">@&quot;B&quot;</span>, <span class="hljs-string">@&quot;C&quot;</span>, <span class="hljs-string">@&quot;A&quot;</span>, <span class="hljs-string">@&quot;B&quot;</span>, <span class="hljs-string">@&quot;Z&quot;</span>, <span class="hljs-string">@&quot;G&quot;</span>, <span class="hljs-string">@&quot;are&quot;</span>, <span class="hljs-string">@&quot;Q&quot;</span>];<span class="hljs-built_in">NSSet</span> *filterSet = [<span class="hljs-built_in">NSSet</span> setWithObjects: <span class="hljs-string">@&quot;A&quot;</span>, <span class="hljs-string">@&quot;Z&quot;</span>, <span class="hljs-string">@&quot;Q&quot;</span>, <span class="hljs-literal">nil</span>]; <span class="hljs-built_in">BOOL</span> (^test)(<span class="hljs-keyword">id</span> obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> *stop); test = ^(<span class="hljs-keyword">id</span> obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> *stop) &#123;     <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">5</span>) &#123;        <span class="hljs-keyword">if</span> ([filterSet containsObject: obj]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;; <span class="hljs-built_in">NSIndexSet</span> *indexes = [array indexesOfObjectsPassingTest:test]; <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;indexes: %@&quot;</span>, indexes); <span class="hljs-comment">/*</span><span class="hljs-comment">Output:</span><span class="hljs-comment">indexes: &lt;NSIndexSet: 0x10236f0&gt;[number of indexes: 2 (in 2 ranges), indexes: (0 3)]</span><span class="hljs-comment">*/</span></code></pre><pre><code class="hljs objectivec">__block <span class="hljs-built_in">BOOL</span> found = <span class="hljs-literal">NO</span>;<span class="hljs-built_in">NSSet</span> *aSet = [<span class="hljs-built_in">NSSet</span> setWithObjects: <span class="hljs-string">@&quot;Alpha&quot;</span>, <span class="hljs-string">@&quot;Beta&quot;</span>, <span class="hljs-string">@&quot;Gamma&quot;</span>, <span class="hljs-string">@&quot;X&quot;</span>, <span class="hljs-literal">nil</span>];<span class="hljs-built_in">NSString</span> *string = <span class="hljs-string">@&quot;gamma&quot;</span>; [aSet enumerateObjectsUsingBlock:^(<span class="hljs-keyword">id</span> obj, <span class="hljs-built_in">BOOL</span> *stop) &#123;    <span class="hljs-keyword">if</span> ([obj localizedCaseInsensitiveCompare:string] == <span class="hljs-built_in">NSOrderedSame</span>) &#123;        *stop = <span class="hljs-literal">YES</span>;        found = <span class="hljs-literal">YES</span>;    &#125;&#125;]; <span class="hljs-comment">// At this point, found == YES</span></code></pre><h2 id="拷贝Blocks"><a href="#拷贝Blocks" class="headerlink" title="拷贝Blocks"></a>拷贝Blocks</h2><p>通常下,不需要copy或者retain一个block.当想要在block销毁后仍使用block时，才需要copy这个block.拷贝会将一个block移到堆中.</p><p>可以使用c函数拷贝和释放block”</p><pre><code class="hljs abnf">Block_copy()<span class="hljs-comment">;</span>Block_release()<span class="hljs-comment">;</span></code></pre><p>为避免内存泄露,Block_copy()和Block_release()必须成对出现.</p><h2 id="格式注意"><a href="#格式注意" class="headerlink" title="格式注意"></a>格式注意</h2><p>block字面量是通过一个局部栈数据结构的地址来表示一个block,因此局部栈数据结构的作用域仅限于大括号内。所以应避免以下方式的使用：</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dontDoThis</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">void</span> (^blockArray[<span class="hljs-number">3</span>])(<span class="hljs-keyword">void</span>);  <span class="hljs-comment">// an array of 3 block references</span>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;        blockArray[i] = ^&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, %d\n&quot;</span>, i); &#125;;        <span class="hljs-comment">// WRONG: The block literal scope is the &quot;for&quot; loop.</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dontDoThisEither</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">void</span> (^block)(<span class="hljs-keyword">void</span>);     <span class="hljs-keyword">int</span> i = <span class="hljs-built_in">random</span>():    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1000</span>) &#123;        block = ^&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got i at: %d\n&quot;</span>, i); &#125;;        <span class="hljs-comment">// WRONG: The block literal scope is the &quot;then&quot; clause.</span>    &#125;    <span class="hljs-comment">//...</span>&#125;</code></pre><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>您可以设置断点来执行block中的单步操作.也可以在一个GDB会话中使用invoke-block调用一个block.如下所述:</p><pre><code class="hljs smali">$<span class="hljs-built_in"> invoke-block </span>myBlock 10 20</code></pre><p>如果您想要传一个c字符串,必须引用它.举例来说,传递一个 this string 给 doSomethingWithString block,按下面方式去写:</p><pre><code class="hljs smali">$<span class="hljs-built_in"> invoke-block </span>doSomethingWithString <span class="hljs-string">&quot;\&quot;</span>this string \<span class="hljs-string">&quot;&quot;</span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在Objective-C中,使用block,注意以下几点:</p><ul><li>使用类型别名来定义一个Block类型,使用起来更方便.</li><li>__block修饰的外部变量,在block内部可以被修改.（修饰的变量不能是可变数组，也不能是包含C99可变长度数组的结构体）</li><li>每次调用block,都会拷贝该block一次,如果嵌套block,那么内部的block也会被拷贝.</li><li>block进行拷贝操作时,会给内部对象创建一个强引用.如果该对象是实例变量,则创建self的强引用,如果是对象变量,则创建该对象变量的强引用.</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502-CH1-SW1">Blocks Programming Topics</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Block</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVO</title>
    <link href="/blog/2017/12/17/iOS/KVO/"/>
    <url>/blog/2017/12/17/iOS/KVO/</url>
    
    <content type="html"><![CDATA[<h1 id="Key-Value-Observing-Programming-Guide"><a href="#Key-Value-Observing-Programming-Guide" class="headerlink" title="Key-Value Observing Programming Guide"></a>Key-Value Observing Programming Guide</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>键值观察是一种机制,该机制允许对象接收其他对象特定属性改变的通知.</p><blockquote><p>重要: 为了更好的了解键值观察,您必须理解<a href="http://www.jianshu.com/p/7f7360ae8e7b">键值编码</a></p></blockquote><p>一个简单的例子概述了应用中KVO的作用.假设有一个Person对象与一个Account对象相关,表示这个人在银行的存款账户.一个Person实例可能需要知道何时Account实例属性改变对该账户造成影响.比如收支,或者利率.</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-51f7b5abd6205136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p><p>使用KVO,首先确保对象兼容KVO.只要继承自NSObject的对象都是KVO兼容的.然后,必须注册一个观察者Person,观察Account对象实例.Peson发送一个<code>addObserver:forKeyPath:options:context:</code>消息给Account.<br><img src="http://upload-images.jianshu.io/upload_images/3340896-2ec2849c4a768671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注册观察者"></p><p>为了接受来自于Account的改变通知,Peson需要实现<code>observeValueForKeyPath:ofObject:change:context</code>方法,所有的观察者都需要实现.一旦注册的KeyPath对应的属性值发生改变,Account将会发送该消息给Person.Person然后基于改变的通知做出相应的响应.</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-6518b22626ca9474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送改变通知"></p><p>最后,当不在需要通知时,在对象销毁之前,使用<code>removeObser:forKeyPath:</code> 方法移除观察者.</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-3eddd2ec631247c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="移除观察者"></p><p>不像使用NSNotificationCenter通知那样,KVO没有一个中心对象给所有的观察者提供改变通知.一旦被观察的对象发生改变通知将会直接发送. NSObject提供了KVO的基本实现.</p><hr><h2 id="KVO注册"><a href="#KVO注册" class="headerlink" title="KVO注册"></a>KVO注册</h2><p>必须执行以下步骤来使对象接收一个KVO兼容属性的键值观察通知:</p><ul><li>注册观察者使用<code>addObserver:forKeyPath:options:context:</code></li><li>在观察者内部实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法去接收改变通知消息.</li><li>当不再需要接收消息时,使用<code>removeObserver:forKeyPath:</code>方法取消观察者.至少,在观察者从内存中释放前调用该方法.</li></ul><blockquote><p>重要: 不是所有的类的所有属性都是KVO兼容的.</p></blockquote><h3 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h3><p>一个进行观察的对象首先通过发送一个 <code>addObserver:forKeyPath:options:context: </code>消息注册自己和被观察的对象.来传递作为观察者的自身和观察的属性键路径.观察者额外指定一个可选参数和上下文指针用来管理通知方面的内容.</p><h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4><p>可选项参数,使用<code>|</code>位操作符来指定多个可选项.影响提供给通知的字典内容,该字典包含观察到的变动信息.并且影响通知的生成方式.</p><p>通过指定的<code>NSKeyValueObservingOptionOld</code>获取观察的属性改变前的值.通过<code>NSKeyValueObservingOptionNew</code>获取改变后新的属性值.</p><p>通过<code>NSKeyValueObservingOptionPrior</code>可选项,命令观察对象在属性改变前发送一个通知(另外在改变后也发送一个通知).改变信息的字典通过Key为<code>NSKeyValueChangeNotificationIsPriorKey</code>, Value为<code>NSNumber</code>表示的Yes对象的键值对,标明是一个预改变通知.当需要观察一个属性将要改变时,可以使用该可选项来发送通知.</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>在 <code>addObserver:forKeyPath:options:context:</code>消息中的上下文指针包含在相应通知下,传递回的任意数据.可以指定一个NULL类型的数据并且完全依靠键路径字符串去判断改变通知的来源.但是这种方法可能会造成一些问题.如果一个对象的父类出于某种原因也在观察同样的键路径下的属性.</p><p>一个更安全和更加可扩展的方法是使用上下文确保你接收的通知目的对象是观察者而不是其父类.<br>一个类中的特殊命名的静态变量指针可以组成一个好的上下文. <strong>Listing 1</strong> 展示一个为属性观察命名不同上下文的示例.</p><p><strong>Listing 1</strong> 创建上下文指针</p><pre><code class="hljs actionscript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *PersonAccountBalanceContext = &amp;PersonAccountBalanceContext;statci <span class="hljs-keyword">void</span> *PersonAccountInterestRateContext = &amp;PersonAccountInterestRateContext;</code></pre><p>Listing 2中的实例论证了一个Person实例如何使用给定的上下文指针注册它自己作为Account实例banlance和interestRate属性的观察者</p><p><strong>Listing 2</strong> 注册属性balance和interestRate的观察者</p><pre><code class="hljs groovy">- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">registerAsObserverForAccount:</span>(Account *)account&#123;        [account <span class="hljs-attr">addObserver:</span> self <span class="hljs-attr">forKeyPath:</span>@<span class="hljs-string">&quot;balance&quot;</span> <span class="hljs-attr">options:</span>(NSKeyValueObseringOptionNew | NSKeyValueObservingOptionOld) <span class="hljs-attr">context:</span> PersonAccountBalanceContext];        [account <span class="hljs-attr">addObserver:</span> self <span class="hljs-attr">forKeyPath:</span>@<span class="hljs-string">&quot;interestRate&quot;</span> <span class="hljs-attr">options:</span>(NSKeyValueObservingNew | NSKeyValueObservingOptionOld) <span class="hljs-attr">context:</span>PersonAccountINterestRateContext];    &#125;</code></pre><blockquote><p>注意:键值观察方法 <code>addObserver:forKeyPath:options;context:</code>对观察者,被观察对象,或者上下文,不持有强引用.如果需要的话,应该确保对观察者,被观察对象,和上下文的强引用.</p></blockquote><h3 id="接收一个改变的通知"><a href="#接收一个改变的通知" class="headerlink" title="接收一个改变的通知"></a>接收一个改变的通知</h3><p>当被观察的属性值发生变化时,观察者会接收到一个<code>observeValueForKeyPath:ofObject:change:context:</code> 消息.所有的观察者必须实现该方法.</p><p>被观察对象提供触发通知的键路径,它本身作为关联对象,包含更改细节的字典,以及在该键路径下注册的观察者时,提供的上下文指针.</p><p>更改内容字典入口<code>NSKeyValueChangeKindKey</code>提供发生的更改类型相关信息.如果观察的值已经发生改变,<code>NSKeyValueChangeKindKey</code>入口返回<code>NSKeyValueChangeSetting</code>.通过依赖注册的观察者指定的可选项.在更改内容字典中<code>NSKeyValueChangeOldKey</code>和<code>NSKeyValueChangeNewKey</code>包含观察属性改变前和改变后的值.如果属性是一个对象,则直接提供该值.如果属性是一个标量或者结构体,那么对应的值会包装在一个NSValue对象中.</p><p>如果观察的属性是一个一对多关系.<code>NSKeyValueChangeKindKey</code>入口也会表示是否该集合内的对象被插入,移除,或者替换.分别用<code>NSKeyValueChangeInsertion</code>,<code>NSKeyValueChangeRemoval</code>,<code>NSKeyValueChangeReplacement</code>表示.</p><p>更改内容字典入口<code>NSKeyValueChangeIndexesKey</code>是一个NSIndexSet对象.明确了在集合中更改的元素的所有下标.如果<code>NSKeyValueObservingOptionNew</code>或者<code>NSKeyValueObservingOptionOld</code>被指定作为观察者的可选项.那么<code>NSKeyValueChangeOldKey</code>和<code>NSKeyValueChageNewKey</code>在改变内容字典中用数组来包含关联对象改变前和改变后的值.</p><p>在Listing 3中的例子展示了 <em>Person</em> 观察者 <code>observeValueForKeyPath:ofObject:change:context:</code>方法的实现,并且记录了balance和interestRate属性的改变前后的值.</p><p><strong>Listing 3</strong> <code>observeValueForKeyPath:ofObject:change:context:</code>方法实现</p><pre><code class="hljs groovy">- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">observeValueForKeyPath:</span>(NSString *)keyPath <span class="hljs-attr">ofObject:</span>(id)object <span class="hljs-attr">change:</span>(NSDictionary *)change <span class="hljs-attr">context:</span>(<span class="hljs-keyword">void</span> *)context&#123;    <span class="hljs-keyword">if</span> (context == PersonAccountBalanceContext) &#123;                <span class="hljs-comment">// Do something with the balance...</span>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context == PersonAccountInterestRateContext)&#123;                <span class="hljs-comment">// Do something with the interest rate...</span>            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// Any unrecognized context must belong to super</span>                [<span class="hljs-built_in">super</span> <span class="hljs-attr">observeValueForKeyPath:</span>keyPath <span class="hljs-attr">ofObject:</span>object <span class="hljs-attr">change:</span>change <span class="hljs-attr">context:</span>context];            &#125;&#125;</code></pre><p>如果在注册观察者的时候指定一个NULL上下文,通过比对键路径来判断观察的内容改变情况.如果使用一个单一的上下文给所有观察的键路径,首先测试那个通知的上下文,然后使用键路径来匹配从而判断具体改变的内容.如果给每一个观察的间路径提供一个不同的上下文,正如这里论证的,遗传单一的指针做比较来告诉你是否该通知是发送给这个观察者,并且哪个键路径改变了.</p><p>在任何情况下,观察者如果没有识别上下文(或者在一个单一情况下,任何键路径)通常应该调用父类的<code>obserValueForKeyPath:ofObject:change:context:</code>实现.因为这意味着父类也注册为观察者去接受通知.</p><blockquote><p>注意: 如果一个通知传递到类层级的顶部.NSObject会抛出一个NSInternalInconsistencyException.因为这是一个编程错误: 一个子类没有使用它注册的通知.</p></blockquote><h3 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h3><p>发送给观察者 removeObserver:forKeyPath:context:消息来移除一个键值观察者.需要指定观察的对象.键路径,和上下文.Listing 4中的例子展示了Person移除自己,作为balance和interestRate的观察者.</p><p><strong>Listing 4</strong> 移除balance和interestRate观察者</p><pre><code class="hljs groovy">- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">unregisteAsObserverForAccount:</span>(Account *)account&#123;        [account <span class="hljs-attr">removeObserver:</span> self <span class="hljs-attr">forKeyPath:</span> @<span class="hljs-string">&quot;balance&quot;</span> <span class="hljs-attr">context:</span> PersonAccountBalanceContext];        [account <span class="hljs-attr">removeObserver:</span> self <span class="hljs-attr">forKeyPath:</span> @<span class="hljs-string">&quot;interestRate&quot;</span> <span class="hljs-attr">context:</span> PersonAccountInterestRateContext];&#125;</code></pre><p>接受到一个 removeObserver:forKeyPath:context: 消息后,观察的对象将不再接受指定的键路径和对象的任何 obserValueForKeyPath:ofObject:change:context:消息 </p><p>当正在移除一个观察者时,记住以下几点:</p><ul><li><p>如果移除的观察者未注册,则会导致一个NSRangeExcepion异常.调用<code>removeObserver:forKeyPath:context:</code>方法一次,则有与之相对应的<code>addObserver:forKeyPath:options:context:</code>方法被调用.或者如果不适用的话,把remove方法添加到一个<code>try/catch</code> Block中处理潜在的异常.</p></li><li><p>一个观察者在销毁时不会自动移除自身.被观察的对象会持续发送通知,不会顾及到观察者状态的改变.然而,一个改变通知,或者其他消息发送给一个已经释放的对象,会触发一个内存访问异常.因此需要确保观察者释放前一定要移除观察者.</p></li><li><p>KVO协议没有提供观察者和被观察对象的访问方式.避免相关的错误发生.一个典型的格式是在观察者初始化的时候(比如在 init 或者 viewDidLoad 方法中),注册为观察者,在delloc方法中取消注册.来确保合适的添加和移除信息.并且确保观察者在内存中移除前已经取消注册.</p></li></ul><hr><h2 id="注册依赖键"><a href="#注册依赖键" class="headerlink" title="注册依赖键"></a>注册依赖键</h2><p>在许多情况下，一个属性的值取决于另一个对象中的一个或多个其他属性的值。如果一个属性的值发生改变,那么派生属性的值也被标记为更改.</p><h3 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h3><p>为了自动触发一对一关系属性的通知,应该重写 <code>keyPathsForValuesAffectingValueForKey:</code>方法或者实现一个合适的方法,该方法遵循它定义注册为依赖键的格式.</p><p>例如,一个人完整的姓名取决于firs和last names.返回完整姓名的方法可以向下面方法一样写:</p><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSString</span> *)fullName &#123;        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@ %@&quot;</span>,firstName, lastName];&#125;</code></pre><p>当应用观察fullName属性的时候,只要firstName和lastName中任意一个属性发生改变,都必须通知该应用,因为他们影响fullName属性的值.</p><p>一种解决办法是重写<code>keyPathsForValuesAffectingValueForKey:</code>方法 来指定fullName属性依赖于lastName和firstName属性. <strong>Listing 1</strong>展示了这种依赖的实现.</p><p><strong>Listing 1</strong> <code>keyPathsForValuesAffectingValueForKey: </code>方法的实现示例</p><pre><code class="hljs groovy">+ (NSSet *)<span class="hljs-attr">keyPathsForValuesAffectingValueForKey:</span>(NSString *)key &#123;        NSSet *keyPaths = [<span class="hljs-built_in">super</span> <span class="hljs-attr">keyPathsForValuesAffectingValueForKey:</span>key];        <span class="hljs-keyword">if</span> ([key <span class="hljs-attr">isEqualToString:</span>@<span class="hljs-string">&quot;fullName&quot;</span>]) &#123;        NSArray *affectingKey = @[@<span class="hljs-string">&quot;lastName&quot;</span>, @<span class="hljs-string">&quot;firstName&quot;</span>];        keyPaths = [keyPaths <span class="hljs-attr">setByAddingObjectsFromArray:</span>affectingKeys];    &#125;    <span class="hljs-keyword">return</span> keyPaths;&#125;</code></pre><p>您的重写通常应该调用super，并返回一个集合，该集合包含了在该集合中产生的任何成员(以便在superclasses中不影响该方法的重写)</p><p>通过实现一个类方法也可以实现相同的结果,该类方法遵循命名约定 keyPathsForValuesAffectiing<Key>,该<Key>是依赖属性的名称(首字母大写).按照<strong>Listing 1</strong>中的模式写一个类方法, 如 <strong>Listing 2</strong> 所展示.</p><p><strong>Listing 2</strong> keyPathsForValuesAffecting<Key> 命名约定的实现示例</p><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSSet</span> *)keyPathsForValuesAffectingFullName &#123;        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSSet</span> setWithObjects:<span class="hljs-string">@&quot;lastName&quot;</span>, <span class="hljs-string">@&quot;firstName&quot;</span>, <span class="hljs-literal">nil</span>];&#125;</code></pre><p>当使用分类给一个存在的类添加计算属性时,不能重写<code>keyPathsForValuesAffectingValueForKey:</code>方法.因为在分类中不得重写方法.在那种情况下,实现一个keyPathsForValuesAffecting<Key>类方法可以很好地利用该机制.</p><blockquote><p>注意: 一对多关系属性不能使用<code>keyPathsForValuesAffectingValueForKey:</code>方法设定依赖.必须观察一对多集合中每个对象的合适的属性并且通过更新依赖键自身来改变它的值.下面内容展示了处理这种情况的一种策略.</p></blockquote><h3 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h3><p><code>keyValuesForValuesAffectingValueForKey: </code>方法不支持一对多关系属性的键路径.例如,假设有一个department对象,该对象拥有一个一对多关系的属性(employees).employee有一个salary属性.可能该对象希望有一个totalSalary属性来表示employees中所有employee的salary总和.</p><p>下面两种情况下的两种可能的解决方案.</p><p>1.可以使用键值观察注册父类(本例中是Department)作为所有子类(在本例中是Employees)相关属性的观察者.必须添加和移除作为观察者的父类对象.在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中通过更新依赖值来响应变化,就像下面的代码中阐述的一样:</p><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-keyword">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span> *)change context:(<span class="hljs-keyword">void</span> *)context &#123;     <span class="hljs-keyword">if</span> (context == totalSalaryContext) &#123;        [<span class="hljs-keyword">self</span> updateTotalSalary];    &#125;    <span class="hljs-keyword">else</span>    <span class="hljs-comment">// deal with other observations and/or invoke super...</span>&#125; - (<span class="hljs-keyword">void</span>)updateTotalSalary &#123;    [<span class="hljs-keyword">self</span> setTotalSalary:[<span class="hljs-keyword">self</span> valueForKeyPath:<span class="hljs-string">@&quot;employees.@sum.salary&quot;</span>]];&#125; - (<span class="hljs-keyword">void</span>)setTotalSalary:(<span class="hljs-built_in">NSNumber</span> *)newTotalSalary &#123;     <span class="hljs-keyword">if</span> (totalSalary != newTotalSalary) &#123;        [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;totalSalary&quot;</span>];        _totalSalary = newTotalSalary;        [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;totalSalary&quot;</span>];    &#125;&#125; - (<span class="hljs-built_in">NSNumber</span> *)totalSalary &#123;    <span class="hljs-keyword">return</span> _totalSalary;&#125;</code></pre><p>2.如果您使用的是Core Data，您可以将应用程序的通知中心注册为其托管对象上下文的观察者。托管对象应以类似于键值观察的方式，对子对象发布的相关更改通知作出响应。</p><hr><h2 id="键值观察实现细节"><a href="#键值观察实现细节" class="headerlink" title="键值观察实现细节"></a>键值观察实现细节</h2><p>自动键值观察使用一种叫做 isa-swizzling 的技术来实现.</p><p>isa 指针,作为建议的名称,指向对象类.该类持有一个分配表.这个分配表包含了实例方法的指针,以及其他数据.</p><p>当注册的观察者观察一个对象的某个属性时,被观察对象的isa指针被修改,指向一个媒介类,而不是对象类的真正isa指针.所以isa指针不必映射到实际的类实例.</p><p>不应该依靠isa指针来判断类的成员关系.而应该使用类方法去判断一个对象实例的类.</p><hr><h1 id="NSKeyValueObserving"><a href="#NSKeyValueObserving" class="headerlink" title="NSKeyValueObserving"></a>NSKeyValueObserving</h1><p>一个非正式协议,该协议内容为对象接受其他对象指定属性改变的通知.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>您可以观察任何对象属性.包括单一属性,一对一关系属性,一对多关系属性.一对多关系属性的观察者被告知改变的属性类型—以及相关的对象.</p><p>NSObject提供一个键值观察协议的实现.该实现提供对所有对象的自动观察能力.您可以通过禁用自动观察者通知和使用该协议中的方法实现手动通知来进一步优化通知。</p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><h3 id="改变通知"><a href="#改变通知" class="headerlink" title="改变通知"></a>改变通知</h3><pre><code class="hljs swift"><span class="hljs-comment">/**</span><span class="hljs-comment"> 当观察对象的指定键路径下的值发生变化时,通知观察者.</span><span class="hljs-comment"> </span><span class="hljs-comment"> keyPath: 观察对象值已经改变的对应键路径.</span><span class="hljs-comment"> object : 观察对象.</span><span class="hljs-comment"> change : 一个字典用来描述相关对象指定键路径下属性值已经形成的变化.</span><span class="hljs-comment"> context: 提供给注册观察者的值.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 对一个对象来说,当它开始发送键路径下值改变通知时,您发送给它一个 addObserver(_:forKeyPath:options:context:)消息,命名应该接受该消息的观察者.当您观察结束时,在观察对象销毁前,您发送给观察对象一个removeObserver(_:forKeyPath:)或者remmoverObserver(_:forKeyPath:context:)消息去取消观察者,并且停止发送改变通知的消息.</span><span class="hljs-comment"></span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">observeValue</span><span class="hljs-params">(forKeyPath: String?, of object: <span class="hljs-keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="hljs-keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span></code></pre><h3 id="注册观察"><a href="#注册观察" class="headerlink" title="注册观察"></a>注册观察</h3><pre><code class="hljs swift"><span class="hljs-comment">/**</span><span class="hljs-comment"> 注册观察者接受键路径相关对象的KVO通知消息</span><span class="hljs-comment">  </span><span class="hljs-comment"> observer: 注册KVO通知的对象.观察者必须实现键值观察方法 observeValue(forKeyPath:of:change:context:)</span><span class="hljs-comment"> keyPath: 被观察对象的键路径.该参数不能为nil</span><span class="hljs-comment"> options: 一个在NSKeyValueObservingOptions 值的组合. </span><span class="hljs-comment"> context: 在obserValue(forKeyPath:of:change:context:)方法中传递给观察者的任意数据</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 不管是观察者还是被观察对象,引用计数都不会加一.调用该方法的对象必须调用removerObserver(_:forKeyPath:)或者removeObserver(_:forKeyPathL:context:)方法去移除观察者.</span><span class="hljs-comment"> </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(<span class="hljs-number">_</span> observer: NSObject, forKeyPath keyPath: String, options: NSKeyValueObservingOptions = [], context: UnsafeMutableRawPointer?)</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> 对一个之前没有注册观察者的对象调用该方法是错误的.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 确保注册的观察者在销毁之前调用该方法.</span><span class="hljs-comment"></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(<span class="hljs-number">_</span> observer: NSObject, forKeyPath keyPath: String)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(NSObject, forKeyPath: String, context: UnsafeMutableRawPointer?)</span></span></code></pre><h3 id="通知观察对象的变化"><a href="#通知观察对象的变化" class="headerlink" title="通知观察对象的变化"></a>通知观察对象的变化</h3><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">willChangeValue</span><span class="hljs-params">(forKey: String)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didChangeValue</span><span class="hljs-params">(forKey: String)</span></span><span class="hljs-comment">//观察对象数组类型时,调用该方法来通知观察对象的变化</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">willChange</span><span class="hljs-params">(NSKeyValueChange, valuesAt: IndexSet, forKey: String)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didChange</span><span class="hljs-params">(NSKeyValueChange, valuesAt: IndexSet, forKey: String)</span></span><span class="hljs-comment">//观察对象Set类型时,调用该方法来通知观察对象的变化</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">willChangeValue</span><span class="hljs-params">(forKey: String, withSetMutation: NSKeyValueSetMutationKind, using: Set&lt;AnyHashable&gt;)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didChangeValue</span><span class="hljs-params">(forKey: String, withSetMutation: NSKeyValueSetMutationKind, using: Set&lt;AnyHashable&gt;)</span></span></code></pre><h3 id="自定义观察"><a href="#自定义观察" class="headerlink" title="自定义观察"></a>自定义观察</h3><pre><code class="hljs go"><span class="hljs-comment">//返回一个布尔值标明是否观察对象自动支持KVO.</span>class <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">automaticallyNotifiesObservers</span><span class="hljs-params">(forKey: String)</span></span><span class="hljs-comment">//返回一个键路径集合,该集合内键路径对应的值影响指定key的值.比如计算属性</span>class <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">keyPathsForValuesAffectingValue</span><span class="hljs-params">(forKey: String)</span></span><span class="hljs-comment">//返回一个指针，该指针标识所有在被观察对象注册的观察者的信息。</span><span class="hljs-keyword">var</span> observationInfo: UnsafeMutableRawPointer?</code></pre><pre><code class="hljs routeros">protocol NSKeyValueObservingCustomizationType methods   required  static func automaticallyNotifiesObservers(<span class="hljs-keyword">for</span>: AnyKeyPath)  required  static func keyPathsAffectingValue(<span class="hljs-keyword">for</span>: AnyKeyPath)Relationships继承自  NSObjectProtocol</code></pre><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NSKeyValueObservation</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NSKeyValueObservedChange</span></span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NSKeyValueChange</span>&#123;</span>        <span class="hljs-keyword">case</span> setting,    <span class="hljs-keyword">case</span> insertion,    <span class="hljs-keyword">case</span> removal,    <span class="hljs-keyword">case</span> replacement&#125;--------------------------------------------------------------<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NSKeyValueObservingOptions</span> </span><span class="hljs-comment">#### Constants</span>    static var <span class="hljs-symbol">new:</span> NSKeyValueObservingOptions    static var <span class="hljs-symbol">old:</span> NSKeyValueObservingOptions    static var <span class="hljs-symbol">initial:</span> NSKeyValueObservingOptions    static var <span class="hljs-symbol">prior:</span> NSkeyValueObservingOptions--------------------------------------------------------------<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NSKeyValueChangeKey</span></span><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NSKeyValueSetMutationKind</span></span></code></pre><h2 id="KVO原理简析"><a href="#KVO原理简析" class="headerlink" title="KVO原理简析"></a>KVO原理简析</h2><ul><li>当一个object有观察者时，动态创建这个object的类的子类</li><li>对于每个被观察的property，重写其set方法</li><li>在重写的set方法中调用<code> willChangeValueForKey:</code>和 <code>didChangeValueForKey:</code>通知观察者</li><li>当一个property没有观察者时，删除重写的方法</li><li>当没有observer观察任何一个property时，删除动态创建的子类</li></ul><p>详细的分析可以去看sunyxx的<a href="http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/">objc kvo简单探索</a></p><h2 id="GitHub优秀开源"><a href="#GitHub优秀开源" class="headerlink" title="GitHub优秀开源"></a>GitHub优秀开源</h2><p>在项目中使用KVO的时候要时刻谨记移除观察者,否则会抛出异常.这样不经容易出错,而且项目代码看起来也不够漂亮. <strong>facebook</strong>提供了一个很好的解决方案.在该第三方库中,不用再担心移除观察者的问题,代码整体上也比以前更叫干净漂亮.仅需要在项目 <strong>PCH</strong> 文件中 <code>#import &lt;KVOController/NSObject+FBKVOController.h&gt;</code>,这样会给每个<strong>NSObject</strong> 对象自动添加KVOController属性,然后直接使用就OK了</p><pre><code class="hljs groovy">[self.KVOController <span class="hljs-attr">observe:</span>clock <span class="hljs-attr">keyPath:</span>@<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">options:</span>NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew <span class="hljs-attr">action:</span><span class="hljs-meta">@selector</span>(<span class="hljs-attr">updateClockWithDateChange:</span>)];</code></pre><p>具体使用请看 <a href="https://github.com/facebook/KVOController">KVOController</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA">Key-Value Observing Programming Guide</a></p><p><a href="https://developer.apple.com/documentation/foundation/notifications/nskeyvalueobserving">NSKeyValueObserving</a></p><p><a href="http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/">objec kvo简单探索</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KVO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVC</title>
    <link href="/blog/2017/12/10/iOS/KVC/"/>
    <url>/blog/2017/12/10/iOS/KVC/</url>
    
    <content type="html"><![CDATA[<h1 id="NSKeyValueCoding"><a href="#NSKeyValueCoding" class="headerlink" title="NSKeyValueCoding"></a>NSKeyValueCoding</h1><p>一种可以直接通过key的名字来获取对象属性的机制.</p><h2 id="通览"><a href="#通览" class="headerlink" title="通览"></a>通览</h2><p>访问对象值的基本方法是 setValue(_:forKey:),该方法给指定属性设置值,还有value(forKey:)方法,通过指定key获取该属性的value.因此,所有对象属性都可以通过同一种方式去访问.</p><p>默认实现依赖于通过对象的访问器方法正常地实现.(或者如果需要的话直接获取实例变量)</p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><pre><code class="hljs swift"><span class="hljs-comment">//返回指定key的属性值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(forKey: String)</span></span><span class="hljs-comment">//返回指定的key path 推断出的属性值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(forKeyPath: String)</span></span><span class="hljs-comment">//返回一个字典,该字典包含一个数组中包含的所以key对应的属性值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dictionaryWithValues</span><span class="hljs-params">(forKeys: [String])</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> 当调用value(forKey:)方法,发现没有key对应属性时,调用此方法.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 子类可以重写该方法给未定义的key返回一个可选值,默认实现是会抛出一个NSUndefinedKeyException异常.</span><span class="hljs-comment"> </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">value</span><span class="hljs-params">(forUndefineKey: String)</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> 当key对应对象的属性为一个有序集合时,返回一个可变数组.</span><span class="hljs-comment"> </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutableArrayValue</span><span class="hljs-params">(forKey: String)</span></span><span class="hljs-comment">//返回一个可变数组,代理其提供指定key path的序列关系集合的读写权限.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutableArrayValue</span><span class="hljs-params">(forKeyPath: String)</span></span><span class="hljs-comment">//返回一个可变集合,代理其提供指定key的无序关系集合的读写访问</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutableSetValue</span><span class="hljs-params">(forKey: String)</span></span><span class="hljs-comment">//返回一个可变集合,代理其提供指定key path的无序关系集合的读写访问.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutableSetValue</span><span class="hljs-params">(forKeyPaht: String)</span></span><span class="hljs-comment">//返回一个可变序列化集合,该集合通过指定key提供对这个特殊的有序集合的读写访问.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutableOrderedSetValue</span><span class="hljs-params">(forKey: String)</span></span><span class="hljs-comment">//返回一个可变序列化集合,该集合通过指定key path 提供对这个特殊有序集合的读写访问.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mutableOrderedSetValue</span><span class="hljs-params">(forKeyPath: String)</span></span></code></pre><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><pre><code class="hljs swift"><span class="hljs-comment">//给指定keyPath赋值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>?, forKeyPath: String)</span></span><span class="hljs-comment">//根据指定字典的key对应的value,给key对应的属性赋值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setValuesForKeys</span><span class="hljs-params">([String : <span class="hljs-keyword">Any</span>])</span></span><span class="hljs-comment">//当给setValue(_:forKey:)的标量值(比如一个int 或者 float 值)为nil时调用此方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setNilValueForKey</span><span class="hljs-params">(String)</span></span><span class="hljs-comment">/**</span><span class="hljs-comment"> 给指定key对应属性赋值</span><span class="hljs-comment"></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>?, forKey: String)</span></span><span class="hljs-comment">//当调用setValue(_:forKey:)方法发现没有key对应的属性时,调用此方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>?, forUndefineKey: String)</span></span></code></pre><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><pre><code class="hljs swift"><span class="hljs-comment">//校验一个对象赋值给key对应的属性是否有效,无效则抛出一个错误</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateValue</span><span class="hljs-params">(AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKey: String)</span></span><span class="hljs-comment">//校验一个对象赋值给对应的keypath属性是否有效,无效抛出一个错误</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateValue</span><span class="hljs-params">(AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, forKeyPath: String)</span></span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/documentation/foundation/object_runtime/nskeyvaluecoding">NSKeyValueCoding</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Router</title>
    <link href="/blog/2017/11/26/iOS/iOS-Router/"/>
    <url>/blog/2017/11/26/iOS/iOS-Router/</url>
    
    <content type="html"><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>通过scheme跳转到应用指定页面</p><h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><ul><li>定义URL，通过其获取控制器名和控制器属性参数</li><li>通过控制器名创建对应控制器</li><li>给控制器属性赋值</li><li>跳转到相应控制器</li></ul><h3 id="项目Demo"><a href="#项目Demo" class="headerlink" title="项目Demo"></a><a href="https://github.com/913868456/GFRouter">项目Demo</a></h3><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li><p>定义URL规则</p><p>scheme :// host /控制器名?属性名=属性值&amp;属性名=属性值</p></li></ol><p>该方式符合标准的URL定义规范，同时也方便以后扩展</p><p>通过控制器名称获取控制器，需要用到runtime，所以需要先导入&lt;objc/runtime.h&gt; 头文件</p><pre><code class="hljs objectivec"><span class="hljs-comment">//通过URL获取控制器</span>+ (<span class="hljs-built_in">UIViewController</span> *)getControllerFromURL:(<span class="hljs-built_in">NSURL</span> *)URL&#123;        <span class="hljs-keyword">if</span> (URL.path.length &gt; <span class="hljs-number">1</span>) &#123;                <span class="hljs-built_in">NSString</span> *subPath = [URL.path substringFromIndex:<span class="hljs-number">1</span>];        <span class="hljs-built_in">UIViewController</span> *vc = [GFRouter getControllerFromClassName:subPath];        <span class="hljs-keyword">return</span> vc;    &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;    &#125;&#125;<span class="hljs-comment">//通过类名获取控制器</span>+ (<span class="hljs-built_in">UIViewController</span> *)getControllerFromClassName:(<span class="hljs-built_in">NSString</span> *)controllerName&#123;        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * name = [controllerName cStringUsingEncoding:<span class="hljs-built_in">NSASCIIStringEncoding</span>];        <span class="hljs-comment">// 从一个类名返回一个类</span>    Class newClass = objc_getClass(name);    <span class="hljs-comment">// 创建对象</span>    <span class="hljs-keyword">if</span> (newClass == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;    <span class="hljs-keyword">return</span> [[newClass alloc] init];&#125;</code></pre><p>获取控制器属性参数 paraDic</p><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSMutableDictionary</span> *)getParaWith:(<span class="hljs-built_in">NSURL</span> *)URL&#123;        <span class="hljs-built_in">NSMutableDictionary</span> *properties = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];    <span class="hljs-comment">// Extract Params From Query.</span>    <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSURLQueryItem</span> *&gt; *queryItems = [[<span class="hljs-built_in">NSURLComponents</span> alloc] initWithURL:URL resolvingAgainstBaseURL:<span class="hljs-literal">false</span>].queryItems;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSURLQueryItem</span> *item <span class="hljs-keyword">in</span> queryItems) &#123;       properties[item.name] = item.value;    &#125;        <span class="hljs-keyword">return</span> properties;&#125;</code></pre><ol start="2"><li>控制器属性赋值，使用 KVC <blockquote><p> 使用 KVC 赋值的时候，需要判断将要赋值的属性是否在控制器中存在</p></blockquote></li></ol><pre><code class="hljs objectivec"><span class="hljs-comment">//属性赋值</span>+ (<span class="hljs-built_in">UIViewController</span> *)setPropertyWith:(<span class="hljs-built_in">NSMutableDictionary</span> *)paraDic and:(<span class="hljs-built_in">UIViewController</span> *)controller&#123;        [paraDic enumerateKeysAndObjectsUsingBlock:^(<span class="hljs-keyword">id</span> key, <span class="hljs-keyword">id</span> obj, <span class="hljs-built_in">BOOL</span> *stop) &#123;        <span class="hljs-comment">// 检测这个对象是否存在该属性</span>        <span class="hljs-keyword">if</span> ([GFRouter checkIsExistPropertyWithInstance:controller verifyPropertyName:key]) &#123;            <span class="hljs-comment">// 利用kvc赋值</span>            [controller setValue:obj forKey:key];        &#125;    &#125;];    <span class="hljs-keyword">return</span> controller;&#125;+ (<span class="hljs-built_in">BOOL</span>)checkIsExistPropertyWithInstance:(<span class="hljs-keyword">id</span>)instance verifyPropertyName:(<span class="hljs-built_in">NSString</span> *)verifyPropertyName&#123;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> outCount, i;        <span class="hljs-comment">// 获取对象里的属性列表</span>    objc_property_t * properties = class_copyPropertyList([instance <span class="hljs-keyword">class</span>], &amp;outCount);        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; outCount; i++) &#123;        objc_property_t property =properties[i];        <span class="hljs-comment">//  属性名转成字符串</span>        <span class="hljs-built_in">NSString</span> *propertyName = [[<span class="hljs-built_in">NSString</span> alloc] initWithCString:property_getName(property) encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];        <span class="hljs-comment">// 判断该属性是否存在</span>        <span class="hljs-keyword">if</span> ([propertyName isEqualToString:verifyPropertyName]) &#123;            free(properties);            <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;        &#125;    &#125;    free(properties);        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;&#125;</code></pre><ol start="3"><li>获取当前控制器，推出目标控制器</li></ol><pre><code class="hljs objectivec"><span class="hljs-comment">//获取当前viewController</span>+ (<span class="hljs-built_in">UIViewController</span> *)getCurrentVC&#123;    <span class="hljs-built_in">UIViewController</span> *result = <span class="hljs-literal">nil</span>;    <span class="hljs-built_in">UIWindow</span> * window = [[<span class="hljs-built_in">UIApplication</span> sharedApplication] keyWindow];    <span class="hljs-comment">//app默认windowLevel是UIWindowLevelNormal，如果不是，找到UIWindowLevelNormal的</span>    <span class="hljs-keyword">if</span> (window.windowLevel != <span class="hljs-built_in">UIWindowLevelNormal</span>)    &#123;        <span class="hljs-built_in">NSArray</span> *windows = [[<span class="hljs-built_in">UIApplication</span> sharedApplication] windows];        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">UIWindow</span> * tmpWin <span class="hljs-keyword">in</span> windows)        &#123;            <span class="hljs-keyword">if</span> (tmpWin.windowLevel == <span class="hljs-built_in">UIWindowLevelNormal</span>)            &#123;                window = tmpWin;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">id</span>  nextResponder = <span class="hljs-literal">nil</span>;    <span class="hljs-built_in">UIViewController</span> *appRootVC=window.rootViewController;    <span class="hljs-comment">//    如果是present上来的appRootVC.presentedViewController 不为nil</span>    <span class="hljs-keyword">if</span> (appRootVC.presentedViewController) &#123;        nextResponder = appRootVC.presentedViewController;    &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-comment">//        NSLog(@&quot;===%@&quot;,[window subviews]);</span>        <span class="hljs-built_in">UIView</span> *frontView = [[window subviews] objectAtIndex:<span class="hljs-number">0</span>];        nextResponder = [frontView nextResponder];    &#125;        <span class="hljs-keyword">if</span> ([nextResponder isKindOfClass:[<span class="hljs-built_in">UITabBarController</span> <span class="hljs-keyword">class</span>]])&#123;        <span class="hljs-built_in">UITabBarController</span> * tabbar = (<span class="hljs-built_in">UITabBarController</span> *)nextResponder;        <span class="hljs-built_in">UINavigationController</span> * nav = (<span class="hljs-built_in">UINavigationController</span> *)tabbar.viewControllers[tabbar.selectedIndex];        <span class="hljs-comment">//UINavigationController * nav = tabbar.selectedViewController ; 上下两种写法都行</span>        result=nav.childViewControllers.lastObject;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([nextResponder isKindOfClass:[<span class="hljs-built_in">UINavigationController</span> <span class="hljs-keyword">class</span>]])&#123;        <span class="hljs-built_in">UIViewController</span> * nav = (<span class="hljs-built_in">UIViewController</span> *)nextResponder;        result = nav.childViewControllers.lastObject;    &#125;<span class="hljs-keyword">else</span>&#123;        result = nextResponder;    &#125;    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-comment">//导航推出控制器</span>+ (<span class="hljs-keyword">void</span>)pushWith:(<span class="hljs-built_in">UIViewController</span> *)controller&#123;        <span class="hljs-built_in">UINavigationController</span> *nc = [GFRouter getCurrentVC].navigationController;    controller.hidesBottomBarWhenPushed = <span class="hljs-literal">YES</span>;        <span class="hljs-keyword">if</span> (nc) &#123;        [nc pushViewController:controller animated:<span class="hljs-literal">YES</span>];    &#125;&#125;</code></pre><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>通过上述方式，我们还可以往URL中拼上一些参数，来操作控制器的推出方式。</p><p>比如 xxx://host:8080/控制器名?displayStyle=present</p><pre><code class="hljs groovy">  <span class="hljs-comment">//默认push推出控制器</span>    <span class="hljs-keyword">if</span> ([paraDic[@<span class="hljs-string">&quot;displayStyle&quot;</span>] <span class="hljs-attr">isEqualToString:</span>@<span class="hljs-string">&quot;present&quot;</span>]) &#123;        [router <span class="hljs-attr">presentWith:</span>controller];    &#125;<span class="hljs-keyword">else</span>&#123;        [router <span class="hljs-attr">pushWith:</span>controller];    &#125;<span class="hljs-comment">//模态推出控制器</span>- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">presentWith:</span>(UIViewController *)controller&#123;        UIViewController *vc = [GFRouter getCurrentVC];        <span class="hljs-keyword">if</span> (vc.<span class="hljs-keyword">class</span> != controller.<span class="hljs-keyword">class</span>) &#123;        [vc <span class="hljs-attr">presentViewController:</span>controller <span class="hljs-attr">animated:</span>YES <span class="hljs-attr">completion:</span>nil];    &#125;</code></pre><p>也可在控制器内部使用router,传入控制器名称和属性键值字典，然后像上述方式一样推出控制器。具体实现就不多说了，自己可以动手操作一下。</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Objective-C Runtime</title>
    <link href="/blog/2017/11/20/iOS/-Objective-C-Runtime/"/>
    <url>/blog/2017/11/20/iOS/-Objective-C-Runtime/</url>
    
    <content type="html"><![CDATA[<p>描述macOS OC运行时库支持的函数和数据结构.</p><h2 id="通览"><a href="#通览" class="headerlink" title="通览"></a>通览</h2><p>OC运行时是一个运行时库,该库用来支持OC语言的动态属性.并且这种情况对所有的的Objectiv-C的app都有关系.OC运行时库支持的函数实现在 /usr/lib/libobjc.A.dylib中的分享库中可以查到.(自己测试是在资源库文件夹下面)</p><p>在OC编程中,您完全没有必要直接地使用OC运行时库.这些Api的主要作用是作为OC和其他语言的桥接层.或者更底层的调试.</p><p>OC运行时库在macOS 中的实现是特殊的.对于其他平台,GNU编译集合使用类似的Api提供了一种不同的的实现.这个文档只包含了macOS的实现.</p><p>底层的OC运行时Api在OS X 版本10.5中做了显著更新.许多函数和所有现有的数据结构被替换为新的函数.老的函数和数据结构在32位模式下被弃用.64位模式下仍然存在.Api在64位模式下约束了一些在32位模式下表示的整型数据值.比如 class Count, protocol Count, methods per class, ivars per class, arguments per method, sizeof(all arguments) per method, class version number.另外,新的Objective-C ABI 对32位模式下的对象实例化约束更多.并且三个其他的24位模式下表示的一些值 methods per class, ivars per class, sizeof(a single ivar).最后,<br>老式的NXHashTable和NXMapTable被限制到四百万项.</p><blockquote><p>字符串编码<br>在运行时API中所有的字符指针应该<br> 被看作UTF-8编码格式.</p></blockquote><h2 id="该文档适用哪些人"><a href="#该文档适用哪些人" class="headerlink" title="该文档适用哪些人?"></a>该文档适用哪些人?</h2><p>这个文档适用那些对OC运行时有兴趣学习的读者.<br>因为这不是关于C的文档.该文档仅当做对OC开发者的一些拓展.</p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><h3 id="与Class一起使用"><a href="#与Class一起使用" class="headerlink" title="与Class一起使用"></a>与Class一起使用</h3><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><span class="hljs-comment"> cls: 一个类对象</span><span class="hljs-comment"> 返回值: 类的名称,如果传Nil则为空字符串</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getName(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>:AnyClass?)</span> -&gt; UnsafePointer&lt;Int8&gt;<span class="hljs-comment">/*</span><span class="hljs-comment"> cls: 一个类对象</span><span class="hljs-comment"> 返回值: 该类的父类. 如果cls为根类或者cls为Nil的话,返回值为Nil</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 你应该通常使用NSObject的 superclass()方法替换该方法</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getSuperclass(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?)</span> -&gt; AnyClass?<span class="hljs-comment">/*</span><span class="hljs-comment"> 返回一个布尔值, 该值表示是否一个类对象是一个元类</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 一个类对象</span><span class="hljs-comment"> 返回值: 如果参数是一个元类,则返回true. 如果非元类,则返回false,或者参数为Nil也返回false.</span><span class="hljs-comment"></span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_isMetaClass(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?)</span> -&gt; Bool<span class="hljs-comment">/*</span><span class="hljs-comment"> 返回一个类的实例占用内存的大小</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 一个类对象</span><span class="hljs-comment"> 返回值: 类实例的占用的字节.如果参数为Nil则返回0</span><span class="hljs-comment">**/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getInstanceSize(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?)</span> -&gt; Int<span class="hljs-comment">/*</span><span class="hljs-comment"> 返回给定类的一个指定实例变量</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 想要获取实例变量的类</span><span class="hljs-comment"> name: 去获取的实例变量名</span><span class="hljs-comment"> 返回值: 指定名字的实例变量的指针</span><span class="hljs-comment">**/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getInstanceVariable(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">name</span>: UnsafePointer&lt;Int8&gt;)</span> -&gt; Ivar?<span class="hljs-comment">/*</span><span class="hljs-comment"> 返回某个类指定名字的类变量</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 要获取类变量的类</span><span class="hljs-comment"> name: 要获取的类变量名称</span><span class="hljs-comment"> 返回值: 指定名字的类变量的指针</span><span class="hljs-comment">**/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getClassVariable(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">name</span>: UnsagePointer&lt;Int8&gt;)</span> -&gt;Ivar?<span class="hljs-comment">/*</span><span class="hljs-comment"> 给一个类添加一个实例变量</span><span class="hljs-comment"> </span><span class="hljs-comment"> 返回值: 如果实例变量加入成功,返回true.否则返回false(比如该类已经包含一个相同名字的实例变量)</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 这个函数只能在objc_allocateClassPair(_:_:_:)之后调用.在objc_registerClassPair(_:)之前调用.不支持给一个已经注册过的类添加实例变量.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 操作的类不能使元类.不支持给一个元类添加实例变量.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 实例变量以字节的最小对齐方式为1&lt;&lt;align.实例变量的最小对齐方式取决于实例变量的类型和设备的架构.对于任意指针类型的变量,传log2(sizeof(pointer_type))</span><span class="hljs-comment"></span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_addIvar(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?,<span class="hljs-params">_</span> <span class="hljs-params">name</span>: UnsagePointer&lt;Int8&gt;, <span class="hljs-params">_</span> <span class="hljs-params">size</span>: Int, <span class="hljs-params">_</span> <span class="hljs-params">alignment</span>: UInt8, <span class="hljs-params">_</span> <span class="hljs-params">types</span>: UnsagePointer&lt;Int8&gt;?)</span> -&gt; Bool<span class="hljs-comment">/*</span><span class="hljs-comment"> 获取类的实例变量列表</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 需要拷贝属性列表的类</span><span class="hljs-comment"> outCount: 在返回时,包含返回数组的长度.如果outCount是NULL,则不反悔该长度.</span><span class="hljs-comment"> 返回值: 一个指针数组描述类声明的实例变量.任何被父类声明的实例变量不包含在内.数组包含* outCount指针，后跟一个空终止符。您必须使用free()函数释放数组.</span><span class="hljs-comment"> 如果类声明中没有实例变量.或者cls为Nil,则返回NULL 并且*coutCount指针为0</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyIvarList(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">outCount</span>: UnsafeMutablePointer&lt;UInt32&gt;?)</span> -&gt; UnsafeMutablePointer&lt;Ivar&gt;?<span class="hljs-comment">//返回指定类实例变量布局的描述</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getIvarLayout(AnyClass?)</span><span class="hljs-comment">//设置指定类实例变量布局</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_setIvarLayout(AnyClass?, UnsafePointer&lt;UInt8&gt;?)</span><span class="hljs-comment">//返回弱引用实例变量的布局描述</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getWeakIvarLayout(AnyClass?)</span><span class="hljs-comment">//设置弱引用实例变量的布局</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_setWeakIvarLayout(AnyClas?, UnsafePointer&lt;UInt8&gt;?)</span><span class="hljs-comment">/*</span><span class="hljs-comment"> 返回指定类的指定名称的属性</span><span class="hljs-comment"> </span><span class="hljs-comment"> 返回值: 一个objc_property_t类型的指针.如果类中并未声明该名称属性或者cls为Nil则返回NULL.</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getProperty(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">name</span>: UnsafePointer&lt;Int8&gt;)</span> -&gt; objc_property_t?<span class="hljs-comment">/*</span><span class="hljs-comment"> 描述声明的一个类的属性</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 想要检查的类</span><span class="hljs-comment"> outCount: 在返回时,包含返回数组的长度.如果outCount 是NULL,数组长度不返回.</span><span class="hljs-comment"> 返回值: objc_property_t类型的指针数组.任何父类声明的属性不包含在内.数组包含* outCount指针，后跟一个空终止符。您必须使用free()函数释放数组.</span><span class="hljs-comment"> 如果类声明中没有实例变量.或者cls为Nil,则返回NULL 并且*coutCount指针为0</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyPropertyList(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">outCount</span>: UnsageMutablePointer&lt;UInt32&gt;?)</span> -&gt; UnsafeMutablePointer&lt;objc_property_t&gt;?<span class="hljs-comment">/*添加一个新方法给指定类.指定方法名和方法实现</span><span class="hljs-comment"></span><span class="hljs-comment">  cls:需要添加方法的类 </span><span class="hljs-comment">  name: 指定添加的方法名  </span><span class="hljs-comment">  imp: 方法的实现的函数,该函数必须携带两个参数 self 和  _cmd</span><span class="hljs-comment">  types: 一个字符数组,用来描述方法的参数类型.参考苹果官方文档 [Type Encodings](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100)</span><span class="hljs-comment">  返回值: 如果添加成功,返回true 否则返回false(例如添加的方法已经存在)</span><span class="hljs-comment">  </span><span class="hljs-comment">  讨论:</span><span class="hljs-comment">  该方法会重载父类的实现,但是并不会替换在这个类中已经存在的实现.想要改变已经存在的实现的话,使用method_setImplementation(_:_:)</span><span class="hljs-comment">  一个OC方法仅仅是一个C的函数.该函数携带至少两个参数----self 和 _cmd.举例,给定下列函数</span><span class="hljs-comment"></span><span class="hljs-comment">  void myMethodIMP(id self, SEL _cmd)</span><span class="hljs-comment">  &#123;</span><span class="hljs-comment">    //implementation ...</span><span class="hljs-comment">    </span><span class="hljs-comment">  &#125;</span><span class="hljs-comment">  </span><span class="hljs-comment">  您可以动态添加该函数到一个类中作为一个方法.(调用 resolveThisMethodDynamically) 像这样:</span><span class="hljs-comment">  </span><span class="hljs-comment">  class_addMethod([self class], @selector(resolveThisMethodDynamically), (IMP) myMethodIMP, &quot;v@:&quot;);</span><span class="hljs-comment">  </span><span class="hljs-comment"> **/</span>func  <span class="hljs-keyword">class</span><span class="hljs-constructor">_addMethod(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>:AnyClass?,<span class="hljs-params">_</span> <span class="hljs-params">name</span>:Selector,<span class="hljs-params">_</span> <span class="hljs-params">imp</span>:IMP,<span class="hljs-params">_</span> <span class="hljs-params">types</span>: UnsagePointer&lt;Int8&gt;?)</span><span class="hljs-comment">/*</span><span class="hljs-comment"> 获取一个类的指定实例方法</span><span class="hljs-comment"> </span><span class="hljs-comment"> aClass: 要检查的类</span><span class="hljs-comment"> aSelector: 要获取方法的选择器</span><span class="hljs-comment"> 返回值: 指定方法选择器所对应的方法实现,如果指定类或者它的父类不包含指定选择器的实例方法则返回NULL.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 注意这个函数搜索父类的实现,而class_copyMethodList(_:_:)是不会的</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getInstanceMethod(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>:AnyClass?,<span class="hljs-params">_</span> <span class="hljs-params">name</span>: Selector)</span> -&gt; Method?<span class="hljs-comment">/*</span><span class="hljs-comment"> 返回指定类指定名称的类方法</span><span class="hljs-comment"> </span><span class="hljs-comment"> aClass: 一个雷定义的指针.该类包含您想要获取的方法.</span><span class="hljs-comment"> aSelector: 一个SEL类型的指针.该SEL包含你想要获取的方法.</span><span class="hljs-comment"> 返回值: Method的指针.对应指定类指定方法选择器的实现.如果该类或者它的父类不包含这个类方法,则返回NULL.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 注意这个函数搜索父类的方法实现.class_copyMethodList(_:_:)不搜索</span><span class="hljs-comment"> **/</span> func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getClassMethod(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">name</span>: Selector)</span> -&gt; Method? <span class="hljs-comment">/*</span><span class="hljs-comment"> 返回一个类的实例方法列表</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 想要检测的类</span><span class="hljs-comment"> outCount: 在返回时,包含数组的长度.如果outCounte是NULL,则不返回.</span><span class="hljs-comment"> 返回值: Method类型的指针数组.表示该类所有的实例方法实现.</span><span class="hljs-comment"> 不包含父类的实例方法实现.该数组包含*outCount指针后面跟一个空终止符.您必须使用free()函数释放该数组.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 如果该类没有实例方法.或者该类为Nil,则返回NULL并且*outCount是0</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> </span><span class="hljs-comment"> 获取一个类的类方法列表.使用class_copyMethodList(object_getClass(cls), &amp;count)</span><span class="hljs-comment"> 获取父类的方法列表,使用class_getInstanceMethod(_:_:)或者class_getClassMehtod(_:_:)</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyMethodList(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">outCount</span>: UnsageMutablePointer&lt;UInt32&gt;?)</span> -&gt; UnsafeMutablePointer&lt;Method&gt;?<span class="hljs-comment">/*</span><span class="hljs-comment"> 替换指定类的方法的实现</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls:要修改的类</span><span class="hljs-comment"> name: 一个方法选择器用来确认哪个方法实现要被替换</span><span class="hljs-comment"> imp:新的方法实现.</span><span class="hljs-comment"> types: 一个字符串集合,用来描述参数的类型.必须至少携带两个参数, self 和_cmd, 第二个和第三个字符必须为&quot;@:&quot;(第一个参数为返回类型)</span><span class="hljs-comment"> </span><span class="hljs-comment"> 返回值: 修改的类之前的方法实现.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment">可以通过两种方式实现该函数行为:</span><span class="hljs-comment">如果方法名不存在,通过call_addMethod(_:_:_:_:)方法的调用添加函数实现.按照types添加参数类型和返回值类型.</span><span class="hljs-comment">如果方法名存在,他的IMP通过method_setImplementation(_:_:)方法的调用来替换函数实现.types参数被忽略.</span><span class="hljs-comment"></span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_replaceMethod(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>:AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">name</span>: Selector,<span class="hljs-params">_</span> <span class="hljs-params">imp</span>: IMP, <span class="hljs-params">_</span> <span class="hljs-params">types</span>: UnsafePointer&lt;Int8&gt;?)</span> -&gt; IMP?<span class="hljs-comment">/*</span><span class="hljs-comment"> 获取指定实例方法的实现</span><span class="hljs-comment"></span><span class="hljs-comment"> cls: 指定类</span><span class="hljs-comment"> name: 方法选择器</span><span class="hljs-comment"> 返回值: 返回函数指针,如果cls为Nil,则返回NULL.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> </span><span class="hljs-comment"> class_getMethodImplementation(_:_:)可能会比method_getImplementtation(class_getInstanceMethod(cls, name))更快一些.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 返回的函数指针可能是运行时的函数，而不是实际的方法实现。例如，如果类的实例不响应选择器，那么返回的函数指针将是运行时消息转发机制的一部分。</span><span class="hljs-comment"> **/</span> func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getMethodImplementation(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?,<span class="hljs-params">_</span> <span class="hljs-params">name</span>: Selector)</span> -&gt; IMP?<span class="hljs-comment">/*</span><span class="hljs-comment"> 返回将要被调用的指定消息的函数指针</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 指定的类</span><span class="hljs-comment"> name: 一个方法选择器</span><span class="hljs-comment"> 返回值: 返回函数指针,如果cls为Nil,则返回NULL.</span><span class="hljs-comment"> **/</span> func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getMethodImplementation_stret(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?,<span class="hljs-params">_</span> <span class="hljs-params">name</span>: Selector)</span> -&gt; IMP?<span class="hljs-comment">/*</span><span class="hljs-comment">返回一个布尔值表示是否一个实例响应了指定方法</span><span class="hljs-comment"></span><span class="hljs-comment">cls : 响应消息的类</span><span class="hljs-comment">sel : 一个方法选择器</span><span class="hljs-comment">返回值: 响应方法,则返回true,否则返回false</span><span class="hljs-comment"></span><span class="hljs-comment">讨论:</span><span class="hljs-comment">通常使用NSObject的responds(to:)或者instancesRespond(to:)方法来替换该方法.</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_respondsToSelector(AnyClass?, Selector)</span><span class="hljs-comment">/*</span><span class="hljs-comment"> 给一个类添加一个协议</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 要改动的类</span><span class="hljs-comment"> outCount: 要添加到该类的协议</span><span class="hljs-comment"> 返回值: 添加成功,返回ture;否则false(比如该类中已经存在该协议)</span><span class="hljs-comment"></span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_addProtocol(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">protocol</span>: Protocol)</span> -&gt; Bool<span class="hljs-comment">/*</span><span class="hljs-comment"> 给一个类添加一个属性</span><span class="hljs-comment"> </span><span class="hljs-comment"> cls: 要改动的类</span><span class="hljs-comment"> name: 属性名</span><span class="hljs-comment"> attributes: 属性的描述(readonly, nonatomic, asign...)</span><span class="hljs-comment"> attributeCount: 属性描述的数量</span><span class="hljs-comment"> 返回值: 添加成功,返回true,否则false(比如已经存在该属性)</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_addProperty(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">name</span>: UnsagePointer&lt;Int8&gt;, <span class="hljs-params">_</span> <span class="hljs-params">attributes</span>: UnsafePointer&lt;<span class="hljs-params">objc_property_attribute_t</span>&gt;?, <span class="hljs-params">_</span> <span class="hljs-params">attributeCounte</span>: UInt32)</span> -&gt; Bool<span class="hljs-comment">/*</span><span class="hljs-comment"> 替换一个类的属性</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_replaceProperty(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>:AnyClass?, <span class="hljs-params">_</span> <span class="hljs-params">name</span>: UnsafePointer&lt;Int8&gt;, <span class="hljs-params">_</span> <span class="hljs-params">attributes</span>: UnsafePointer&lt;<span class="hljs-params">objc_property_attribute_t</span>&gt;?, <span class="hljs-params">_</span> <span class="hljs-params">attrubuteCount</span>: UInt32)</span><span class="hljs-comment">/*</span><span class="hljs-comment"> 返回一个布尔值 表示是否一个类执行指定协议方法</span><span class="hljs-comment"> </span><span class="hljs-comment"> 通常使用NSObject的conforms(to:) 来替换它</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_conformsToProtocol(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?,<span class="hljs-params">_</span> <span class="hljs-params">protocol</span>: Protocol?)</span> -&gt; Bool<span class="hljs-comment">/*</span><span class="hljs-comment"> 描述一个类包含的协议</span><span class="hljs-comment"> cls: 指定的类</span><span class="hljs-comment"> outCount: 返回数组的长度.如果outCount是NULL,返回值不包含数组的长度.</span><span class="hljs-comment"> 返回值: Protocol* 类型的指针数组.描述类中包含的协议.父类的协议不包含其中.数组中包含*outCount指针,并庚随一个空的终止符.必须使用free()函数释放数组.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 返回值: 如果cls中没有协议,或者cls为Nil,返回NULL并且*outCount为0</span><span class="hljs-comment"> **/</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyProtocolList(<span class="hljs-params">_</span> <span class="hljs-params">cls</span>: AnyClass?,<span class="hljs-params">_</span> <span class="hljs-params">outCount</span>: UnsafeMutablePointer&lt;UInt32&gt;?)</span>  -&gt; AutoreleasingUnsafeMutablePointer&lt;Protocol&gt;?<span class="hljs-comment">//返回类定义的版本号</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_getVersion(AnyClass?)</span><span class="hljs-comment">//设置一个类定义的版本号</span>func <span class="hljs-keyword">class</span><span class="hljs-constructor">_setVersion(AnyClass, Int32)</span></code></pre><h3 id="添加Class"><a href="#添加Class" class="headerlink" title="添加Class"></a>添加Class</h3><pre><code class="hljs swift"><span class="hljs-comment">/*</span><span class="hljs-comment"> 创建一个类和元类</span><span class="hljs-comment"> </span><span class="hljs-comment"> superclass: 新创建类的父类.如果创建一个根类则为Nil</span><span class="hljs-comment"> name: 新创建类的类名.该字符串会被拷贝.</span><span class="hljs-comment"> extraBytes: 类和元类末尾为索引实例变量而分配的字节数.通常为0</span><span class="hljs-comment"> 返回值: 新创建的类.或者为Nil如果该类无法被创建(比如使用的名字已经被使用)</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 可以获取新创建元类的指针通过调用object_getClass(newClass).</span><span class="hljs-comment"> 创建一个类.需要先调用objc_allocateClassPair(_:_:_:).然后设置类的特性使用诸如class_addMethod(_:_:_:_:)和class_addIvar(_:_:_:_:_:)这些方法.当你创建完该类后.调用objc_registerClassPair(_:)注册该类后才可以使用.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 实例方法和实例变量应该添加到自身类中.类方法应该添加到元类中.</span><span class="hljs-comment"> </span><span class="hljs-comment"> **/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_allocateClassPair</span><span class="hljs-params">(<span class="hljs-number">_</span> superclass: AnyClass?, <span class="hljs-number">_</span> name: UnsafePointer&lt;Int8&gt;, <span class="hljs-number">_</span> extraBytes: Int)</span></span> -&gt; <span class="hljs-type">AnyClass?</span><span class="hljs-comment">/*</span><span class="hljs-comment"> 销毁一个类和它关联的元类.</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 如果cls类实例或者它的任何子类存在的话,不要调用该函数.</span><span class="hljs-comment"> **/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_disposeClassPair</span><span class="hljs-params">(<span class="hljs-number">_</span> cls: AnyClass)</span></span><span class="hljs-comment">//注册一个类 该类已使用objc_allocateClassPair(_:_:_:)方法创建</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_registerClassPair</span><span class="hljs-params">(AnyClass)</span></span><span class="hljs-comment">/*</span><span class="hljs-comment"> 在Foundation框架下的KVO使用</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 自身不要调用该函数</span><span class="hljs-comment"> **/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_duplicateClass</span><span class="hljs-params">(AnyClass, UnsafePointer&lt;Int8&gt;, Int)</span></span></code></pre><h3 id="与实例一起使用"><a href="#与实例一起使用" class="headerlink" title="与实例一起使用"></a>与实例一起使用</h3><pre><code class="hljs swift"><span class="hljs-comment">/*</span><span class="hljs-comment"> 读取一个对象中实例变量的值</span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 如果实例变量名已知的话,object_getIvar(_:_:)比object_getInstanceVariable获取值更快一些.</span><span class="hljs-comment"> **/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">object_getIvar</span><span class="hljs-params">(<span class="hljs-number">_</span> obj: <span class="hljs-keyword">Any</span>?,<span class="hljs-number">_</span> ivar: Ivar)</span></span> -&gt; <span class="hljs-type">Any?</span><span class="hljs-comment">//设置一个对象实例变量的值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">object_setIvar</span><span class="hljs-params">(<span class="hljs-number">_</span> obj: <span class="hljs-keyword">Any</span>?,<span class="hljs-number">_</span> ivar: Ivar,<span class="hljs-number">_</span> varlue: <span class="hljs-keyword">Any</span>?)</span></span><span class="hljs-comment">//返回某对象的类名</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">object_getClassName</span><span class="hljs-params">(_obj: <span class="hljs-keyword">Any</span>?)</span></span><span class="hljs-comment">//返回实例对象的类对象</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">object_getClass</span><span class="hljs-params">(<span class="hljs-number">_</span> obj: <span class="hljs-keyword">Any</span>?)</span></span> -&gt; <span class="hljs-type">AnyClass?</span><span class="hljs-comment">//设置一个对象的类 返回值为对象之前所属的类对象.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">object_setClass</span><span class="hljs-params">(<span class="hljs-number">_</span> obj: <span class="hljs-keyword">Any</span>?,<span class="hljs-number">_</span> cls: AnyClass)</span></span> -&gt; <span class="hljs-type">AnyClass?</span></code></pre><h3 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h3><pre><code class="hljs go"><span class="hljs-comment">//获取已注册类定义的列表</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_getClassList</span><span class="hljs-params">(AutoreleasingUnsafeMutablePointer&lt;AnyClass&gt;?, Int32)</span></span><span class="hljs-comment">//创建并且返回所有已注册的类定义的指针列表</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_copyClassList</span><span class="hljs-params">(UnsafeMutablePointer&lt;UInt32&gt;?)</span></span><span class="hljs-comment">//返回某个类的类定义</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_lookUpClass</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;)</span></span><span class="hljs-comment">//返回某个类的类定义</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_getClass</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;)</span></span><span class="hljs-comment">//返回某个类的类定义</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_getRequiredClass</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;)</span></span><span class="hljs-comment">//返回某个类的元类定义</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_getMetaClass</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;)</span></span></code></pre><h3 id="与实例变量一起使用"><a href="#与实例变量一起使用" class="headerlink" title="与实例变量一起使用"></a>与实例变量一起使用</h3><pre><code class="hljs go"><span class="hljs-comment">//返回实例变量名称</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ivar_getName</span><span class="hljs-params">(Ivar)</span></span><span class="hljs-comment">//返回实例变量的类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ivar_getTypeEncoding</span><span class="hljs-params">(Ivar)</span></span><span class="hljs-comment">//返回一个实例变量相对内存基址的偏移值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ivar_getOffset</span><span class="hljs-params">(Ivar)</span></span></code></pre><h3 id="关联引用"><a href="#关联引用" class="headerlink" title="关联引用"></a>关联引用</h3><pre><code class="hljs swift"><span class="hljs-comment">//使用指定key和关联策略设置某个对象的关联值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_setAssociateObject</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>, UnsafeRawPointer, <span class="hljs-keyword">Any</span>?, objc_AssociationPoicy)</span></span><span class="hljs-comment">//返回某个对象该key下对应的关联值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_getAssociateObject</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>, UnsafeRawPointer)</span></span><span class="hljs-comment">//移除某个对象所有关联对象</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_removeAssociateObjects</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>)</span></span></code></pre><h3 id="与方法一起使用"><a href="#与方法一起使用" class="headerlink" title="与方法一起使用"></a>与方法一起使用</h3><pre><code class="hljs swift"><span class="hljs-comment">/*</span><span class="hljs-comment"> 返回方法的SEL</span><span class="hljs-comment"> </span><span class="hljs-comment"> 讨论:</span><span class="hljs-comment"> 获取C字符串的方法名.调用sel_getName(method_getName(method))</span><span class="hljs-comment"> **/</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_getName</span><span class="hljs-params">(<span class="hljs-number">_</span> m: Method)</span></span> -&gt; <span class="hljs-type">Selector</span><span class="hljs-comment">//返回IMP类型的函数指针</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_getImplementation</span><span class="hljs-params">(<span class="hljs-number">_</span> m: Method)</span></span> -&gt; <span class="hljs-type">IMP</span><span class="hljs-comment">//返回一个字符串描述方法的参数和返回类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_getTypeEncoding</span><span class="hljs-params">(<span class="hljs-number">_</span> m: Method)</span></span> -&gt; <span class="hljs-type">UnsafePointer</span>&lt;<span class="hljs-type">Int8</span>&gt;?<span class="hljs-comment">//返回一个字符串描述方法的返回类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_copyReturnType</span><span class="hljs-params">(Method)</span></span><span class="hljs-comment">//返回一个字符串描述方法的单个参数类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_copyArgumentType</span><span class="hljs-params">(Method, UInt32)</span></span><span class="hljs-comment">//通过引用返回一个字符串描述方法的返回值类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_getReturnType</span><span class="hljs-params">(Method, UInt32)</span></span><span class="hljs-comment">//返回一个方法接受的参数数量</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_getNumberOfArguments</span><span class="hljs-params">(Method)</span></span><span class="hljs-comment">//通过引用返回一个字符串描述方法单个参数的类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_getArgumentType</span><span class="hljs-params">(Method, UInt32, UnsafeMutablePointer&lt;Int8&gt;?, Int)</span></span><span class="hljs-comment">//返回某个方法的结构描述</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_getDescription</span><span class="hljs-params">(Method)</span></span><span class="hljs-comment">//设置某个方法的实现</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_setImplementation</span><span class="hljs-params">(<span class="hljs-number">_</span> m: Method, <span class="hljs-number">_</span> imp: IMP)</span></span> -&gt; <span class="hljs-type">IMP</span><span class="hljs-comment">/*</span><span class="hljs-comment"> 交换两个方法的实现</span><span class="hljs-comment"> </span><span class="hljs-comment"> IMP imp1 = method_getImplementation(m1);</span><span class="hljs-comment"> IMP imp2 = method_getImplementation(m2);</span><span class="hljs-comment"> method_setImplementation(m1, imp2);</span><span class="hljs-comment"> method_setImplementation(m2, imp1);</span><span class="hljs-comment"> </span><span class="hljs-comment"> **/</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method_exchangeImplementations</span><span class="hljs-params">(_m1: Method,<span class="hljs-number">_</span> m2: Method)</span></span></code></pre><h3 id="与库一起使用"><a href="#与库一起使用" class="headerlink" title="与库一起使用"></a>与库一起使用</h3><pre><code class="hljs go"><span class="hljs-comment">//返回所有加载的OC框架和动态库名称  </span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_copyImageNames</span><span class="hljs-params">(UnsafeMutablePointer&lt;UInt32&gt;?)</span></span><span class="hljs-comment">//返回动态库中一个类的原始格式的名称</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_getImageName</span><span class="hljs-params">(AnyClass?)</span></span><span class="hljs-comment">//返回某个库或者框架中所有类的名称</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_copyClassNameForImage</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;, UnsafeMutablePointer&lt;UInt32&gt;?)</span></span></code></pre><h3 id="与Selectors一起使用"><a href="#与Selectors一起使用" class="headerlink" title="与Selectors一起使用"></a>与Selectors一起使用</h3><pre><code class="hljs go"><span class="hljs-comment">//返回某一方法的名称</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sel_getName</span><span class="hljs-params">(Selector)</span></span><span class="hljs-comment">//在OC runtime系统中注册一个方法,映射方法名到一个selector,并且返回selector的值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sel_registerName</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;)</span></span><span class="hljs-comment">//注册一个方法名到 OC runtime系统中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sel_getUid</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;)</span></span><span class="hljs-comment">//返回一个布尔值 表示两个方法是否相等</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sel_isEqual</span><span class="hljs-params">(Selector, Selector)</span></span></code></pre><h3 id="与协议一起使用"><a href="#与协议一起使用" class="headerlink" title="与协议一起使用"></a>与协议一起使用</h3><pre><code class="hljs swift"><span class="hljs-comment">//返回指定协议</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_getProtocol</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;)</span></span><span class="hljs-comment">//以数组形式返回runtime中所有已知协议</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_copyProtocolList</span><span class="hljs-params">(UnsafeMutablePointer&lt;UInt32&gt;)</span></span><span class="hljs-comment">//创建一个协议实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_allocateProtocol</span><span class="hljs-params">(UnsafePointer&lt;Int8&gt;)</span></span><span class="hljs-comment">//在OC运行时系统中注册一个新协议</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_registerProtocol</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>)</span></span><span class="hljs-comment">//给协议添加一个方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_addMethodDescription</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>, Selector, UnsafePointer&lt;Int8&gt;?, Bool, Bool)</span></span><span class="hljs-comment">//添加注册过的协议到正在构建的协议中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_addProtocol</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>, <span class="hljs-keyword">Protocol</span>)</span></span><span class="hljs-comment">//添加属性到正在构建的协议中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_addProperty</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>, UnsafePointer&lt;Int8&gt;, UnsafePointer&lt;objc_property_attribute_t&gt;?, UInt32, Bool, Bool)</span></span><span class="hljs-comment">//返回协议名称</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_getName</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>)</span></span><span class="hljs-comment">//返回布尔值 表示是否两个协议相等</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_isEqual</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>?, <span class="hljs-keyword">Protocol</span>?)</span></span><span class="hljs-comment">//返回满足给定协议的方法描述数组</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_copyMethodDescriptionList</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>, Bool, Bool, UnsafeMutablePointer&lt;UInt32&gt;?)</span></span><span class="hljs-comment">//返回满足给定协议的指定方法的方法描述</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_getMethodDescription</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>, Selector, Bool, Bool)</span></span><span class="hljs-comment">//返回一个协议声明的属性数组</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_copyPropertyList</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>, UnsafeMutablePointer&lt;UInt32&gt;)</span></span><span class="hljs-comment">//返回给定协议的指定属性</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_getProperty</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>, UnsafePointer&lt;Int8&gt;, Bool, Bool)</span></span><span class="hljs-comment">//返回适用某协议的协议数组</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_copyProtocolList</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>, UnsafeMutablePointer&lt;UInt32&gt;)</span></span><span class="hljs-comment">//返回一个布尔值 表示是否一个协议遵循另一个协议</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">protocol_comformsToProtocol</span><span class="hljs-params">(<span class="hljs-keyword">Protocol</span>?, <span class="hljs-keyword">Protocol</span>?)</span></span></code></pre><h3 id="与属性一起使用"><a href="#与属性一起使用" class="headerlink" title="与属性一起使用"></a>与属性一起使用</h3><pre><code class="hljs reasonml"><span class="hljs-comment">//返回属性名</span>func property<span class="hljs-constructor">_getName(<span class="hljs-params">_</span> <span class="hljs-params">property</span>: <span class="hljs-params">objc_property_t</span>)</span> -&gt; UnsafePointer&lt;Int8&gt;<span class="hljs-comment">//返回一个属性的的特征字符串</span>func property<span class="hljs-constructor">_getAttributes(<span class="hljs-params">_</span> <span class="hljs-params">property</span>: <span class="hljs-params">objc_property_t</span>)</span> -&gt; UnsafePointer&lt;Int8&gt;<span class="hljs-comment">//返回指定特征名的属性值</span>func property<span class="hljs-constructor">_copyAttributeValue(<span class="hljs-params">_</span> <span class="hljs-params">property</span>: <span class="hljs-params">objc_property_t</span>,<span class="hljs-params">_</span> <span class="hljs-params">attributeName</span>: UnsafePointer&lt;Int8&gt;)</span> -&gt; UnsafeMutablePointer&lt;Int8&gt;?<span class="hljs-comment">//返回指定属性的属性特征数组</span>func property<span class="hljs-constructor">_copyAttributeList(<span class="hljs-params">_</span> <span class="hljs-params">property</span>: <span class="hljs-params">objc_property_t</span>, <span class="hljs-params">_</span> <span class="hljs-params">outCount</span>: UnsafeMutablePointer&lt;UInt32&gt;?)</span> -&gt; UnsafeMutablePointer&lt;objc_property_attribute_t&gt;?</code></pre><h3 id="OC语言特色的使用"><a href="#OC语言特色的使用" class="headerlink" title="OC语言特色的使用"></a>OC语言特色的使用</h3><pre><code class="hljs swift"><span class="hljs-comment">//当在foreach迭代中检测到一个突变时，由编译器插入。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_enumerationMutation</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>)</span></span><span class="hljs-comment">//设置当前的突变处理</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_setEnumerationMutationHandler</span><span class="hljs-params">(<span class="hljs-params">(<span class="hljs-params">(<span class="hljs-keyword">Any</span>)</span></span></span></span> -&gt; <span class="hljs-type">Void</span>)?)<span class="hljs-comment">//给一个函数创建一个指针  当方法被调用的使用调用指定Block</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imp_implementationWithBlock</span><span class="hljs-params">(<span class="hljs-keyword">Any</span>)</span></span><span class="hljs-comment">//返回与一个已经创建使用的IMP关联的Block</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imp_getBlock</span><span class="hljs-params">(IMP)</span></span><span class="hljs-comment">//取消与已经创建使用的IMP关联的Block</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">imp_removeBlock</span><span class="hljs-params">(IMP)</span></span><span class="hljs-comment">//加载被弱引用的对象并返回它</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_loadWeak</span><span class="hljs-params">()</span></span><span class="hljs-comment">//存储一个弱引用变量值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">objc_storeWeak</span><span class="hljs-params">(AutoreleasingUnsafeMutablePointer&lt;AnyObject?&gt;, <span class="hljs-keyword">Any</span>?)</span></span></code></pre><h3 id="类定义数据结构"><a href="#类定义数据结构" class="headerlink" title="类定义数据结构"></a>类定义数据结构</h3><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在类定义中表示一个方法类型typealias Method<span class="hljs-regexp">//</span>表示一个实例变量类型typealias Ivar<span class="hljs-regexp">//</span>表示一个分类类型typealias Category<span class="hljs-regexp">//</span>表示一个OC声明的属性类型typealias objc_property_t<span class="hljs-regexp">//</span>定义一个OC方法struct objc_method_description<span class="hljs-regexp">//</span>定义一个属性特性struct objc_property_attribute_t</code></pre><h3 id="实例数据类型"><a href="#实例数据类型" class="headerlink" title="实例数据类型"></a>实例数据类型</h3><p>  这些是表示对象,类,父类的数据类型</p><ul><li>objc_object 指向一个实例对象的指针</li><li>objc_object 表示一个实例对象</li><li>objc_super  一个实例对象的父类</li></ul><pre><code class="hljs gauss"><span class="hljs-comment">//一个类的实例的指针</span><span class="hljs-keyword">struct</span> <span class="hljs-type">objc_object</span>//指定实例对象的父类<span class="hljs-type">struct</span> objc_super</code></pre>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScriptCore与WebView</title>
    <link href="/blog/2017/11/07/iOS/JavaScriptCore%E4%B8%8EWebView/"/>
    <url>/blog/2017/11/07/iOS/JavaScriptCore%E4%B8%8EWebView/</url>
    
    <content type="html"><![CDATA[<h3 id="Html中JS-与-Native交互情况"><a href="#Html中JS-与-Native交互情况" class="headerlink" title="Html中JS 与 Native交互情况"></a>Html中JS 与 Native交互情况</h3><ul><li>Native调用JS</li><li>JS调用Native</li></ul><h3 id="一-获取WebView的JSContext"><a href="#一-获取WebView的JSContext" class="headerlink" title="一.  获取WebView的JSContext"></a>一.  获取WebView的JSContext</h3><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">webViewDidFinishLoad</span><span class="hljs-params">(<span class="hljs-number">_</span> webView: UIWebView)</span></span> &#123;        <span class="hljs-keyword">self</span>.context = webView.value(forKeyPath: <span class="hljs-string">&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>) <span class="hljs-keyword">as</span>? <span class="hljs-type">JSContext</span>&#125;</code></pre><blockquote><p>不同网页JSContext不同,只有在 webViewDidFinishLoad() 方法中获取,才能获取当前网页的JSContext</p></blockquote><h3 id="二-Native调用JS"><a href="#二-Native调用JS" class="headerlink" title="二.   Native调用JS"></a>二.   Native调用JS</h3><p>Html中JS提供的接口</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">argument</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;jsContent&quot;</span>).innerHTML = argument[<span class="hljs-string">&quot;name&quot;</span>] + <span class="hljs-string">&quot; &quot;</span> + argument[<span class="hljs-string">&quot;age&quot;</span>] + <span class="hljs-string">&quot;岁 &quot;</span> +  argument[<span class="hljs-string">&quot;job&quot;</span>]</span>      &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>Native调用方法</p><pre><code class="hljs swift"> <span class="hljs-comment">//本地调用JS方法</span><span class="hljs-meta">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nativeCallJS</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">//方法一 (直接执行JS脚本)</span>    <span class="hljs-keyword">let</span> scriptStr = <span class="hljs-string">&quot;handler(&#123;&#x27;name&#x27;:&#x27;小明&#x27;, &#x27;age&#x27;:&#x27;18&#x27;,&#x27;job&#x27;:&#x27;学生&#x27;&#125;)&quot;</span>    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-keyword">self</span>.context?.evaluateScript(scriptStr)        <span class="hljs-comment">//方法二 (获取函数,然后调用函数传参)</span>    <span class="hljs-keyword">let</span> handleFunc = <span class="hljs-keyword">self</span>.context?.objectForKeyedSubscript(<span class="hljs-string">&quot;handler&quot;</span>)    <span class="hljs-keyword">let</span> paraDic = [<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&quot;job&quot;</span>:<span class="hljs-string">&quot;学生&quot;</span>] <span class="hljs-keyword">as</span> [<span class="hljs-type">String</span> : <span class="hljs-type">Any</span>]    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = handleFunc?.call(withArguments: [paraDic])&#125;</code></pre><h3 id="三-JS调用Native"><a href="#三-JS调用Native" class="headerlink" title="三.    JS调用Native"></a>三.    JS调用Native</h3><h4 id="方式一-使用Block-Swift-用闭包"><a href="#方式一-使用Block-Swift-用闭包" class="headerlink" title="方式一: 使用Block(Swift 用闭包)"></a>方式一: 使用Block(Swift 用闭包)</h4><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)webViewDidFinishLoad:(<span class="hljs-built_in">UIWebView</span> *)webView&#123;    <span class="hljs-comment">//获取JS运行环境</span>    _context = [webView valueForKeyPath:<span class="hljs-string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];    <span class="hljs-comment">//html调用无参数OC</span>    _context[<span class="hljs-string">@&quot;test1&quot;</span>] = ^()&#123;        [<span class="hljs-keyword">self</span> method1];    &#125;;        _context[<span class="hljs-string">@&quot;test2&quot;</span>] = ^()&#123;                <span class="hljs-built_in">NSArray</span> *args = [JSContext currentArguments];<span class="hljs-comment">//传过来的参数</span>        <span class="hljs-built_in">NSString</span> *name = args[<span class="hljs-number">0</span>];        <span class="hljs-built_in">NSString</span> *str = args[<span class="hljs-number">1</span>];        [<span class="hljs-keyword">self</span> method2:name and:str];    &#125;;&#125;</code></pre><h4 id="方式二-使用JSExport"><a href="#方式二-使用JSExport" class="headerlink" title="方式二: 使用JSExport"></a>方式二: 使用JSExport</h4><pre><code class="hljs swift"><span class="hljs-meta">@objc</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">SwiftBridgeProtocol</span>: <span class="hljs-title">JSExport</span></span>&#123;       <span class="hljs-comment">//JS调用本地方法(无参数)</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-number">_</span> title: String, <span class="hljs-number">_</span> message: String)</span></span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method3</span><span class="hljs-params">(<span class="hljs-number">_</span> handlerName: String)</span></span>&#125;<span class="hljs-meta">@objc</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwiftBrige</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">SwiftBridgeProtocol</span></span>&#123;        <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> controller: <span class="hljs-type">UIViewController?</span>    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> context   : <span class="hljs-type">JSContext?</span>        <span class="hljs-comment">//JS调用本地方法(无参数)</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>  &#123;                <span class="hljs-keyword">let</span> controller = <span class="hljs-type">UIAlertController</span>.<span class="hljs-keyword">init</span>(title: <span class="hljs-string">&quot;测试&quot;</span>, message: <span class="hljs-string">&quot;JS调用本地方法&quot;</span>, preferredStyle: .alert)        controller.addAction(<span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-string">&quot;取消&quot;</span>, style: .cancel, handler: <span class="hljs-literal">nil</span>))        <span class="hljs-keyword">self</span>.controller?.present(controller, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)    &#125;        <span class="hljs-comment">//JS调用本地方法(传参数)</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-number">_</span> title: String, <span class="hljs-number">_</span> message: String)</span></span> &#123;                <span class="hljs-keyword">let</span> controller = <span class="hljs-type">UIAlertController</span>.<span class="hljs-keyword">init</span>(title: title, message: message, preferredStyle: .alert)        controller.addAction(<span class="hljs-type">UIAlertAction</span>(title: <span class="hljs-string">&quot;取消&quot;</span>, style: .cancel, handler: <span class="hljs-literal">nil</span>))        <span class="hljs-keyword">self</span>.controller?.present(controller, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)    &#125;        <span class="hljs-comment">//JS调用本地方法  本地方法回调JS方法</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">method3</span><span class="hljs-params">(<span class="hljs-number">_</span> handlerName: String)</span></span>&#123;                <span class="hljs-comment">//回调参数</span>        <span class="hljs-keyword">let</span> paraDic = [<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>, <span class="hljs-string">&quot;job&quot;</span>:<span class="hljs-string">&quot;学生&quot;</span>] <span class="hljs-keyword">as</span> [<span class="hljs-type">String</span> : <span class="hljs-type">Any</span>]                <span class="hljs-comment">//获取JS回调函数</span>        <span class="hljs-keyword">let</span> handleFunc = <span class="hljs-keyword">self</span>.context?.objectForKeyedSubscript(<span class="hljs-string">&quot;\(handlerName)&quot;</span>)                <span class="hljs-comment">//调用该函数</span>        <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = handleFunc?.call(withArguments: [paraDic])    &#125;&#125;</code></pre><p><a href="https://github.com/913868456/SwiftDemo">项目代码Swift</a><br><a href="https://github.com/913868456/OCDemo">项目代码OC</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScriptCore</tag>
      
      <tag>WebView</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreNFC</title>
    <link href="/blog/2017/10/30/iOS/CoreNFC/"/>
    <url>/blog/2017/10/30/iOS/CoreNFC/</url>
    
    <content type="html"><![CDATA[<p>检测NFC 设备并读取里面包含的NDEF格式数据.</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>使用CoreNFC,你能够读取(目前只能读取) 1-5种NDEF格式的Near Field Communication(NFC)设备信息.为了读取NFC信息,你的app需要创建一个NDEF reader session 并且实现相关协议.一个运行的reader session 会查询NFC设备并且返回它包含的NDEF信息时,会调用相关协议方法.代理对象能够读取相关信息并决定reader session 是否失效.</p><blockquote><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>读取NFC数据的设备仅支持iPhone 7 以上机型<br>当前的NFC芯片,大部分读取不到信息,必须是标准的NFCNDEF格式写入的芯片才能读取.(北京地铁卡,门禁卡,身份证等卡片测试的时候无法识别,反正我是什么都没有读到,就出现一个调取NFC的界面,然后就没有然后了…)</p></blockquote><h4 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h4><ul><li>开启NFC功能(如果你的证书勾选自动管理的话, TARGETS -&gt; Capabilities -&gt; Near Field Communication Tag Reading 勾选ON),然后会自动创建一个 “项目名.entitlements” 文件.</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/3340896-88ca287b76f4f852.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开启NFC.jpeg"></p><ul><li><p>证书对工程进行授权<br><img src="http://upload-images.jianshu.io/upload_images/3340896-ab200d5472bdfcf5.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TestNFC.entitlements"></p></li><li><p>info.plist 文件中添加隐私访问权限申请.<br><img src="http://upload-images.jianshu.io/upload_images/3340896-e6375dba9089d513.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="info.plist"></p></li></ul><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span>, <span class="hljs-title">NFCNDEFReaderSessionDelegate</span> </span>&#123;        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">super</span>.viewDidLoad()                <span class="hljs-comment">//判断设备是否支持NFC,支持创建NFC对话对象</span>        <span class="hljs-keyword">if</span> <span class="hljs-type">NFCNDEFReaderSession</span>.readingAvailable == <span class="hljs-literal">true</span> &#123;                        <span class="hljs-keyword">let</span> session = <span class="hljs-type">NFCNDEFReaderSession</span>.<span class="hljs-keyword">init</span>(delegate: <span class="hljs-keyword">self</span>, queue: <span class="hljs-literal">nil</span>, invalidateAfterFirstRead: <span class="hljs-literal">false</span>)            session.alertMessage = <span class="hljs-string">&quot;请将卡片靠近手机&quot;</span>            session.begin()        &#125;    &#125;        <span class="hljs-comment">// MARK: - NFCNDEFReaderSessionDelegate</span>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readerSession</span><span class="hljs-params">(<span class="hljs-number">_</span> session: NFCNDEFReaderSession, didInvalidateWithError error: Error)</span></span> &#123;        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">&quot;\(session)\n\(error)&quot;</span>)    &#125;        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readerSession</span><span class="hljs-params">(<span class="hljs-number">_</span> session: NFCNDEFReaderSession, didDetectNDEFs messages: [NFCNDEFMessage])</span></span> &#123;        <span class="hljs-built_in">debugPrint</span>(<span class="hljs-string">&quot;\(session)\n\(messages)&quot;</span>)    &#125;&#125;</code></pre><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><h4 id="Reader-Session"><a href="#Reader-Session" class="headerlink" title="Reader Session"></a>Reader Session</h4><pre><code class="hljs markdown">class [<span class="hljs-string">NFCNDEFReaderSession </span>](<span class="hljs-link"></span>)//reader session 类  用来探测NFC设备的NDEF数据.//实例创建init(delegate: NFCNDEFReaderSessionDelegate, queue: DispatchQueue?, invalidateAfterFirstRead: Bool)//参数介绍://delegate: 代理对象//queue    : 代理对象回调被分派的队列.  可选值, 置为nil 后,会在内部为该会话创建一个串行队列//invalidateAfterFirRead: 设备第一次成功读取到信息后,reader session是否自动失效. 一般填false//设备可用性检查//类属性,返回设备是否支持NFC读取功能class var readingAvailable: Bool protocol [<span class="hljs-string">NFCReaderSessionProtocol</span>](<span class="hljs-link"></span>)//通用交互接口协议  用来跟reader session进行交互// 会话检测到NDEF信息func readerSession(NFCNDEFReaderSession, didDetectNDEFs: [NFCNDEFMessage])// 会话失效,返回错误信息func readerSession(NFCNDEFReaderSession, didInvalidateWithError: Error)class [<span class="hljs-string">NFCReaderSession</span>](<span class="hljs-link"></span>)// NFCNDEFReaderSession 的基类.</code></pre><hr><h4 id="NDEF-Messages"><a href="#NDEF-Messages" class="headerlink" title="NDEF Messages"></a>NDEF Messages</h4><pre><code class="hljs markdown">class   [<span class="hljs-string">NFCNDEFMessage</span>](<span class="hljs-link"></span>)//  records 属性是[NFCNDEFPayload]数组class  [<span class="hljs-string">NFCNDEFPayload</span>](<span class="hljs-link"></span>)//  NFC NDEF信息的载体//载体的idvar identifier : Data// 数据内容,这是我们需要读取的二进制信息var payload: Data// 载体类型var type      : Data // 类型格式名  枚举值var typeNameFormat: NFCTypeNameFormatenum [<span class="hljs-string">NFCTypeNameFormat</span>](<span class="hljs-link"></span>)//枚举值 标明NFC NDEF信息的格式</code></pre><h4 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h4><pre><code class="hljs markdown">struct [<span class="hljs-string">NFCReaderError</span>](<span class="hljs-link"></span>)//结构体 reader session的错误类型</code></pre>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreNFC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dispatch</title>
    <link href="/blog/2017/10/27/iOS/Dispatch/"/>
    <url>/blog/2017/10/27/iOS/Dispatch/</url>
    
    <content type="html"><![CDATA[<h1 id="DispatchQueue"><a href="#DispatchQueue" class="headerlink" title="DispatchQueue"></a>DispatchQueue</h1><p>该类管理任务项的执行.每个提交到一个队列中的任务项将被系统管理的线程池处理.<br><a href="https://github.com/913868456/SwiftDemo">测试Demo</a></p><h2 id="同步和异步执行"><a href="#同步和异步执行" class="headerlink" title="同步和异步执行"></a>同步和异步执行</h2><p>每个任务项可以被同步或者异步执行.当一个任务项使用同步方法执行时,程序会直到执行项执行完毕才返回.当一个任务项使用异步方法执行时,异步方法会马上返回</p><h2 id="串行和并行队列"><a href="#串行和并行队列" class="headerlink" title="串行和并行队列"></a>串行和并行队列</h2><p>一个分发队列可以是串行队列,任务项一次只能执行一个.或者是并行队列,任务项目被序列化,但是却可以一次全部运行或者在任何顺序下终止.<br>串行或者并行队列处理工作项都遵循FIFO原则</p><blockquote><h2 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h2><p> 尝试同步执行工作项在主队列容易导致死锁.</p></blockquote><h2 id="全局队列-global-concurrent-queue"><a href="#全局队列-global-concurrent-queue" class="headerlink" title="全局队列(global concurrent queue)"></a>全局队列(global concurrent queue)</h2><p>全局队列是并行队列，系统创建了许多全局队列供程序使用</p><h2 id="DispatchQueue-1"><a href="#DispatchQueue-1" class="headerlink" title="DispatchQueue"></a>DispatchQueue</h2><p>Dispatchqueue  管理任务项的执行。每个提交到队列中的任务项被系统管理的线程池处理。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code class="hljs less">实例创建<span class="hljs-selector-tag">init</span>(<span class="hljs-attribute">__label</span>: UnsafePointer&lt;Int8&gt;?, <span class="hljs-attribute">attr</span>: __OS_dispatch_queue_attr?)参数介绍<span class="hljs-selector-tag">label</span>:  <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.myqueue</span> (可不填)，主要功能是标记线程，方便调试。<span class="hljs-selector-tag">attr</span> :  <span class="hljs-selector-tag">DISPATCH_QUEUE_SERIAL</span>; <span class="hljs-selector-tag">DISPATCH_QUEUE_CONCURRENT</span>; 标明创建的是串行队列还是并行队列。<span class="hljs-selector-tag">init</span>(<span class="hljs-attribute">label</span>: String, <span class="hljs-attribute">qos</span>: DispatchQoS, <span class="hljs-attribute">attributes</span>: DispatchQueue.Attributes, <span class="hljs-attribute">autoreleaseFrequency</span>: DispatchQueue.AutoreleaseFrequency, <span class="hljs-attribute">target</span>: DispatchQueue?)参数介绍<span class="hljs-selector-tag">attributes</span>: <span class="hljs-selector-tag">concurrent</span> 可以用来创建并行队列<span class="hljs-selector-tag">QoS</span>  : 枚举（<span class="hljs-selector-tag">unspecified</span>,<span class="hljs-selector-tag">background</span>,<span class="hljs-selector-tag">utility</span>,<span class="hljs-selector-tag">default</span>,<span class="hljs-selector-tag">userInitiated</span>,<span class="hljs-selector-tag">userInterractive</span>）优先级从低到高,在有优先级需求的时候使用.<span class="hljs-selector-tag">target</span>: 可以将队列添加到一个某个目标队列，最终将在目标队列执行。实例方法同步方法<span class="hljs-comment">// 提交block到一个队列中执行，直到那个block完成。</span><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">sync</span>(<span class="hljs-attribute">execute</span>: () -&gt; Void)<span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">sync</span>(<span class="hljs-attribute">execute</span>: DispatchWorkItem)异步方法<span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">async</span>(<span class="hljs-attribute">execute</span>: DispatchWorkItem)类属性<span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">main</span>: <span class="hljs-selector-tag">DispatchQueue</span>类方法<span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">concurrentPerform</span>(<span class="hljs-attribute">iterations</span>: Int, execute <span class="hljs-attribute">work</span>: (Int) -&gt; Void)<span class="hljs-selector-tag">iterations</span>: 迭代次数其他方法<span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">setTarget</span>(<span class="hljs-attribute">queue</span>: DispatchQueue?)参数说明: 对象所在的新的目标队列.这个队列引用加一,之前所在队列,如果可能的话,将被释放.这个参数不能为<span class="hljs-selector-tag">NULL</span> 讨论目标队列为对象处理负责.目标队列决定了对象的析构器的调用.更改对象的目标队列会改变他们的行为.如果提交一个<span class="hljs-selector-tag">block</span>到串行队列,串行队列的目标队列是一个不同的串行队列,该<span class="hljs-selector-tag">Block</span>不会与提交到目标队列的其他<span class="hljs-selector-tag">Block</span>并发调用或者说其他与该队列拥有相同目标队列的队列并发执行.<span class="hljs-selector-tag">Dispatch</span> <span class="hljs-selector-tag">souces</span>: 分发源的目标队列明确了(事件处理和取消)的位置.全局队列明确优先级,获取一个具有优先级别的全局队列.<span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">global</span>(<span class="hljs-attribute">qos</span>: DispatchQoS.QoSClass)</code></pre><p>用一个表格来表示串并行队列同步异步执行的情况</p><table><thead><tr><th></th><th>同步执行</th><th>异步执行</th></tr></thead><tbody><tr><td>串行队列</td><td>当前线程，一个一个执行</td><td>其他线程，一个一个执行</td></tr><tr><td>并行队列</td><td>当前线程，一个一个执行</td><td>多个线程，一起执行</td></tr></tbody></table><h1 id="DispatchWorkItem"><a href="#DispatchWorkItem" class="headerlink" title="DispatchWorkItem"></a>DispatchWorkItem</h1><p>DispatchWorkItem包含能够被执行的任务。一个任务项能够被分配至DispatchQueue 和 DispatchGroup.一个任务项也能被置为一个DispatchSource 事件，注册项，或者错误处理。</p><pre><code class="hljs less">实例化<span class="hljs-selector-tag">init</span>(<span class="hljs-attribute">qos</span>: DispatchQoS = default, <span class="hljs-attribute">flags</span>: DispatchWorkItemFlags = default, <span class="hljs-attribute">block</span>: <span class="hljs-variable">@escaping</span> () -&gt; Void)参数介绍<span class="hljs-selector-tag">Qos</span>:   同上<span class="hljs-selector-tag">flags</span>: 任务项的性质，是否要创建新线程，或者创建<span class="hljs-selector-tag">barrior</span>。关于<span class="hljs-selector-tag">barrior</span>需要描述一下,网上查找的资料描述: 只针对一个并行队列.同步点之前的任务，会并发执行，到了同步点就会等待，等待同步点的任务执行完成的时候，继续后面的任务，再次并发执行项目中主要还是用到它的创建方法，其他略。</code></pre><h1 id="DispatchTime"><a href="#DispatchTime" class="headerlink" title="DispatchTime"></a>DispatchTime</h1><p>DispatchTime代表与具有纳秒（十亿分之一秒）精度的时钟相关的一个时间点。</p><pre><code class="hljs swift">实例方法<span class="hljs-comment">// 创建后即开始启动计时。</span><span class="hljs-keyword">init</span>(uptimeNanoseconds: <span class="hljs-type">UInt64</span>)实例属性<span class="hljs-comment">// 返回创建以来到当前时间的纳秒数，包含系统休眠的时间。</span><span class="hljs-keyword">var</span> uptimeNanoseconds: <span class="hljs-type">UInt64</span>类属性<span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> distantFuture: <span class="hljs-type">DispatchTime</span>类方法<span class="hljs-comment">// 返回当前时间</span><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">now</span><span class="hljs-params">()</span></span></code></pre><h2 id="DispatchTimeInterVal"><a href="#DispatchTimeInterVal" class="headerlink" title="DispatchTimeInterVal"></a>DispatchTimeInterVal</h2><p>枚举类  使用其值来确定DispatchSourceTimer启动或者I/O处理的时间间隔。</p><p>（未完待续）</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DispatchQueue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSLayoutConstraint</title>
    <link href="/blog/2017/10/19/iOS/NSLayoutConstraint/"/>
    <url>/blog/2017/10/19/iOS/NSLayoutConstraint/</url>
    
    <content type="html"><![CDATA[<h4 id="创建约束的两个方法"><a href="#创建约束的两个方法" class="headerlink" title="创建约束的两个方法"></a>创建约束的两个方法</h4><pre><code class="hljs less">方法一:<span class="hljs-comment">/* Create an array of constraints using an ASCII art-like visual format string.</span><span class="hljs-comment">*/</span><span class="hljs-selector-tag">open</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">constraints</span>(withVisualFormat <span class="hljs-attribute">format</span>: String, options <span class="hljs-attribute">opts</span>: NSLayoutFormatOptions = [], <span class="hljs-attribute">metrics</span>: [<span class="hljs-attribute">String </span>: Any]?, <span class="hljs-attribute">views</span>: [<span class="hljs-attribute">String </span>: Any]) <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-attr">[NSLayoutConstraint]</span>方法二:<span class="hljs-comment">/* Create constraints explicitly. Constraints are of the form &quot;view1.attr1 = view2.attr2 * multiplier + constant&quot;</span><span class="hljs-comment">If your equation does not have a second view and attribute, use nil and NSLayoutAttributeNotAnAttribute.</span><span class="hljs-comment">*/</span><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">convenience</span> <span class="hljs-selector-tag">init</span>(item <span class="hljs-attribute">view1</span>: Any, attribute <span class="hljs-attribute">attr1</span>: NSLayoutAttribute, relatedBy <span class="hljs-attribute">relation</span>: NSLayoutRelation, toItem <span class="hljs-attribute">view2</span>: Any?, attribute <span class="hljs-attribute">attr2</span>: NSLayoutAttribute, <span class="hljs-attribute">multiplier</span>: CGFloat, constant <span class="hljs-attribute">c</span>: CGFloat)</code></pre><h4 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h4><p>方法一:</p><p>format: VFL字符串<br>options: NSLayoutformatOptins (如果有一个则只需填写一个,若有多个则需要数组包含所有选项)<br>metrics 以字典的形式设置距离变量<br>比如 “H:|-[dis1]-[view1]-[dis2]-[view2(==view1)]-20-|”这句中的[dis1] [dis2]为视图变量,将字典的view1 view2即为key 对应相应的视图<br>views 以字典的形式设置视图变量<br>比如 “H:|-20-[view1]-20-[view2(==view1)]-20-|”这句中的[view1] [view2]为视图变量,将字典的view1 view2即为key 对应相应的视图</p><p>方法二:</p><p>view1:将要设置约束的控件<br>view2:参考控件<br>attr1:  将要设置控件的属性<br>attr2:  参考控件的属性<br>multiplier: 相乘系数<br>constant： 约束常量</p><p>view1.attr1 = view2.attr2 * multiplier + constant</p><h4 id="Visual-Format-Laguage-VFL-介绍"><a href="#Visual-Format-Laguage-VFL-介绍" class="headerlink" title="Visual Format Laguage(VFL)介绍"></a>Visual Format Laguage(VFL)介绍</h4><p>H:表示水平约束<br>V:表示垂直方向约束<br>| 表示父视图<br>-30- 表示间距30Point<br>[View] 表示UI控件View</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>“H:|-20-[aView]-15-[bView(==aView)]-20-|”<br>翻译:  水平方向约束:距离父视图左右间距为20,aView 和 bView水平间距为15,aView和bView的宽度相等.</p><h4 id="布局视图"><a href="#布局视图" class="headerlink" title="布局视图"></a>布局视图</h4><p><img src="http://upload-images.jianshu.io/upload_images/3340896-d4ba05585a04da9f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1508392677456.jpg"></p><h4 id="布局代码"><a href="#布局代码" class="headerlink" title="布局代码"></a>布局代码</h4><pre><code class="hljs groovy"><span class="hljs-comment">/**</span><span class="hljs-comment">创建两个视图,两个视图距离顶部50,距离左右边界20,两个视图间距15,等宽,等高,视图高度为150</span><span class="hljs-comment">*/</span>let aView = UIView()aView.backgroundColor = .redview.addSubview(aView)let bView = UIView()bView.backgroundColor = .brownview.addSubview(bView)<span class="hljs-comment">//关闭Autoresize,防止与AutoLayout冲突,参与布局的视图都需要关闭</span>view.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>aView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>bView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span><span class="hljs-comment">//添加两个视图的水平约束</span>let contraintsH = NSLayoutConstraint.constraints(<span class="hljs-attr">withVisualFormat:</span> <span class="hljs-string">&quot;H:|-20-[aView]-15-[bView(==aView)]-20-|&quot;</span>, <span class="hljs-attr">options:</span> [.alignAllTop, .alignAllBottom], <span class="hljs-attr">metrics:</span> nil, <span class="hljs-attr">views:</span> [<span class="hljs-string">&quot;aView&quot;</span>: aView, <span class="hljs-string">&quot;bView&quot;</span>: bView])view.addConstraints(contraintsH)<span class="hljs-comment">//添加两个视图的垂直约束</span>let contraintsV = NSLayoutConstraint.constraints(<span class="hljs-attr">withVisualFormat:</span> <span class="hljs-string">&quot;V:|-50-[aView(150)]&quot;</span>, <span class="hljs-attr">options:</span> .init(<span class="hljs-attr">rawValue:</span> <span class="hljs-number">0</span>), <span class="hljs-attr">metrics:</span> nil, <span class="hljs-attr">views:</span> [<span class="hljs-string">&quot;aView&quot;</span>: aView])view.addConstraints(contraintsV)<span class="hljs-comment">/**</span><span class="hljs-comment">aView内添加一个子视图cView,cView与aView的中心对齐,宽高是aView的一半</span><span class="hljs-comment">*/</span>let cView = UIView()cView.backgroundColor = .yellowaView.addSubview(cView)<span class="hljs-comment">//关闭autoresize</span>cView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span><span class="hljs-comment">//cView添加约束</span>let constraintX = NSLayoutConstraint.init(<span class="hljs-attr">item:</span> cView, <span class="hljs-attr">attribute:</span> .centerX, <span class="hljs-attr">relatedBy:</span> .equal, <span class="hljs-attr">toItem:</span> aView, <span class="hljs-attr">attribute:</span> .centerX, <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1.0</span>, <span class="hljs-attr">constant:</span> <span class="hljs-number">0</span>)let constraintY = NSLayoutConstraint.init(<span class="hljs-attr">item:</span> cView, <span class="hljs-attr">attribute:</span> .centerY, <span class="hljs-attr">relatedBy:</span> .equal, <span class="hljs-attr">toItem:</span> aView, <span class="hljs-attr">attribute:</span> .centerY, <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1.0</span>, <span class="hljs-attr">constant:</span> <span class="hljs-number">0</span>)let constraintsWidth = NSLayoutConstraint.init(<span class="hljs-attr">item:</span> cView, <span class="hljs-attr">attribute:</span> .width, <span class="hljs-attr">relatedBy:</span> .equal, <span class="hljs-attr">toItem:</span> aView, <span class="hljs-attr">attribute:</span> .width, <span class="hljs-attr">multiplier:</span> <span class="hljs-number">0.5</span>, <span class="hljs-attr">constant:</span> <span class="hljs-number">0</span>)let constraintsHeight = NSLayoutConstraint.init(<span class="hljs-attr">item:</span> cView, <span class="hljs-attr">attribute:</span> .height, <span class="hljs-attr">relatedBy:</span> .equal, <span class="hljs-attr">toItem:</span> aView, <span class="hljs-attr">attribute:</span> .height, <span class="hljs-attr">multiplier:</span> <span class="hljs-number">0.5</span>, <span class="hljs-attr">constant:</span> <span class="hljs-number">0</span>)aView.addConstraints([constraintX,constraintY,constraintsWidth,constraintsHeight])</code></pre>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天路旅途（二）</title>
    <link href="/blog/2017/10/15/%E9%9A%8F%E7%AC%94/%E5%A4%A9%E8%B7%AF%E6%97%85%E9%80%94%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/blog/2017/10/15/%E9%9A%8F%E7%AC%94/%E5%A4%A9%E8%B7%AF%E6%97%85%E9%80%94%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>北京到拉萨的Z21列车全程40小时10分钟，全程3757公里，从北京晚上八点钟出发，到后天12点10分才能到达拉萨，有生以来，做过的最漫长的铁路。旅行途中，要经过举世瞩目的青藏铁路。</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-58e0c0a43123ecfe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="青藏铁路格尔木至拉萨段线路图"><br>为什么说青藏铁路举世瞩目？下面请看一下青藏铁路创下的多项世界之最</p><p>1.青藏铁路是世界海拔最高的高原铁路：铁路穿越海拔4000米以上地段达960千米，最高点为海拔5072米。<br>2.青藏铁路也是世界最长的高原铁路：青藏铁路格尔木至拉萨段，穿越戈壁荒漠、沼泽湿地和雪山草原，全线总里程达1142千米。<br>3.青藏铁路还是世界上穿越冻土里程最长的高原铁路：铁路穿越多年连续冻土里程达550公里。<br>4.海拔5068米的唐古拉山车站，是世界海拔最高的铁路车站。<br>5.海拔4905米的风火山隧道，是世界海拔最高的冻土隧道。<br>6.全长1686米的昆仑山隧道，是世界最长的高原冻土隧道。<br>7.海拔4704米的安多铺架基地，是世界海拔最高的铺架基地。<br>……</p><p>更让我佩服的是，自2001年6月29日开工建设至2005年10月15日全线铺通,青藏铁路格拉段的建设历时4年多.这期间,先后十几万人上下青藏高原,奋战在被称为“ 世界第三极”的生命禁区,但是,却没有一例因高原脑水肿、肺水肿等高原常见病而死亡的事故.这是青藏铁路建设中,中国人创造的又一个世界之最。因此，我对所有参与修建青藏铁路的人员是即崇拜，又敬畏。他们不惜用生命，架起了通往雪域高原的天路。<br><img src="http://upload-images.jianshu.io/upload_images/3340896-2770bc0cf41dff66.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="天路故事"><br>2016年是青藏铁路通车10周年，中国铁路总公司拍摄的<a href="https://www.bilibili.com/video/av5041137/?from=search&seid=6581890509244381135#page=1">《天路故事》</a>，详细介绍了青藏铁路建设和通车运营期间克服的种种难题和背后的感人故事。这些内容也是我出行前做的一些小功课，以便能够更加了解和认识西藏这个神奇而又美丽的地方。</p><hr><p>北京上车的时候是晚上，所以基本上洗漱一下，玩一会儿手机就睡觉去了。旅途漫漫，总得找个人聊会儿天打磨这难捱的时光，我的对面是一对情侣，他们是在石家庄站上车的。一聊天居然是老乡，倍感亲切，话题自然而然也就多起来。他们国庆节前刚结婚，这次西藏之行是结婚旅行。了解到这些内容后，我开玩笑的说，结婚旅行怎么选这个地方，多艰苦啊。老乡说，他一个朋友在这工作，说这里风景挺不错，于是便过来玩了。我开玩笑的说，来了这次说不定还有下次。对于了解过西藏的人来说，应该都有踏上这片高原土地的梦想。反正我这个梦已经做了好久，直到现在终于实现。</p><p>旅行中还有一个趣事便是我对面的中铺。他的名字叫Tobi,德国人，来北大留学，跟着同学一块来拉萨，他们一行有十个人，有乘飞机去的，有坐火车的，坐火车的又分两拨，他有幸买到了卧铺，剩下的就只能悲催的坐硬座了。40个小时，想想心里就打颤。有趣的是在行李架上我看到一大桶农夫山泉，5L的那种。我就跟我对面老乡说，火车上不是有热水吗？他还带这一大桶水干嘛？喝不惯？后来Tobi从外边回来后，我就问他,为什么要带这么一大桶水，多累啊。他的回答让我豁然开朗，他们那边没有喝热水的习惯，平时喝的水都是冷水，我忽然想起来，之前在斗鱼上看直播，听那些海外留学生介绍是有这么回事。因为自己的英语水平有限，所以也就没和他多聊。</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-4dd039e8a2cbc77e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="西宁站"></p><p>列车在西宁站因为要换火车头，停留时间较长，所以下来透透气，顺便拍一下西宁站的风景。</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-907a7b56b57477ea.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这便是传说中的弥漫式供氧列车Z21"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-aa7ef6f2a06628c1.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="列车与车厢进行接合"></p><p>还有一个挺尴尬的事情要说一下，从北京出发的时候，因为着急赶车，居然忘记取钱了，所以从北京到拉萨的一路上，身无分文的我，看着车厢内卖食品的小推车来回转悠，手机信号不好，不能移动支付，只能干瞪眼看着。幸福总是来得这么突然，列车到西宁的时候，站台上卖的食品可以微信支付，于是我果断买了一盒青海酸奶给自己解解馋。口感挺不错，就是有点小贵，三盒15块钱。从西宁到拉萨的一路上，风景就格外漂亮了，不多说，直接上图。<br><img src="http://upload-images.jianshu.io/upload_images/3340896-78669065449c4513.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远山与白云"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-ffa6ba788ba67e3f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="白云与远山"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-9436df28e4ef9358.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="大美青海湖"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-d7eea52340ba13ed.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="光与影交织下的山峰与草甸"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-92020e0c6c7b61c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在夕阳的映照下，群山看起来棱角分明"><br>一边拍摄，一边惊叹，不知不觉便到晚上。列车到达格尔木，天已经完全黑下来。在格尔木站，列车要更换功率更大的车头，开始晚上的爬坡。在<a href="https://www.bilibili.com/video/av5041137/?from=search&seid=6581890509244381135#page=1">《天路故事》</a>记录片里描述，从格尔木出发的一百五十公里内，列车将会爬升接近两千米，列车也是从此处开始进行弥漫式供氧。</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-99810f8728054f65.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="供氧口"></p><p>列车到达格尔木的时候已经晚上十点多了，下去看一下更换车头，回来洗漱完毕，便去睡觉。（说实话，还是挺担心自己高反的，不过晚上稍微感觉有些喘不过气，慢慢还是进入了梦乡）</p><p><a href="https://www.jianshu.com/p/bb1befb30773">天路旅途(三)</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天路旅途（一）</title>
    <link href="/blog/2017/10/15/%E9%9A%8F%E7%AC%94/%E5%A4%A9%E8%B7%AF%E6%97%85%E9%80%94%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/blog/2017/10/15/%E9%9A%8F%E7%AC%94/%E5%A4%A9%E8%B7%AF%E6%97%85%E9%80%94%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3340896-60da4e7205a94044.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水立方展览的藏族小姑娘油画"></p><p>说起去拉萨，可能跟这幅画有很大关系。有一次我从水立方游完泳，恰好碰到里面举办油画展览，反正也没啥事，于是便去里面逛逛。给我印象最深的就是这幅画，吸引我最深的就是这位藏族小姑娘的那双眼睛，深邃澄澈，给人无限遐想。这幅画唤醒了我对拉萨的兴趣，也为之后的拉萨之行做了一个铺垫。</p><p><img src="http://upload-images.jianshu.io/upload_images/3340896-dbf120add38fbd39.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三极"></p><p>西藏，一个神圣的地方，美丽壮观的雪域高原，一望无际的可可西里，阳光普照的拉萨城，壮丽雄浑的布达拉宫，这一切对于我来讲都充满了吸引力。我比较喜欢逛B站的记录片，有一次看到央视拍的记录片<a href="https://www.bilibili.com/video/av8668069/?from=search&seid=2105442602118330865">《第三极》</a>，里面对西藏的景物，人文，历史，饮食，风俗等多方面做了详细的介绍，让我心驰神往。江西大学生况露单车骑行穿藏的纪录片<a href="https://space.bilibili.com/19515012?from=search&seid=13205517380530848374#!/channel/detail?cid=8399">《行疆》</a>也让我佩服不已。这些记录片让我对西藏这个地方越来越感兴趣。</p><p>上班闲暇之余，在逛简书的时候，无意间看到一篇文章<a href="http://www.jianshu.com/u/54f4e7e9a502">《在西藏支教的日子》</a>，作者的个人简介是这样写的  <strong>“对待工作和生活，不抛头颅，只洒热血。”</strong>我感觉这个作者特有意思，于是便开始细读她的文章，里面主要以日记的形式来展现她在支教期间的生活点滴。作者是东北人，讲话幽默诙谐，却也不乏真情流露，读着读着便上道了，从此便一发不可收拾，找到了当年读连载小说的感觉。里面对藏族小学生活的描述让我充满兴趣。眼看还有一个月要过国庆节了，长假期间恰好可以去拉萨一趟，于是便开始了行前的准备。</p><p>要说准备，其实也没有多上心，从淘宝上买了一袋葡萄糖粉，一袋红景天。入藏最担心的便是高原反应，网上查攻略说红景天可以预防高反，所以我就买了一袋。葡萄糖对高反有一定的缓解作用，主要还是偏预防。出发前的一个月，开始跑步，一方面锻炼自己的耐力，一方面减肥。网上说去拉萨前避免剧烈运动，我也没当回事，还是减肥要紧，要不驮着这一百六七十斤的体重也是一个累赘。因为出行是在国庆，恰好碰到出行的高峰期，而北京到拉萨的火车只有一趟Z21,出发前一个月我就蹲点12306，开始抢票，放票的当天上午8点，眼看着有七八十张卧铺就是无法下单成功。后来几天又陆陆续续抢了几次，一直没有抢票成功，索性就交给万能的淘宝吧，在出行的前一天，终于刷到了，我心里那个激动啊，还以为这趟旅行要泡汤了呢。回到宿舍就赶紧收拾东西。第二天准备出发，坐着火车去拉萨…</p><p><a href="https://www.jianshu.com/p/7ae5ac073849">天路旅途 (二)</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xcode问题</title>
    <link href="/blog/2017/10/10/iOS/Xcode-module-compiled-with-Swift-3-1-cannot-be-imported-in-Swift-3-2--/"/>
    <url>/blog/2017/10/10/iOS/Xcode-module-compiled-with-Swift-3-1-cannot-be-imported-in-Swift-3-2--/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>首先我们的项目是用Xcode 8.3版本写的,第三方库使用Carthage管理,从同事那里拷贝了一个Xcode9的包,然后安装,编译项目就出现了module compiled with Swift 3.1 cannot be imported in Swift 3.2: /User/……Alamofire.framework 这样的报错信息<br> <img src="http://upload-images.jianshu.io/upload_images/3340896-c90dc3fcea0add44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="66C43EBF3CF24F18CCFFCABFC94025ED.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>把旧的Xcode版本删掉,将Xcode 9拷贝到应用程序中, 然后打开终端 cd到项目目录, Carthage update –platform ios,等更新完毕后,重新打开项目, Commend + shift + k, 然后重新编译一下就不报错了.</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Xcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cocoapods</title>
    <link href="/blog/2017/05/18/%E5%B7%A5%E5%85%B7/CocoaPods/"/>
    <url>/blog/2017/05/18/%E5%B7%A5%E5%85%B7/CocoaPods/</url>
    
    <content type="html"><![CDATA[<h3 id="使用CocoaPods"><a href="#使用CocoaPods" class="headerlink" title="使用CocoaPods"></a>使用CocoaPods</h3><h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><p>打开命令行</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> OSX <span class="hljs-number">10.11</span>后安装CocoaPods命令sudo gem install -n <span class="hljs-regexp">/usr/</span>local/bin cocoapods -v <span class="hljs-number">1.9</span>.<span class="hljs-number">0</span></code></pre><h4 id="项目使用CocoaPods"><a href="#项目使用CocoaPods" class="headerlink" title="项目使用CocoaPods"></a>项目使用CocoaPods</h4><ul><li><p>生成Podfile，进入.xcodeproj文件所在目录</p><pre><code class="hljs csharp">pod <span class="hljs-keyword">init</span></code></pre></li><li><p>Podfile</p></li></ul><pre><code class="hljs delphi"><span class="hljs-keyword">platform</span> :ios, <span class="hljs-string">&#x27;8.0&#x27;</span>target <span class="hljs-string">&#x27;AppName&#x27;</span> <span class="hljs-keyword">do</span><span class="hljs-keyword">end</span> </code></pre><ul><li>引入不同的库，并指定版本</li></ul><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;~&gt; 1.1&#x27;</span></code></pre><ul><li>引入非CocoaPods公共Git仓库中的库，并可以指定具体的commit, branch 或者 tag, 编译版本</li></ul><pre><code class="hljs arcade">pod <span class="hljs-string">&#x27;Y&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">git</span> =&gt;</span> <span class="hljs-string">&#x27;https://github.com/NSHipster/Y.git&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">commit</span> =&gt;</span> <span class="hljs-string">&#x27;b4dc0ffee&#x27;</span>pod <span class="hljs-string">&#x27;LookinServer&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">configurations</span> =&gt;</span> [<span class="hljs-string">&#x27;Debug&#x27;</span>]</code></pre><ul><li>引入私有库   </li></ul><pre><code class="hljs awk"><span class="hljs-regexp">//</span>添加私有库地址到本地的cocopods中$ pod repo add REPO_NAME SOURCE_URL<span class="hljs-regexp">//</span>Podfile文件中添加私有库源source <span class="hljs-string">&#x27;URL_TO_REPOSITORY&#x27;</span></code></pre><ul><li>安装所需要的库</li></ul><pre><code class="hljs cmake">pod <span class="hljs-keyword">install</span></code></pre><p>Cocoapods 会你用递归分析所有需求，最后序列化为Podfile.lock（建议将 podfile.lock和.xcworkspace 纳入Git版本管理中，该文件记录这Pod里面相关库的历史安装版本）</p><p>比如，如果两个库都需要使用AFNetworking，CocoaPods 会确定一个同时能被这两库使用的版本，然后将同一个安装版本链接到两个不同的库中。</p><p>CocoaPods 会创建一个新的包含之前安装好的静态库 Xcode 项目，然后将它们链接成一个新的 libPods.a target。你原有的项目将会依赖这个新的静态库。一个 xcworkspace 文件会被创建，从此之后，你应该只打开这个 xcworkspace 文件来进行开发。</p><ul><li>升级指定库</li></ul><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> update <span class="hljs-string">&#x27;C&#x27;</span></code></pre><ul><li>升级私有库</li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">pod repo update REPO_NAME</span></code></pre><ul><li>尝试使用Cocoapod</li></ul><pre><code class="hljs actionscript">pod <span class="hljs-keyword">try</span> <span class="hljs-string">&#x27;D&#x27;</span></code></pre><h3 id="建立自己的CocoaPods"><a href="#建立自己的CocoaPods" class="headerlink" title="建立自己的CocoaPods"></a>建立自己的CocoaPods</h3><h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><p>.podspec文件作为 CocoaPods 的一个独立单元，包含了名称，版本，许可证，和源码文件等所有信息。</p><p>以下是Alamofire的podspec文件内容</p><pre><code class="hljs pgsql">Pod::Spec.<span class="hljs-built_in">new</span> <span class="hljs-keyword">do</span> |s|  s.name = <span class="hljs-string">&#x27;Alamofire&#x27;</span>  s.version = <span class="hljs-string">&#x27;5.3.0&#x27;</span>  s.license = <span class="hljs-string">&#x27;MIT&#x27;</span>  s.<span class="hljs-keyword">summary</span> = <span class="hljs-string">&#x27;Elegant HTTP Networking in Swift&#x27;</span>  s.homepage = <span class="hljs-string">&#x27;https://github.com/Alamofire/Alamofire&#x27;</span>  s.authors = &#123; <span class="hljs-string">&#x27;Alamofire Software Foundation&#x27;</span> =&gt; <span class="hljs-string">&#x27;info@alamofire.org&#x27;</span> &#125;  s.source = &#123; :git =&gt; <span class="hljs-string">&#x27;https://github.com/Alamofire/Alamofire.git&#x27;</span>, :tag =&gt; s.<span class="hljs-keyword">version</span> &#125;  s.documentation_url = <span class="hljs-string">&#x27;https://alamofire.github.io/Alamofire/&#x27;</span>  s.ios.deployment_target = <span class="hljs-string">&#x27;10.0&#x27;</span>  s.osx.deployment_target = <span class="hljs-string">&#x27;10.12&#x27;</span>  s.tvos.deployment_target = <span class="hljs-string">&#x27;10.0&#x27;</span>  s.watchos.deployment_target = <span class="hljs-string">&#x27;3.0&#x27;</span>  s.swift_versions = [<span class="hljs-string">&#x27;5.1&#x27;</span>, <span class="hljs-string">&#x27;5.2&#x27;</span>, <span class="hljs-string">&#x27;5.3&#x27;</span>]  s.source_files = <span class="hljs-string">&#x27;Source/*.swift&#x27;</span>  s.frameworks = <span class="hljs-string">&#x27;CFNetwork&#x27;</span><span class="hljs-keyword">end</span></code></pre><p>一旦把这个.podspec发布到公共数据库中，任何想使用它的开发者，只需要在 Podfile 中加入如下声明即可：</p><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> <span class="hljs-string">&#x27;Alamofire&#x27;</span>, <span class="hljs-string">&#x27;~&gt; 5.0&#x27;</span></code></pre><p>.podspec文件也可以作为管理内部代码的利器：</p><pre><code class="hljs arcade">pod <span class="hljs-string">&#x27;Z&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> <span class="hljs-string">&#x27;path/to/directory/with/podspec&#x27;</span></code></pre><h4 id="发布CocoaPods"><a href="#发布CocoaPods" class="headerlink" title="发布CocoaPods"></a>发布CocoaPods</h4><p>CocoaPods 0.33 中加入了Trunk服务。</p><p>要想使用 Trunk 服务，首先你需要注册自己的电脑。这很简单，只要你指明你的邮箱地址（spec 文件中的）和名称即可。</p><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pod trunk register mattt<span class="hljs-variable">@nshipster</span>.com <span class="hljs-string">&quot;Mattt Thompson&quot;</span></code></pre><p>至此，你就可以通过以下命令来方便地发布和升级你的 Pod！</p><pre><code class="hljs reasonml">$ pod trunk push <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NAME</span>.</span></span>podspec</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://guides.cocoapods.org/">CocoaPods</a></p><p><a href="https://nshipster.cn/cocoapods/">NSHipster</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>依赖管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>友盟三方登录</title>
    <link href="/blog/2017/05/16/iOS/iOS%E5%8F%8B%E7%9B%9F%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
    <url>/blog/2017/05/16/iOS/iOS%E5%8F%8B%E7%9B%9F%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><ul><li>绑定账号</li><li>解绑账号</li><li>校验UID</li><li>校验手机号</li></ul><hr><h1 id="登录流程"><a href="#登录流程" class="headerlink" title="登录流程"></a>登录流程</h1><p><img src="http://upload-images.jianshu.io/upload_images/3340896-3c9abdd048dbc676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登录流程.png"></p><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><ul><li>友盟SDK需要及时更新,4.x,5.x版本可能无法获取到uid</li><li>QQ第三方登录需要向腾讯开发者平台申请QQ统一UID,然后通过腾讯给的接口请求UID;否则,iOS和Android获取的uid是不一样的</li><li>微信第三方登录功能需要登录微信开发者中心,开通第三方登录授权 (付费功能)</li><li>如果集成了友盟分享功能,集成第三方登录只需获取用户信息即可</li></ul><p>// 在需要进行获取登录信息的UIViewController中加入如下代码</p><pre><code class="hljs reasonml">#import &lt;UMSocialCore/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UMSocialCore</span>.</span></span>h&gt;- (void)getUserInfoForPlatform:(UMSocialPlatformType)platformType&#123;    <span class="hljs-literal">[[UMS<span class="hljs-identifier">ocialManager</span> <span class="hljs-identifier">defaultManager</span>]</span> getUserInfoWithPlatform:platformType currentViewController:self completion:^(id result, NSError *error) &#123;        UMSocialUserInfoResponse *resp = result;        <span class="hljs-comment">// 第三方登录数据(为空表示平台未提供)</span>        <span class="hljs-comment">// 授权数据</span>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; uid: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">uid</span>)</span>;        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; openid: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">openid</span>)</span>;        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; accessToken: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">accessToken</span>)</span>;        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; refreshToken: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">refreshToken</span>)</span>;        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; expiration: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">expiration</span>)</span>;        <span class="hljs-comment">// 用户数据</span>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; name: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">name</span>)</span>;        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; iconurl: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">iconurl</span>)</span>;        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; gender: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">gender</span>)</span>;        <span class="hljs-comment">// 第三方平台SDK原始数据</span>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot; originalResponse: %@&quot;</span>, <span class="hljs-params">resp</span>.<span class="hljs-params">originalResponse</span>)</span>;    &#125;];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>友盟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动打包Shell</title>
    <link href="/blog/2017/03/17/iOS/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85Shell%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/"/>
    <url>/blog/2017/03/17/iOS/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85Shell%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>##只打包ipa文件</p><ul><li>下载<code>build.sh</code>文件              <a href="https://github.com/913868456/-">传送门</a></li><li>修改工程目录为你的项目   <code>projectPath=你的工程目录</code></li><li>配置编译模式                     <code>buildConfig=&quot;Debug&quot;  </code> 或 <code>buildConfig=&quot;Release&quot;</code></li><li>在终端下,定位到脚本目录,运行脚本   <code>sh build.sh</code></li></ul><p>##打包ipa文件并且上传到fir.im</p><ul><li>下载<code>build_upTofir.sh</code>文件       <a href="https://github.com/913868456/-">传送门</a></li><li>更改工程目录,配置编译模式(同上)</li><li>配置fir.im Token  <code>fir p $Export_Path -T 你的fir Token</code></li><li>检测ruby版本 <code>ruby -v</code>  ruby版本需大于1.9.3, 不满足更新ruby</li><li>安装fir.im插件  <code>gem install fir-cli</code></li><li>在终端下, 定位到脚本目录,运行脚本  <code>sh build_upTofir.sh</code></li></ul><p>##<strong>注意:</strong><br>需要修改的参数:  <code> projectPath</code>  <code>buildConfig</code> <code>$Export_Path -T</code></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
      <tag>自动打包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 账号续费及证书更新流程</title>
    <link href="/blog/2017/03/16/%E5%B7%A5%E5%85%B7/iOS%E8%B4%A6%E5%8F%B7%E7%BB%AD%E8%B4%B9%E5%8F%8A%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/"/>
    <url>/blog/2017/03/16/%E5%B7%A5%E5%85%B7/iOS%E8%B4%A6%E5%8F%B7%E7%BB%AD%E8%B4%B9%E5%8F%8A%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>  #####  开发者账号会员快到期的时候,苹果会发送给开发者账号的注册邮箱一封邮件,提示用户账号快到期了,及时续费,一般是提前一个月提示用户续费.下面开始介绍续费流程;<br>1.登录开发者账号后,网页上面会有账号过期黄色提示;点击renew your membership ;会跳到支付页面;个人开发者账号是688RMB/年;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-c84af4890fcb7576.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>2.选择continue;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-f211f9428c8d363f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>3.购买详情,选择continue,然后点击购买<br> <br><img src="http://upload-images.jianshu.io/upload_images/3340896-8cd11c2ff508d2f6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br> <br><img src="http://upload-images.jianshu.io/upload_images/3340896-071e0e01c3d430cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>4.使用visa 或者 万事达信用卡支付,填写好发票信息就ok了,需要纸质发票的选择纸质发票;购买完后,苹果会发邮件告诉你续费成功.然后就是接下来的更新证书流程了.<br><img src="http://upload-images.jianshu.io/upload_images/3340896-f65f7b4cc0565609.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br> <br> ###   续费后证书更新流程,首先得描述一下各个证书的定位，作用，这样在制作的时候心中有谱，对整个流程的把握也会准确一些<br>1、开发者证书（分为开发和发布两种，类型为<a href="http://lib.csdn.net/base/1">iOS</a> Development,ios Distribution），这个是最基础的，不论是真机调试，还是上传到appstore都是需要的，是一个基证书，用来证明自己开发者身份的；<br>2、appID,这是每一个应用的独立标识，在设置项中可以配置该应用的权限，比如是否用到了PassBook,GameCenter,以及更常见的push服务，如果选中了push服务，那么就可以创建生成下面第3条所提到的推送证书，所以，在所有和推送相关的配置中，首先要做的就是先开通支持推送服务的appID;<br>3、推送证书（分为开发和发布两种，类型分别为APNs Development ios,APNs Distribution ios）,该证书在appID配置中创建生成，和开发者证书一样，安装到开发电脑上；<br>4、Provisioning Profiles,这个东西是很有苹果特色的一个东西，我一般称之为PP文件，该文件将appID,开发者证书，硬件Device绑定到一块儿，在开发者中心配置好后可以添加到Xcode上，也可以直接在Xcode上连接开发者中心生成，真机调试时需要在PP文件中添加真机的udid；是真机调试和必架必备之珍品；<br>平常我们的制作流程一般都是按以上序列进行，先利用开发者帐号登陆开发者中心，创建开发者证书，appID,在appID中开通推送服务，在开通推送服务的选项下面创建推送证书（服务器端的推送证书见下文），之后在PP文件中绑定所有的证书id,添加调试真机等；<br>###下面开始申请证书<br> 1.将原来快要过期或者已经过期的测试证书.发布证书. Provision Profile文件等跟该AppID相关的证书和PP文件revoke;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-a97820d267527d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>2.创建开发者证书;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-5f43433de9e5d5bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-b2725fd7db2e92f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>选择continue,然后要求上传CSR文件,这里解释一下CSR文件,全称Certificate Signing Requst ,苹果公司要知道是谁在请求证书,需要请求者进行签名;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-f913802a5e2ca432.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>CSR文件生成方法,打开钥匙串;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-5c4407a763055aee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-177df67ecf5ed162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>选择存储到磁盘;<br> 然后上传CSR文件,点击generate,就会生成开发者证书;然后下载,存到指定文件夹下,双击安装证书;<br>2.同理生成发布证书,同样流程创建开发推送证书和发布推送证书;选择开发推送证书类型<br><img src="http://upload-images.jianshu.io/upload_images/3340896-1c62d3f7275ae169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>然后选择appID;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-185bdbaa7f22c17a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>上传CSR文件,点击generate 就生成开发环境的推送证书;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-35c8b7666789eb75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>同理生成发布环境的推送证书;<br>3.生成发布和推送证书后,可以去查看推送服务是否激活; <br> <img src="http://upload-images.jianshu.io/upload_images/3340896-7f7a15afa3c997e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br> 激活后,创建Provision Profile文件,简称PP文件;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-9b55694b0e1d0467.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-fe6f70f2c6a7b15c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-ca7b60ee04269861.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-eea56e362aad9353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="http://upload-images.jianshu.io/upload_images/3340896-f30b174c576adeff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>填写名称,continue就ok了;同理创建发布环境PP文件;下载双击安装即可;<br><img src="http://upload-images.jianshu.io/upload_images/3340896-f2f8121e8ae46822.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br>致此,完毕. </p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>证书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用正则表达式</title>
    <link href="/blog/2017/03/16/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/blog/2017/03/16/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>##参考链接<br><a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVN 配置</title>
    <link href="/blog/2017/03/16/%E5%B7%A5%E5%85%B7/MAC-svn-%E9%85%8D%E7%BD%AE%E5%8F%8Acornerstone/"/>
    <url>/blog/2017/03/16/%E5%B7%A5%E5%85%B7/MAC-svn-%E9%85%8D%E7%BD%AE%E5%8F%8Acornerstone/</url>
    
    <content type="html"><![CDATA[<p>SVN 配置</p><p>1、创建SVN Repositroy<br>打开终端 输入：svnadmin create /path/svn/pro<br>svn是目录，pros是版本库，输入完成即可看见生成文档<br>2、配置svn用户权限。<br>/path/svn/pro/conf/目录下存在3个文件：authz,passwd,svnserve.conf<br>（1) 配置svnserve.conf<br>将里面的<br>＃anon-access = read<br>＃auth-access = write<br>＃password-db = passwd<br>＃authz-db = authz<br>四行前的＃号去掉，再将anon-access = read改为anon-access = none，这样禁止匿名访问<br><strong>注意</strong>:</p><ul><li>这句话必须使用，这样子才能显示Log的信息</li><li>在＃号后是有空格的，去掉空格，上文字顶格,否则也有错误<br>（2)  配置passwd<br>里面存的是用户与密码，有示例，直接按照它的格式添加用户和密码就可以了<br>test1=123<br>test2=456<br>（3)   配置authz<br>[groups] 后面跟的是用户组设置，可以将你在passwd里设置的用户添加到不同的用户组里，那么之后，可以对不同用户组设置不同的权限，以免多用户设置麻烦，多个用户用,号分隔。可按它的示例做<br>[groups]<br>testgroups=test1,test2</li></ul><p>之后，可以对不同的版本库进行权限设置，底下有一个示例，按它的写法写就可以了，如果需要对所有的版本库设置，利用[/]就可以了。如：<br>[/]<br>@testgroups=rw<br>个人配置只需在[/]下面添加<br>用户名=rw即可<br><strong>PS</strong>：用户组前要用@符号，如果是用户，直接写用户名就可以了。rw代表可读写，显然只读就是r了<br>3、启动SVN服务<br>svnserve -d -r /path/svn  特别注意，路径一定是SVN的目录，不是其中一个版本库的目录，不然，能正常启动，就是访问有问题<br>没有任何输出，则启动成功<br>4.配置conrnerStone<br>点击ConerStone左下角 如下图的“+”，添加SVN地址，<br>需要填写的方格<br>server： IP地址 不包括Svn后面的其他路径 例如：主机IP 192.168.。。。<br>Repisitory path:Ip后面的路径  例如：上文的Pro<br>Name：用户名<br>Password：密码<br>5.让SVN支持.a文件的上传<br>（1）打开终端：vi ~/.subversion/config 打开config文件<br>（2）找到：</p><p>#global-ignores = *.o <em>.lo *.la *.al .libs *.so *.so.[0-9]</em> *.a *.pyc *.pyo </p><h1 id="rej-swp-DS-Store"><a href="#rej-swp-DS-Store" class="headerlink" title=".rej ~ ## .# .*.swp .DS_Store"></a><em>.rej <em>~ #</em># .#</em> .*.swp .DS_Store</h1><p>这是svn默认的忽略列表，更改这个即可上传和下载被忽略的文件<br>去掉开头第一行的#和#前面的空格，第一行global前面不能有空格。<br>去掉第二行的#，空格不用管。<br>删除上问红色的*.a，这样即可上传.a文件。</p><p>#<strong>Cornerstone Svn简单使用指南</strong></p><p>一、安装并拷贝项目</p><p>1.第一步：安装svn.<br>2.第二步：第一个使用svn，找到“Check Out Working Copy”选项，选择并点击。<br>目的：从服务器上拷贝一份全新的项目工程。<br>3.第三步：可以正常使用了。。。</p><p>二、在项目中使用</p><p>1.查看日志<br>找到“Log”选项，选择并点击。<br>查看自己当前的版本是否是最新的，如果不是最新的版本，从第2步开始执行；<br>如果自己当前的版本是最新的，从第3步开始执行；<br>2.更新到最新版本<br>当前程序员在打开工程项目之前，找到“Update to Latest Revision”选项，选择并点击。<br>目的：保持当前程序员客户端的项目版本是最新的。<br>3.编辑项目<br>4.提交之前，再次点击“Update to Latest Revision”，保持项目是最新版本。<br>5.更新最新版本后，如果有错误，冲突等情况，解决，直到没错误！<br>6.提交项目，找到“Commit Changes”选项，选择并点击。<br>目的：把当前编辑后的项目提交的服务器。<br>三、”lock”和“unlock”的使用<br>当我们正在编辑某个文件时，为了防止被其他人修改，可以在编辑之前，使该文件处于锁定状态，当我们编辑后，要提交的时候，再解锁。<br>四、每次提交项目，都要写详细备注并署名。<br>五、恢复到以前的版本，以前其他出错情况，请参考稍后的文档说明或上网搜索。<br>Cornerstone的逻辑很清晰，界面打开后，左边栏上下分开，上面是working copies的列表，下面是REPOSITORIES的列表。常见的功能基本上跟windows一样，在上下文中可以得到。</p><p>1、连接到HTTP server</p><p>RESPOSITORIES栏上，标题栏的右手边有+和-，点击+号（如果第一次打开这个软件，这一步会自动跳出来），出现的对话框中，选择HTTP Server</p><p>Server：http server的地址<br>Port: 空着就可以</p><p>Repository path: 填入http server的Repository地址。一般这个地址，开源项目host在你创建项目后都会给你地方拷贝。</p><p>提示：在这个栏目下面，有一行最后形成的地址，你可以跟开源项目给你的路径看一下是否一致。</p><p>NickName: 空着就可<br>Name: 填入登录的账户名称<br>Password: 填入登录的密码</p><p>然后点击Add，就可以把这个Repository加入了。 </p><p>2、Check out<br>按照1做好自己的REPOSITORIES，选中一个的时候，左上角的Check Out就会高亮，点击该图标，就会出现一个路径选择的对话框。填好相应的地方后，就开始check out了。<br>##<strong>注意</strong>：<br>**<em>第一次在check out没有完成之前，你选择的本地work space目录是不会出现在 working COPIES上的。**</em><br>3、Commit delete file<br>先把本地的文件删除，然后在cornerstone的working copies栏目中，找到相应的文件所在的位置，可以看到这个文件有个M标志，表示missing。在该文件上右键点击，上下文菜单中找到Delete，然后确认。刚才的M标识换成了D，表示Deleted。这个时候你就可以commit了。<br>4、Relocate<br>如果服务器上改了原始的某个目录的路径，那么在WORKING COPIES上，右键可以找到Relocate To，后面会跟上相应的目录，点击就可以重新定位。定位好后，相应的REPOSITORIES会自动更改。 </p><p>##参考：</p><p>  <a href="http://www.tuicool.com/articles/n6fyq2">conerStone的配置及使用说明</a><br><a href="http://www.cnblogs.com/onlyfu/archive/2012/05/08/2489814.html">MAC下配置SVN</a><br><a href="http://blog.csdn.net/wisdom605768292/article/details/19068601">http://blog.csdn.net/wisdom605768292/article/details/19068601</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SVN</tag>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XAMPP 权限问题</title>
    <link href="/blog/2017/03/16/PHP/mac-XAMPP%E7%8E%AF%E5%A2%83%E4%B8%8B,-%E4%BD%BF%E7%94%A8php%E5%87%BD%E6%95%B0mkdir()%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9B%AE%E5%BD%95(%E6%96%87%E4%BB%B6)%E6%8A%A5%E9%94%99,%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF-permission-denied;/"/>
    <url>/blog/2017/03/16/PHP/mac-XAMPP%E7%8E%AF%E5%A2%83%E4%B8%8B,-%E4%BD%BF%E7%94%A8php%E5%87%BD%E6%95%B0mkdir()%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9B%AE%E5%BD%95(%E6%96%87%E4%BB%B6)%E6%8A%A5%E9%94%99,%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF-permission-denied;/</url>
    
    <content type="html"><![CDATA[<p><strong>我的解决方法</strong>:</p><ol><li><p>打开”应用程序”文件夹;</p></li><li><p>定位到 XAMPP 文件夹;</p></li><li><p>右击, 选择-&gt;显示简介;</p></li><li><p>在弹出框中选择-&gt;”共享与权限”;</p></li><li><p>点击右下角 🔐 标志;</p></li><li><p>输入管理员密码</p></li><li><p>将everyone 权限改为”读与写”;</p></li><li><p>点击 +- 右边的 “设置” 按钮,选择-&gt;”应用到包含的项目”; 重新点击🔐 加锁;</p></li><li><p>关闭简介窗口</p></li></ol><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>PHP 创建文件目录权限设置</p>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
      <category>XAMPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xcode Debug 问题</title>
    <link href="/blog/2017/03/16/iOS/swift%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEDebug%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/"/>
    <url>/blog/2017/03/16/iOS/swift%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEDebug%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>在调试程序时，很多开发者喜欢用输出 log 的方式对代码的运行进行追踪，帮助理解。Swift 编译器并不会帮我们将 print 或者 debugPrint 删去，在最终 app 中它们会把内容输出到终端，造成性能的损失。我们当然可以在发布时用查找的方式将所有这些log 输出语句删除或者注释掉，但是更好的方法是通过添加条件编译来将这些语句排除在 Release 版本外。在 Xcode 的 Build Setting 中，在 Other Swift flags 的 Debug 栏中加入 -D DEBUG 即可加入一个编译标识。<br><img src="https://onevcat.com/assets/images/2016/debug-flag.png"><br>之后我们就可以通过将<code> print</code> 或者 <code>debugPrint </code>包装一下：</p><pre><code class="hljs applescript">fuc Dlog (<span class="hljs-built_in">item</span> : Any, <span class="hljs-built_in">file</span> : String = <span class="hljs-comment">#file, lineNum : Int = #line)&#123;</span>   <span class="hljs-comment">#if DEBUG </span>       let fileName = (<span class="hljs-built_in">file</span> <span class="hljs-keyword">as</span> NSString).lastPathComponent        print (<span class="hljs-string">&quot;fileName:\(fileName)\n lineNum:\(lineNum)\n \(item)&quot;</span>)   <span class="hljs-comment">#endif</span>&#125;</code></pre><p>这样，在 Release 版本中，dPrint 将会是一个空方法，所有对这个方法的调用都会被编译器剔除掉。需要注意的是，在这种封装下，如果你传入的 items 是一个表达式而不是直接的变量的话，这个表达式还是会被先执行求值的。如果这对性能也产生了可测的影响的话，我们最好用 @autoclosure 修饰参数来重新包装 print。这可以将求值运行推迟到方法内部，这样在 Release 时这个求值也会被一并去掉：</p><pre><code class="hljs livescript">func Dlog<span class="hljs-function"><span class="hljs-params">(@autoclosure item: () -&gt; Any, file : <span class="hljs-built_in">String</span> = #file, lineNum : Int = #line)</span> &#123;</span><span class="hljs-function">    #<span class="hljs-title">if</span> <span class="hljs-title">DEBUG</span></span><span class="hljs-function">         <span class="hljs-title">let</span> <span class="hljs-title">fileName</span> = <span class="hljs-params">(file <span class="hljs-keyword">as</span> NSString)</span>.<span class="hljs-title">lastPathComponent</span> </span><span class="hljs-function">         <span class="hljs-title">print</span> <span class="hljs-params">(<span class="hljs-string">&quot;fileName:\(fileName)\n lineNum:\(lineNum)\n \(item)&quot;</span>)</span></span><span class="hljs-function">    #<span class="hljs-title">endif</span></span><span class="hljs-function">&#125;</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">Dlog</span><span class="hljs-params">(resultFromHeavyWork())</span></span><span class="hljs-function">// <span class="hljs-title">Release</span> 版本中 <span class="hljs-title">resultFromHeavyWork</span><span class="hljs-params">()</span> 不会被执行</span></code></pre><p>##参考<br>   <a href="https://onevcat.com/2016/02/swift-performance/">Swift 性能探索和优化分析</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Xcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
